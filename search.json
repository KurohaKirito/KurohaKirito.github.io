[{"title":"工作中常用的一些 ADB 命令","url":"/computer/computer_adb.html","content":"\n\n🌰查看指定进程包名的内存使用情况adb shell dumpsys meminfo [pkg/pid]\n🌰Unity 以 OpenGL 模式启动-force-gles\n🌰删除 Git 中的空目录git clean -fd\n🌰查询第三方包体adb shell pm list packages -3\n🌰ADB 安装包体adb install C:/a.apk\n🌰Unity 日志 ( : 后为筛选符, 常用 I, W, E )adb logcat -s Unity:E 或 adb logcat -s Unity\n🌰输入文本 ( 光标在输入框内时命令才会生效 )adb shell input text *******\n🌰国内版 Profileradb forward tcp:34999 localabstract:Unity-com.sofunny.ChickenDEV\nadb forward tcp:34999 localabstract:Unity-com.sofunny.chickendinnerfirst\nadb forward tcp:34999 localabstract:Unity-com.sofunny.Sausage\n🌰海外版 Profileradb forward tcp:34999 localabstract:Unity-com.GlobalSoFunny.Sausage\nadb forward tcp:34999 localabstract:Unity-com.GlobalSoFunny.BetaSausage\n🌰查看移动端设备的 CPU 型号adb shell getprop ro.product.cpu.abi\n🌰移动端设备的 CPU 型号 (移动端需要节能, 因此只能使用精简指令集的 ARM 架构)\n\n\nCPU 型号\n位数\n架构\n备注\n\n\n\narmeabi-v8a\n64 位\narmv8 架构\n主流\n\n\narmeabi-v7a\n32 位\narmv7 架构\n\n\n\narmeabi\n32 位\narmv5 和 armv6 架构\n\n\n\nx86_64\n64 位\nx86_64 架构\n\n\n\nx86\n32 位\nx86 架构\n\n\n\n🌰获取某个应用进程的 PIDadb shell ps\nadb shell &quot;ps |grep Sausage&quot;\n🌰查看 OpenGL ES 版本adb shell getprop ro.opengles.version\n\n\n\nro.opengles.version\nandroid:glEsVersion\nOf OpenGL ES version\n\n\n\n65536\n0x00010000\nOpenGL ES 1.0\n\n\n65537\n0x00010001\nOpenGL ES 1.1\n\n\n131072\n0x00020000\nOpenGL ES 2.0\n\n\n196608\n0x00030000\nOpenGL ES 3.0\n\n\n196609\n0x00030001\nOpenGL ES 3.1\n\n\n196610\n0x00030002\nOpenGL ES 3.2\n\n\n","categories":["Computer"],"tags":["ADB"]},{"title":"记录一次 U 盘损坏并成功进行数据恢复的历程","url":"/computer/computer_desk.html","content":"\n\n👻现象先说下当时 U 盘的现象. 当时 U 盘可以正常识别, 不过识别率是有所下降的, 得好好插一下才能识别出来, 哈哈\nU 盘可以识别, 然后里面的文件也是可以看到列表的. 打开文件也没有什么问题, 没有尝试直接在 U 盘中运行程序, 所以这点就不清楚了\n至此可以看到 U 盘和正常 U 盘并没有什么区别, 但是当我复制或者剪切后粘贴时, 就会频繁掉盘. 在一次复制或者剪切的过程中, 大概每 1 MB 就会掉盘, 所以文件根本复制不出来\n总结一下: 文件可访问, 可打开, 可复制粘贴, 也可预览压缩包, 几乎和正常无异, 但操作大文件必然掉盘, 无论复制粘贴, 还是剪切粘贴都会\n👀恢复过程 - 寻找思路因为没有办法进行文件操作, 加上我也不懂数据恢复这一块, 所以我就问 AI 有没有其他的办法, AI 回复说可以越过 &quot;文件&quot; 这个概念, 直接将整个 U 盘的扇区拷贝出来\n🍉恢复过程 - 步骤一我们直接开始执行思路, 将整个 U 盘的扇区完整复制到一个 img 镜像文件中\n使用工具: DMDE 按理来说 HDD Raw Copy 应该也可以, 但是我使用后失败了\n打开 DMDE 切记这里要选择 物理设备 为什么选择物理设备呢, 因为会掉盘呀, 哈哈, 所以不能选逻辑磁盘\n之后点击 &quot;工具&quot;, 选择 &quot;复制扇区&quot;, 在弹出的窗口中, &quot;来源&quot; 这一项会自动设置好, 关键是 &quot;目的地&quot; 这项\n设置 &quot;目的地&quot; 时要点击 &quot;文件&quot;, 选择一个合适的目录, 当然记得把后缀改为 &quot;img&quot;\n之后就是等待了, 在复制的过程中, 因为 U 盘会频繁掉盘, 所以工具就会频繁等待 U 盘自动重连, 因此会花费很长时间, 耐心等待吧\n因为是直接复制整个扇区, 所以 U 盘多大, 复制出来就有多大, 比如 64GB 的 U 盘, 即使你的文件只有 1GB, 复制出来的镜像文件也是 64GB, 你可以理解为这一步直接创建了一份虚拟 U 盘, 和你的物理 U 盘一模一样的\n🎄恢复过程 - 步骤二前面我们已经把整个 U 盘移动到电脑上了, 这样我们就可以随意处置其中的数据啦! 下面是我当时复制出来的镜像文件截图\n\n首先需要将 img 文件挂载为虚拟磁盘, 这样我们就可以像磁盘一样, 处理这个 img 文件了, 这里使用的工具是 OSFMount\n🤠恢复过程 - 步骤三先说明下, 这一步不一定需要, 前面我们已经将 img 文件挂载为虚拟磁盘了, 这一步我们需要打开虚拟磁盘, 查看里面的文件, 看看是否有丢失\n如果确实存在文件丢失, 可以进行文件恢复, 恢复时不用选择真正的 U 盘, 因为现在的虚拟磁盘和你的 U 盘是完全一致的, 虚拟磁盘就是完全拷贝的 U 盘扇区, 所以直接对虚拟磁盘进行数据恢复即可, 使用 DiskGenius 工具\n从这一步的数据恢复中我得到一个教训, 长时间存储文件时不要使用 7z! 不要使用 7z! 不要使用 7z!\n🦄恢复过程 - 步骤四既然文件也已经检查过没有问题了, 剩下的就很简单了, 直接将虚拟磁盘中的文件全部拷贝出来就可以了, 至此, U 盘中的数据就完全恢复出来了, 旧的 U 盘可以处理掉了\n","categories":["Computer"],"tags":["数据恢复"]},{"title":"理解计算机中的字符编码","url":"/computer/computer_char_code.html","content":"\n\n🌠前言今天再一次体会到了 基础知识不扎实会带来无数的问题与困扰 这句话是多么地真实 ! ! 事情起因是我想巩固一下 SQL 知识, 于是用 SQL Developer 工具开始写 SQL, 但是当我用 SQL Developer 打开一个之前在 PL&#x2F;SQL 上编辑的 SQL 文件的时候, 里面所有的中文全部乱码了 ! ! 我就知道我必须要解决 编码 这个困扰我许久的问题了. 于是上网搜索资料, 最后总结如下, 我使用了编码的发展顺序来组织文章结构 ( 大概, 或许, 应该, 差不多是这么个发展顺序吧, 哈哈 ! ), OK, 我们开始.\n字符集 和 编码规则有两件事必须在最开始就要点出, 这也是这篇文章的重心所在.\n\n字符集和编码规则是完全不同的两种事物:\n\n字符集: 为每一个字符分配一个唯一的 ID.\n编码规则: 定义如何将之前定义的 ID 转换为计算机中的字节序列的一整套规则.\n这里不需要特别明白, 只需要知道有这样一个区别即可, 后面根据实例来理解它们会更容易.\n\n字符集和编码规则仅在讨论计算机存储时有效.\n\n计算机基础在计算机内部, 所有信息最终都是一个二进制值. 每一个二进制位 (bit) 有 0 和 1 两种状态, 因此八个二进制位就可以组合出 256 种状态, 这被称为一个字节 (byte). 也就是说, 从 0X00 到 0XFF 的一个字节一共可以用来表示 256 种不同的状态, 如果让每一个状态对应一个符号, 就是 256 个符号.\nASCII于是美国就率先制定了一套字符编码, 来解决英语字符与二进制位之间的关系, 并做了统一规定. 这被称为 ASCII, 即 美国信息交换标准代码, 一直沿用至今.\n由于 ASCII 提出的时候, 字符集和编码规则这两个概念尚未区分, 于是 ASCII 既表示字符集又表示编码规则. 不过为了好理解, 我们这里来一波强行解释! 上图!\n\nASCII 字符集上图中的 Bin 和 缩写/字符 这两列就是字符集, 一共规定了 128 个字符以及这 128 个字符的 ID.\n字符集就只是负责这个工作, 即给每个要表示的字符分配一个 ID, 创建一种映射关系, 至于这个 ID 在计算机中怎么储存, 是用 1 个字节还是 2 个字节还是可变长度字节是不需要字符集去考虑的. 即使是仅仅只有 128 个字符的 ASCII 字符集, 我在电脑中就喜欢用 2 个字节表示, 我硬盘空间有的是, 我就喜欢 1 个字节表示字符, 另 1 个字节在旁边站岗, 谁又管的着呢? 虽然这很蠢!\nASCII 编码规则\n① 每个字符都使用 1 个字节表示.\n② 这个字节的首位始终为 0.\n\nASCII 字符集经过编码规则的限制之后, 在计算机中就表示为了: 0000.0000 到 0111.1111.\n这样应该就有点明白字符集和编码规则的区别了吧. 其实当时那个年代 字符集 和 编码规则 这两个概念还没有明确建立, 因为没必要区分开, 默认情况下, 字符集所定义的 ID 的二进制形式就直接是编码规则, 但是随着时代的发展, 明确建立这两个概念就很有必要了. 比如后来提出的 Unicode 字符集, 在 2020 年 3 月的 ISO/IEC 10646:2020 版本中, 总共有 143924 个字符, 其中部分字符会占用 4 个字节, 总不能还是使用 字符集所定义的 ID 的二进制形式就直接是编码规则 这种简单的对应了吧, 因为这样的话所有的字符都要用 4 个字节, 原来只需 1 个字节的英文字母现在需要 4 个字节, 原来只需要 2 个字节的汉字现在也需要 4 个字节, 而且 Unicode 编码还在不断地补充进化, 所以这样实在是太浪费空间了! 我还要用硬盘存放珍贵的电影资源呢! 更大的影响是在网络传输方面, 原本只需传输 1 MB 的数据量, 现在却要传输 4 MB, 这太浪费带宽了!\n[注] ASCII 是后面一切编码的基础, 因此即使字符编码不断发展, 发展后的它们也都会考虑到和 ASCII 的兼容性, 因此你会看到后面的编码都会做出一些相应的措施来兼容 ASCII.\n扩展版 ASCII随着计算机的普及, 计算机进入了欧洲国家, 但是 ASCII 中不包含其他语言的字符啊! 像希腊字母, 罗马字母等. 那么这些欧洲国家就很难受啊! 正好 ASCII 只使用了 1 个字节的后 7 位, 于是, 一些欧洲国家就决定, 利用 ASCII 编码规则中闲置的最高位编入新的符号 ( 你美国人不是才用了半个字节吗, 那好, 剩下的半个字节由我们来定义 ). 这样一来, 这些欧洲国家使用的编码体系, 就可以表示 256 个字符, 我们称之为 扩展版 ASCII.\n扩展版 ASCII 字符集扩展版 ASCII 字符集规定了 256 个字符. 其中 128 个字符直接沿用了 ASCII, 以达到兼容的目的, 剩下的 128 个字符是欧洲国家自己定义的字符. 当然由于每个国家语言不同, 对于这 128 个字符, 不同的国家自然有不同的定义, 那么肯定也会有它们独特的称呼, 但本质上它们都属于扩展版 ASCII 字符集🤣. (是不是感觉开始出现了混乱的味道? 嗯哼~) 但是不管怎样, 所有这些扩展版 ASCII 字符集中, 0 ~ 127 表示的符号是一样的, 不一样的只是 128 ~ 255 这些字符.\n扩展版 ASCII 编码规则\n① 每个字符使用 1 个字节表示.\n\n于是扩展版 ASCII  字符集经过编码规则的限制之后, 在计算机中就表示为了: 0000.0000 到 1111.1111. ASCII 和扩展版 ASCII 两者之间互不冲突, 相安无事.\n从扩展版 ASCII 开始, 这种命名就具有了表示一个大类的意味, 在这个大类下, 具体会细分成很多字符集, 比如, 意大利有意大利的扩展版 ASCII, 法国有法国的扩展版 ASCII, 瑞士有瑞士的扩展版 ASCII. 其中最优秀的字符集扩展方案是 ISO 8859-1, 通常称之为 Latin-1, Latin-1 利用 128 ~ 255 这 128 个二进制数, 包括了足够的附加字符集来涵盖基本的西欧语言, 同时在 0 ~ 127 的范围内兼容 ASCII 编码规则.\nANSI之后, 计算机进入了亚洲国家, 亚洲国家使用的符号就更多了, 其中我国的汉字就接近十万个! 常用字也有四千多个. 由于前面的 ASCII 和扩展版 ASCII 的单字节字符集只能表示 256 种符号, 这对于我们博大精深的汉语来说是肯定不够的, 于是单字节不行, 就必须使用多字节. 于是就诞生了一系列的多字节字符集, 其中一类就叫做 ANSI 字符集.\nANSI 字符集是从 0X0000 定义到 0XFFFF, 理论上来说, 只要全部的字符都使用 2 个字节表示, 就可以包含 65536 个字符 (但是实际的编码规则不会这么简单直接), 这对于任何单个国家的字符需求来说, 都能基本满足了.\nANSI 字符集定义了要表示的字符以及对应的 ID, 但是并不意味着将这些字符编到计算机中的时候会遵守 字符集所定义的 ID 的二进制形式就直接是编码规则 的游戏规则. 就比如后面会提到的 GB 2312 字符集使用的 EUC-CN 编码规则, 半角字符只占 1 个字节, 汉字和全角字符才会占用 2 个字节 (是不是已经开始有点晕了😵).\n[注] 网络上有人说 ANSI 字符集是 ASCII 字符集 的扩展, 我想他应该是把我前面所提到的 ASCII 字符集和 ASCII 扩展字符集都统称为了 ASCII 字符集, 于是得出了他的这个结论. 我认为我的说法和他的说法没有绝对的谁对谁错, 只是不同的两种理解. 在现在这个信息交流如此便利的时代, 我也希望大家在非原则问题上不要过于较真. 不过本文中一直采用的是我自己的看法, 即 ASCII 字符集和 ASCII 扩展字符集不统称为 ASCII 字符集. 接下来让我们回到正题.\nANSI 字符集ANSI 字符集中包含的字符具体是什么不好说, 因为不同国家的 ANSI 字符集包含的字符是不一样的, 和当时的 ASCII 扩展字符集的发展轨迹相同, 对于 ANSI 字符集, 不同的亚洲国家同样设计了他们各自的字符集 (这里我终于搜索到这些细分的 ANSI 字符集所对应的名字了 😂), 比如日本的 ANSI 字符集叫做 JIS X 0208, 韩国的叫做 KS X 1001, 我国的 ANSI 字符集叫做 GB 2312, 释义为: 信息处理交换用汉字编码字符集基本集. 下面简单说一下 GB 2312 中所规定的字符集内容.\nGB 2312 共收录 6763 个汉字, 其中一级汉字 3755 个, 二级汉字 3008 个, 同时收录了包括拉丁字母, 希腊字母, 日文平假名及片假名字母, 俄语西里尔字母在内的 682 个字符.\nGB 2312 的出现, 基本满足了汉字的计算机处理需要, 它所收录的汉字已经覆盖中国大陆 99.75% 的使用频率.\nANSI 编码规则\n① 不同的 ANSI 字符集会规定其独特的编码规则.\n\n这个还真的都不一样, 但是也都是有基准的. 比如我国的 GB 2312 字符集使用的 ANSI 编码规则叫做 EUC-CN, 日本的 JIS X 0208 字符集在 Windows 上使用的 ANSI 编码规则叫做 EUC-JP, 韩国的 KS X 1001 字符集使用的 ANSI 编码规则叫做 EUC-KR. 这些编码规则都是 EUC 类的编码规则.\n是不是头都大了? 😂 只要知道不同的 ANSI 字符集 会采用一些不同的编码规则即可.\n总结一下, ANSI 是一类字符集的统称, 不同的国家有其自己的 ANSI 字符集, 不同的字符集也会对应不同的编码规则, 同样编码规则也都有各自的名称.\n有人可能会问, 后面不是会出现 Unicode 这种全球统一的字符集吗, 那为什么还要继续使用和发展 ASNI 这种国家之间无法兼容的字符集呢? 这个问题呢我后面会解答.\nUnicodeASNI 出现之后, 各个国家的字符需求基本都解决了, 但是因为每个国家制定了他们各自的字符集和对应的编码方案, 所以各个国家之间的字符集不通用, 于是制定一套全球统一编码的呼声越加强烈! 最后 ISO 即 国际标准化组织 实在看不下去了, 为了解决不同国家 ANSI 的冲突问题, ISO 就制定了一套全球统一编码, 即 Unicode.\nUnicode 时代的时候, 字符集和编码规则就已经很明确了, Unicode 仅仅只是一种字符集. 其中定义了全世界所有符号的唯一标识 ID, 并且一直在不断地修订. 2020 年 3 月的 ISO/IEC 10646:2020 标准中, 已经包含了 143924 个字符.\n如果使用简单的 字符集所定义的 ID 的二进制形式就直接是编码规则 的方法来存储 Unicode 字符集, 将会造成极大的浪费, 于是为了解决 Unicode 这个庞大字符集的存储和网络传输问题, 对应 Unicode 字符集的编码规则就出现了. 其中最常用的就是 UTF-8 编码规则了. 其他的编码规则还有 UTF-16 BE, (Big-Endian 大端序) UTF-16 LE (Little-Endian 小端序), UTF-32, UTF-7, Punycode, CESU-8, SCSU, GB18030 等等.\n对于之前说的为什么还要继续使用 ANSI 字符集的原因是, Unicode 下的各种编码规则, 对于常用汉字, 基本上都是占用 3 个字节, 生僻汉字可能占用到 6 个字节. 对于 GB2312 和 GBK 来讲, UTF-8 无疑造成了浪费, 所以, UTF-8 可以说是对英文友好, 但对中文不友好的一种编码方式. 所以在中文界,  GB2312 与 GBK 依旧有自己的市场. 但是按照目前的趋势来看, 硬盘都是白菜价, 电脑性能也已经足够无视这点性能的消耗了. 所以推荐所有的网页使用统一编码: UTF-8.\n其中关于 UTF-8, GB18030 内部的具体编码规则就不展开说了 (其实我也不会, 哈哈), 有兴趣的可以自己搜索资料, 维基百科就是一个比较好的选择.\n总结\n美国人为了表示日常用的字符, 制定了 ASCII 字符集.\n欧洲人为了表示日常用的字符, 扩充了 ASCII 字符集.\n中国人为了表示常用简体汉字, 制定了 GB2312 字符集.\n中国人为了表示生僻汉字和繁体字, 扩充 GB2312 字符集为 GBK 字符集.\nISO 为了统一全世界的字符, 制定了全球字符集 Unicode, 目标为包含世界上全部的字符.\n为了方便 Unicode 的传输和存储, 制定了 UTF-8, UTF-16 等一系列编码规则.\n\n💖 举例现在在程序编码过程中, 你的一个变量被赋值了这样一个字符串, \\u5730\\u7403\\u002c\\u0020\\u7531\\u6211\\u6765\\u5b88\\u62a4\\u0021, 考虑下面几个问题:\n\n这一串字符串使用了什么字符集?\n这一串字符串使用了什么编码规则?\n使用什么规则对其解码? 字符集映射, 还是编码规则?\n\n\n解析:\n这只是一串字符串, 我们并没有在讨论它的计算机存储方式, 因此字符集和编码规则统统无意义. 如果此时此刻这串字符串储存在计算机中, 此处的讨论才会有意义, 字符集及其编码规则全都是在讨论计算机如何存储字符的, 如果不讨论存储便没有意义.\n对其解码需要使用 Unicode 字符集映射, 原因就是因为这是 Unicode 中对字符定义的 ID, ID 为 \\u5730 的字符是 地, ID 为 \\u7403 的字符是 球, 后面的依次是: ,,  , 由, 我, 来, 守, 护, !.\n参考链接\n字符编码笔记: ASCII, Unicode 和 UTF-8\n\n网页编码就是那点事\n\nUnicode 和 UTF-8 有什么区别\n\n字符集和编码方式的区别\n\nASCII 码和 ANSI 码的区别\n\n从 ASCII 到 UTF-8 字符集到底是什么\n\nASCII 码  和 Unicode 码是什么关系\n\n\n","categories":["Computer"],"tags":["计算机基础"]},{"title":"这个文件既是 GIF 又是 ZIP ？！","url":"/computer/computer_polyglot.html","content":"\n\n🌴神奇的文件！首先看一下下面的这个文件\n\n看起来它就是一张动图对吧？\n\n现在你把它下载下来，然后将后缀重命名为 zip\n它是不是变成一个压缩包了？\n你可能觉得这并算不了什么，因为 Windows 系统就是会按照文件的后缀名来绑定打开方式，这很正常呀！\n是的，你想得完全正确，但是你尝试解压一下呢？\n是不是很神奇，它居然真的能够解压哦！甚至解压出来的文件还是全新的文件，两个 bat 文件！\n🍉它是什么？这种文件叫做 Polyglot 多语文件，是一种能够在多个不同的程序或环境中以不同格式解析的文件。\n🥝主要用途既然 Polyglot 文件可以在多个环境下运行不同的内容，那么 ... 嘿嘿嘿, 自然是深受广大黑客的喜爱啦, 所以它常被用于黑客攻击和恶意软件传播。\n钓鱼攻击比如给你发送一个同时是 PDF 和 EXE 的 Polyglot 文件，然后欺骗你打开这个 PDF，但实际上它也能作为可执行文件运行恶意代码哦！\n绕过杀毒软件将某些恶意代码隐藏在图片或音频文件中，就可以绕过安全检查啦！\n绕过上传限制有的网站只允许上传特定格式的文件，那么用 Polyglot 文件就可以将自己真正想上传的东西藏起来，并上传到服务器上。\n🍖如何制作制作非常简单, 首先准备好要合并的两个文件\n\n\n之后运行命令\ncopy /b kami.gif + bat.zip combined.gif\n然后就可以成功得到一个 Polyglot 文件啦！\n","categories":["Computer"],"tags":["计算机基础"]},{"title":"设置 Windows 访问不同 IP 时使用不同的网络","url":"/computer/computer_issues.html","content":"\n\n使用 oh-my-posh 美化终端第一步, Microsoft Store 中搜索 Windows Terminal Preview 并安装\n第二步, Microsoft Store 中搜索 oh-my-posh 并安装\n第三步, 在 文档 中新建 WindowsPowerShell 文件夹, 在 WindowsPowerShell 文件夹中新建 Microsoft.PowerShell_profile.ps1 文件, 右键菜单, 选择用 VSCode 打开 Microsoft.PowerShell_profile.ps1 文件, 并粘贴 oh-my-posh init pwsh --config ~/.leon.omp.theme.json | Invoke-Expression\n关于文档文件夹, 就是此电脑中的文档文件夹吗?没错, 就是你想的 此电脑 - 文档 文件夹\n为什么要在文档中新建上述文件夹, 必须在文档文件夹中吗? 比如叫那个名字吗?很遗憾, 是的, 必须! 这是固定死的!\n为什么我 Rider 中的终端没有被美化?请重启电脑!\n为什么我的终端显示乱码?请下载字体: https://www.nerdfonts.com/font-downloads\n推荐字体 : FiraCode Nerd Font\n下载安装字体后, 在终端内设置为对应的字体就不会乱码了\n\n&#39;打开方式&#39;中残留已卸载的应用程序注册表里面 HKEY_CLASSES_ROOT 目录中, 删除对应程序名称的文件夹即可.\n设置 Windows 访问不同 IP 时使用不同的网络这个效果是通过设置 Windows 路由表实现的.\n路由表查看方法在 Power Shell 中使用 route print 命令可以查看路由表信息.\nIPv4 路由表==========================================================================================活动路由:          网络目标                网络掩码               网关              接口       跃点数          0.0.0.0                0.0.0.0     192.168.42.129    192.168.42.220          25          0.0.0.0                0.0.0.0       10.30.20.254      10.30.20.143          25       10.30.20.0          255.255.255.0            在链路上      10.30.20.143         281     10.30.20.143        255.255.255.255            在链路上      10.30.20.143         281     10.30.20.255        255.255.255.255            在链路上      10.30.20.143         281        127.0.0.0              255.0.0.0            在链路上         127.0.0.1         331        127.0.0.1        255.255.255.255            在链路上         127.0.0.1         331  127.255.255.255        255.255.255.255            在链路上         127.0.0.1         331       172.16.0.0            255.255.0.0       10.30.20.254      10.30.20.143          26     192.168.42.0          255.255.255.0            在链路上    192.168.42.220         281   192.168.42.220        255.255.255.255            在链路上    192.168.42.220         281   192.168.42.255        255.255.255.255            在链路上    192.168.42.220         281        224.0.0.0              240.0.0.0            在链路上         127.0.0.1         331        224.0.0.0              240.0.0.0            在链路上    192.168.42.220         281        224.0.0.0              240.0.0.0            在链路上      10.30.20.143         281  255.255.255.255        255.255.255.255            在链路上         127.0.0.1         331  255.255.255.255        255.255.255.255            在链路上    192.168.42.220         281  255.255.255.255        255.255.255.255            在链路上      10.30.20.143         281==========================================================================================永久路由:          网络地址                网络掩码           网关地址                         跃点数       172.16.0.0            255.255.0.0       10.30.20.254                             1==========================================================================================\n\n路由表的预备知识\n什么是默认路由规则\n\n网络地址为 0.0.0.0 的路由规则就是默认路由规则, 默认路由规则是当其他全部的路由规则都没有匹配成功的时候生效\n\n什么是普通路由规则\n\n有且至少有一个具体数字不为 0 的路由规则就是普通路由规则\n\n如何算匹配成功\n\n实际网络地址 和 路由表网络掩码 进行与运算, 如果和 路由表网络地址 相等, 则视为匹配成功\n路由表的操作命令\nroute delete\n\n用于删除路由规则, 此命令无法使用通配符, 比如: route delete 0.0.0.0 或 route delete 192.168.0.0\n\nroute add\n\n添加路由规则, 以实现效果举例:\n\n\n想要默认用外网访问网络, 外网的网关是 192.168.42.129, 怎么设置呢?\nroute delete 0.0.0.0route add -p 0.0.0.0 mask 0.0.0.0 192.168.42.129\n\n想要实现类似 &quot;默认&quot; 这种效果, 先把所有的默认路由删除掉, 然后添加想要的默认路由规则即可\n\n\n\n\n有个网址必须使用内网才能访问, 内网网关是 10.30.20.254, 怎么配置呢?\n先得到网址的 IP 地址, 以 https://git.tube/dashboard/projects/starred 为例, 在 Power Shell 中直接 ping 域名即可\nping git.tube正在 Ping git.tube [172.16.11.23] 具有 32 字节的数据:来自 172.16.11.23 的回复: 字节=32 时间&lt;1ms TTL=63来自 172.16.11.23 的回复: 字节=32 时间&lt;1ms TTL=63来自 172.16.11.23 的回复: 字节=32 时间&lt;1ms TTL=63来自 172.16.11.23 的回复: 字节=32 时间&lt;1ms TTL=63172.16.11.23 的 Ping 统计信息:    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，往返行程的估计时间(以毫秒为单位):    最短 = 0ms，最长 = 0ms，平均 = 0ms\n\n得到目标网址: 172.16.11.23, 之后添加路由规则, 为了可以访问整个域名蔟, 只进行部分限定\nroute add -p 172.16.0.0 mask 255.255.0.0 10.30.20.254\n[注] mask 的要求是: mask 和想要访问的 IP 与运算后和网络地址必须一致\n[172.16.11.23] &amp; [255.255.0.0] = [172.16.0.0]\n\n\n\n\n常用 Win 组合快捷键Win 键可以说就是 Windows 的系统按键, 所以 Win 的组合快捷键都是和 Windows 操作相关的.\n\nWin Q : 打开 搜索.\nWin W : 打开 工作区.\nWin E : 打开 资源管理器. \nWin R : 打开 运行.\nWin T : 选中 任务栏上的图标, 可循环切换.\nWin U : 打开 设置中的轻松使用设置.\nWin I : 打开 设置.\nWin P : 更改 投影模式.\nWin A : 打开 桌面右下角的消息通知.\nWin S : 打开 搜索.\nWin D : 显示 Windows 桌面, 再次按下 Win D 返回之前的页面. \nWin F : 打开 反馈中心.\nWin H : 进行 Windows 语音听写, 前提是当前焦点在一个文本编辑器上, 如记事本.  ( 这个功能 &quot;超棒&quot;, 只是语音识别不准确而已, 只是支持的应用特别少而已, 只是使用语音输入后必须关闭文件重新打开之后才能正常使用键盘输入而已...嗯...就这样...)\nWin K : 打开 连接, 检测外部显示设备.\nWin L : 实现 快速锁屏.\nWin ; : 打开 Windows 表情输入.\nWin . : 打开 Windows 表情输入. \nWin X : 打开 开始菜单图标的右键菜单.\nWin C : 打开 小娜 Cortana.  ( 在设置中开启此快捷键)\nWin V :  打开 剪切板历史. 这个是真的好用. \nWin B : 选中 托盘栏中的第一个图标, 不能循环切换, 只能选择第一个.\nWin M : 最小化当前桌面中的所有窗口. 没有最小化功能的窗口无法最小化.\nWin Table : 打开 Windows 10 时间线. \n\n常用 Ctrl 组合快捷键Ctrl 可能是 Control 的简写吧, 所以 Ctrl 快捷键和命令相关.\n不同的应用程序会有不同的 Ctrl 组合快捷键, 而且大多数都可以进行自定义, 所以只列举常见的通用默认快捷键. 下面所有的快捷键在不同的程序中稍有区别.\n\nCtrl W :  关闭当前页面. \nCtrl A : 全选.\nCtrl B : 给字体加粗. Word 支持此快捷键.\nCtrl C : 复制.\nCtrl S : 保存.\nCtrl F : 查找.\nCtrl Z : 撤销一次操作.\nCtrl X : 剪切.\nCtrl V : 粘贴.\nCtrl Y : 恢复一次撤销. \nCtrl O : 程序内部的 &quot;打开&quot; 功能.\nCtrl N : 程序内部的 &quot;新建&quot; 功能.\nCtrl Enter : 通讯软件输入消息时换行, 不发送.\n\n常用 Alt 组合快捷键Alt 主要和软件的菜单相关.\n\nAlt 左键双击 : 快速查看文件, 文件夹的属性.\n\n提高效率的技巧\n按下 Win R, 输入 shell:sendto, 在之后的页面中可以修改右键菜单中的「发送到」子菜单.\n\nWindows 中, 在任务栏的图标上点击鼠标中键可以快速新建窗口, 在任务栏的缩略图中点击鼠标中键可以快速关闭窗口.\n\n\n","categories":["Computer"],"tags":["计算机基础"]},{"title":"自定义 Rider 的配置和缓存位置","url":"/computer/computer_ide.html","content":"\n\n🍖问题用过 Rider 的设置同步插件的应该都知道, 看似同步了很多设置, 而实际上呢, 虽然不能说是完全没用吧, 但也是屁用没有\n于是自己手动同步各项设置就成了重中之重\n\n🥝新建 Rider 的配置和缓存目录推荐在 JetBrains 目录中新建 rider , config , system 三个目录\n\nrider 为存放主程序的位置\nconfig 为存放配置文件和插件的位置\nsystem 为存放缓存和日志的位置\n\n🍹Rider 用户配置文件Rider 自定义配置文件在这个位置\n&#123;Rider&#125;/bin/idea.properties\n\n🍙自定义 Rider 配置打开 idea.properties 文件, 需要修改的位置有 4 个: 配置存放目录, 缓存存放目录, 插件存放目录, 日志存放目录, 可以参照以下配置\n#---------------------------------------------------------------------# Uncomment this option if you want to customize a path to the settings directory.#---------------------------------------------------------------------idea.config.path=E:/Program/JetBrains/config#---------------------------------------------------------------------# Uncomment this option if you want to customize a path to the caches directory.#---------------------------------------------------------------------idea.system.path=E:/Program/JetBrains/system#---------------------------------------------------------------------# Uncomment this option if you want to customize a path to the user-installed ugins directory.#---------------------------------------------------------------------idea.plugins.path=$&#123;idea.config.path&#125;/plugins#---------------------------------------------------------------------# Uncomment this option if you want to customize a path to the logs directory.#---------------------------------------------------------------------idea.log.path=$&#123;idea.system.path&#125;/log\n\n🌴迁移默认设置到新目录配置文件的迁移\n默认位置 C:\\Users\\Administrator\\AppData\\Roaming\\JetBrains\\&#123;rider_version&#125;\\\n\n将上述文件夹中的文件全部移动到新的 config 文件夹中\n缓存文件的迁移\n默认位置 C:\\Users\\Administrator\\AppData\\Local\\JetBrains\\&#123;rider_version&#125;\\\n\n将上述文件夹中的文件全部移动到新的 system 文件夹中\n最后重启 Rider 即可\n","categories":["Computer"],"tags":["IDE"]},{"title":"Git Clone 慢速 20KB 的终极解决方案","url":"/git/git_clone_slow.html","content":"\n\n省流版\n设置 remote 必须使用 https 链接\n使用命令指定 git 代理的 IP 和 端口\n\n前言此方案需要代理, 不会有人还没有代理吧? 不会吧不会吧? [赶紧溜....]\n查看代理端口查看自己的 SS, SSR, Clash 等代理软件的端口, 我这里的是 1080\n设置 git 代理git config --global http.proxy http://127.0.0.1:1080\n\ngit config --global https.proxy https://127.0.0.1:1080\n\n检查代理是否设置正确git config --global -l\n\n通过 https 链接克隆项目git clone [url]\n\n实验结果最终克隆速度直接跑满带宽, 终于... 可以开始敲代码了, 哈哈哈\n最后如果不放心可以把代理关掉git config --global --unset http.proxy\n\ngit config --global --unset https.proxy\n","categories":["Git"],"tags":["Git"]},{"title":"Git 中使用 Revert 导致的合线问题","url":"/git/git_revert_error.html","content":"\n\n问题复现首先模拟一下, 当前有一条功能主分支, 叫做 A, 目前 A 的开发进度为 A, A1\n现在需要在 A 分支上开发一个次要功能, 于是新建了分支 B, B 开发了一段时间之后, 开发进度为 B, B1, 此时 B 功能开发完成了, 但是出了一个 Bug\n之后需要修复 B 分支上的这个 Bug, 于是新建了分支 C, 问题修改进度为: C, C1, C2, Bug 修复完毕\n下面是 Git 记录:\n\n或许这样会看得更清晰一些:\n\n此时问题已经修复完毕, 分支 C 需要合并到分支 B 中, 但是由于操作失误, 分支 C 直接合并到了分支 A, 并且合线人员看到合错线了, 使用了 Revert 进行了反合线, 如图:\n\n\n之后 C 分支正常往 B 分支合线\n\nB 分支向 A 分支合线\n\n至此功能 B 合线完成.\n上面这个情景合线后的 A 分支会有问题吗?\n答案是会有问题. 分支 A 上面压根就没有任何分支 B 和分支 C 上的内容. 因为之前的 Revert 操作的内容是删除分支 B 和分支 C 的内容, 所以导致 B C 在合线进来之后就又被删除掉了, 导致 A 分支上什么都没有.\n\n解决方案\n方案 1: 直接禁止使用 Revert, 一了百了 ~ 哈哈\n\n方案 2: 执行了 Revert 命令之后再次执行一次 Revert 命令  \n\n方案 3: 回退到 Revert 之前的结点, 之后强制推送, 就可以恢复到没有执行 Revert 之前的状态  \n\n方案 4: 回退到 Revert 之前的结点, 新建分支, 之后删除旧的错误分支,也达到了恢复到没有执行 Revert 之前状态的目的\n\n\n","categories":["Git"],"tags":["Git"]},{"title":"不同文件间冲突 ? 远端文件冲突描述信息残留 ?","url":"/git/git_conflict_different_file.html","content":"合并操作时, 居然不同的文件之间存在冲突 ? ! 不同的文件之间呀 ? 这到底是咋回事 ? ? 到底是道德的沦丧 ? 还是人性的... (啪! 😡 废话真多! 赶紧的!)\n\n\n😱问题描述先看一下问题的截图, 下面是一次 merge 操作后的结果\n\n远程仓库中的资源残留了冲突描述文本\n\n\n是的, 你没有看错, 我也没有撒谎, 这确实是远端仓库中资源的样子, 可以看到, 里面还是残留着冲突描述信息, 但是... 这可能吗 ? ? 😣 难道是负责合并的人整了什么活 ? 😒, 遗憾的是经过询问, 人家并没有进行什么特殊的操作, 就是正常 Merge, 正常 resolve conflict, 正常 commit ... 啊这 ... 我不信啊 ! ! !🙄\n😟尝试复现问题既然要解决问题, 首先自然是尝试复现问题, 但是自己新建一个 Git 仓库无论如何也复现不出问题 😫\n可以看下面的截图, 只要存在冲突, 无论使用图形化软件的 fork 还是直接使用 Git 命令都必须先解决冲突才能 commit, 所以究竟怎么做才能将这种带有冲突描述信息的资源提交呢 ?\n\n新建项目尝试复现问题, 建立 2 条存在冲突的分支\n\n\n\n进行合并, 并尝试不解决冲突直接提交, 但是图形化软件 Fork 无法提交\n\n\n\n进行合并, 并尝试不解决冲突直接提交, 但是即使直接使用命令同样无法提交\n\n\n唉... 做不到不解决冲突直接提交, 无论使用什么软件还是直接使用命令, 都不行 😥 暂且记录下这个问题\n\n疑惑 1 : 为什么自己新建仓库无法复现问题 ?\n\n🧐查找导致问题的提交既然自己新建仓库无法复现问题, 那就只能去一步步查找出导致问题的操作\n既然是查找提交, 最快的方法自然是针对某一个有问题的文件找出所有的提交历史啦, 以 Coat_159.FBX.meta 为例 😈\n\nFork 软件显示的历史\n\n\n\nGitKraken 软件显示的历史\n\n\n\nGit log 命令显示的历史\n\n\n从三张截图中可以得出 2 个结论:\n\n结论 1 : 文件只有 2 次提交, 分别是 新增文件 和 关闭读写设置, 并没有冲突描述信息的提交, 考虑到 rebase 操作不会生成新的提交, 所以不会导致此问题, 因此可以断定只有 merge 操作会导致此次问题, 这样后面只要排查合并操作即可\n结论 2 : Fork 软件的历史查询真的有问题! 哈哈! GitKraken 显示的历史便没有后面那些乱七八糟的提交, 直接使用 Log 命令显示的历史中也没有后面的提交! (当然这个结论在文章最后会被推翻, 此时先按下不表 😋)\n\n🧐查找导致问题的 Merge 操作通过 Fork 的 Collapse All Merges (Show First Parent) 功能, 快速对 Merge 进行排查, 最终定位到了导致问题的 Merge 操作\n\n导致问题的 Merge 操作\n\n\n可以看到 origin/develop 合并到 hotfix/release/v51/1716/1726-merge-dev 时出现了冲突描述文本, 至此终于定位到了有问题的操作, 但是还是没有搞清楚这些冲突描述信息为何会残留 ? 又为何在残留的状态下进行了提交 ? 😭\n🤓尝试复现问题继续之前的思路, 在此次合并的两条分支处新建新的分支\n\n在合并前的提交处新建分支\n\n\n\n直接再次发起 Merge\n\n\n惊喜 ╰(*°▽°*)╯ ! 提示可以直接合并, 没有任何冲突 💥 那这岂不是说明了就是负责合并的人整活嘛 ! 赶紧合并完, 去找负责人 battle !\n\n寄\n\n\n啥情况 ? ! 不是说没有冲突吗 ? 怎么又出来冲突了 ? 唉, 没办法, 直接进行一个 查看冲突内容\n\n查看冲突内容\n\n\n果然 ! 就是此次问题中的文件, 使用的例子 Coat_159.FBX.meta 文件还首当其冲, 第一个就是它\n那没办法咯, 解决冲突呗, 直接选择 Merge\n\n抱歉, 无法 Merge\n\n\n啊 ? ? ? 啥情况, 没法 Merge ? ? ? 那返回选择 modified\n\n抱歉, 无法 modified\n\n\n啊 ? ? ? 啥情况, 无法选择 modified ? ? ? 原来其中一个分支压根没有这个文件啊, 怪不得无法 Merge, 也无法选择 modified, 那只好返回选择 added 咯\n好家伙! 明明给我 3 个选项, 我却木的选择, 简直了😒 可以选, 但是没得选\n\n选择 added 后问题复现\n\n\n啊 ? ? ? 为啥选择 added 后变成这样了 ? ? ? 虽然说问题是复现出来了, 但是不懂的地方更多了 ...\n🤔总结问题的复现至此已经将整个问题复现了, 但是头脑中产生了更多的问号🤔\n\n疑惑 2 : 为啥合并前提示没有冲突, 随着合并的进行, 却出现了冲突 ?\n\n疑惑 3 : 为啥 added 的解决方式会错误地解决冲突 ?\n\n疑惑 4 : 为啥文本中明明还存在冲突描述却被 Git 认为冲突解决了 ? 难道冲突的标记不是描述文本吗 ?\n\n\n🧐思路 1 : 怀疑图形化软件的问题因为之前的复现使用的是 Fork 软件, 一款 Git 的图形化软件, 方便 Git 的使用, 所以怀疑是软件的问题\n\n怀疑 1 : 图形化软件无法正确执行 Merge 操作\n怀疑 2 : 图形化软件可以正确执行 Merge 操作, 但是无法正确解决冲突\n\n验证怀疑 1 : 是否正确执行 Merge直接使用命令进行 Merge 操作, 看看结果是否一样\n\n即使直接使用命令也一样\n\n\n直接使用 Merge 命令, 一样出现了冲突, 输入 git status 查看冲突的文件\n\n冲突的文件也一样\n\n\n查看冲突的文件, 发现也是一样的, 这就推翻了第一个怀疑, 后来想想也是, 图形化软件的本质也是执行命令, 怎么会不一致呢 ?\n验证怀疑 2 : 是否能够正确解决冲突既然 Fork 不行, 那就使用另一款软件 GitKraken 进行合并, 尝试解决冲突\n\n同样的问题, 同样的冲突\n\n\n和想的完全一致, 出现了同样的冲突, 但是 GitKraken 中有一个新的选项 : Mark resolved 引起了我的注意, 这不正好就是前面记录下的第 4 点嘛, 难道 冲突是否解决 这点真的有标记位 ? 也就是说可以直接在不更改文件的前提下, 直接将文件标记为 resolved, 从而提交上去 ! 直接来尝试一下\n尝试前先来看一下此时 (冲突未解决的时刻) 文件的样子\n\n标记前的文件内容\n\n\n可以看到冲突描述信息都是在的, 没有任何问题!\n同时可以看到截图的右下角有一个 &#39;在合并编辑器中解析&#39; 的按钮, 这个后面会说, 现在先按下不表 (都 2 个没表的啦 ! 😡)\n\n真的直接标记为解决了\n\n\n从图中可以看出, 和设想的完全一样, 文件直接被标记成 resolved\n而且经过对文件前后的比对, 文件并没有变化, 最终得出结论 : 冲突确实被直接标记成了 resolved, 并没有对文件进行任何修改, 甚至文件时间戳都没变, 至此 为啥 &#39;added&#39; 的解决方式会错误的解决冲突 ? 解决, 不是错误的解决了冲突, 而是直接将文件标记为解决, 文件压根没动, 因此冲突描述信息被保留了下来\n同时 为啥文本中明明还存在冲突描述却被 Git 认为冲突解决了 ? 难道冲突的标记不是描述文本吗 ? 也得到了验证, 文本描述信息确实不是用来标记冲突是否解决的, 但也带来了新的问题\n\n疑惑 5 : 是什么标记了冲突是否解决呢 ?\n\n这个问题先不说明, 这里继续之前的思路\n看来 GitKraken 也不行, 这里突然想到了刚刚用 VSCode 查看文件的时候, 右下角不是有一个 在合并编辑器中解析 嘛! 对呀, VSCode 也可以解决冲突呀, 直接上 VSCode\n\n完美 ! VSCode 永远滴神 !\n\n\nVSCode 完美解决了冲突, 直接点击右下方 完成合并, 提交, 事情解决, 交差 !\n后来才知道原来这种冲突叫做 &#39;树冲突&#39;, 是不同于 &#39;逻辑冲突&#39; 的, 树冲突目前确实不能通过图形化界面解决, 需要手动解决, 希望后面图形化软件的作者们能解决这个问题\n😴革命尚未成功, 同志仍需努力 !问题虽然解决了, 但是心头还是有很多不明白的关键点, 而且使用 Fork + VSCode 的工作流也跟难让人接受, 总不能合并一次还得用两个软件吧, 而且更多的是使用 Fork 而不是 VSCode, 所以看来还是得找到本质原因啊, 治标不治本是不行滴!\n🧐思路 2 : 用 Rebase 代替 Merge 可行不 ?直接进行试验, 在 Fork 中对分支进行变基\n\n成了 !\n\n\n从截图中可以看到, 使用 rebase 操作可以正确得到合并结果, 虽然有冲突, 但是也仅仅只有 1 个, 而且属于 逻辑冲突, 直接解决掉就行了\n\nGitKraken 也一样\n\n\nreset 回之前的提交, 使用 GitKraken 来一次 rebase 也是同样的结果, 只有一个冲突, 解决后效果也是对的\n不使用 rebase 的原因但是在大型项目中, 还是使用 merge 更好, 尤其是在有大量开发分支的项目中, 为了记录下每一次的合并的具体信息, 包括: 合并的分支, 合并的时间, 冲突的文件等等, 必须使用 merge, 同时 merge 也不会导致时空错乱的问题, merge 本质上是将提交直接合并, 而 rebase 本质是合并了提交的副本, 导致可能几个月前, 甚至几年前的提交变成了最近的提交... 而 rebase 所带来的 提交树简洁, 带来的 提交树易懂 的好处实在是微乎其微, 读不懂恰好说明图形化软件做的不好啊, 或者就是你能力不行啊! (开个玩笑, 别打我 😰)\n至此, rebase 方案也被否决, 只能再次寻找其他的突破口, 此时我想到了 是什么标记了冲突是否解决呢 ?, 稍微搜索了一番就找到了答案.\n😥是什么标记了冲突是否解决呢 ?经过 Google 的搜索, 最终定位到了关键字 : 索引, 不过还是先说明一下冲突描述文本吧\n冲突描述文本首先 &lt;&lt;&lt;&lt;&lt;&lt;&lt; ======= &gt;&gt;&gt;&gt;&gt;&gt;&gt; 确实是用来描述冲突信息的, 但是并不是标记冲突是否解决, 而且这里的冲突描述信息还有好几种, 可以通过设置 merge.conflictStyle 来改变冲突描述文本的样式\n这个是默认的样式, 名字就叫做 merge\nHere are lines that are either unchanged from the commonancestor, or cleanly resolved because only one side changed,or cleanly resolved because both sides changed the same way.&lt;&lt;&lt;&lt;&lt;&lt;&lt; yours:sample.txtConflict resolution is hard;let&#x27;s go shopping.=======Git makes conflict resolution easy.&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs:sample.txtAnd here is another line that is cleanly resolved or unmodified.\n\n下面的是 diff3 样式\nHere are lines that are either unchanged from the commonancestor, or cleanly resolved because only one side changed,&lt;&lt;&lt;&lt;&lt;&lt;&lt; yours:sample.txtor cleanly resolved because both sides changed the same way.Conflict resolution is hard;let&#x27;s go shopping.||||||| base:sample.txtor cleanly resolved because both sides changed identically.Conflict resolution is hard.=======or cleanly resolved because both sides changed the same way.Git makes conflict resolution easy.&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs:sample.txtAnd here is another line that is cleanly resolved or unmodified.\n\n最后的是 zdiff3 样式\nHere are lines that are either unchanged from the commonancestor, or cleanly resolved because only one side changed,or cleanly resolved because both sides changed the same way.&lt;&lt;&lt;&lt;&lt;&lt;&lt; yours:sample.txtConflict resolution is hard;let&#x27;s go shopping.||||||| base:sample.txtor cleanly resolved because both sides changed identically.Conflict resolution is hard.=======Git makes conflict resolution easy.&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs:sample.txtAnd here is another line that is cleanly resolved or unmodified.\n\n我查看官方手册中就只有上面 3 种样式, 感兴趣的可以自行查阅, 这是官方手册\n以 diff3 为例, 可以通过 git config --global merge.conflictstyle diff3 进行设置\nhttps://git-scm.com/docs/git-merge/en\n 啊啊啊啊 ! 😦 我怎么没早点想到啊! 如果真的使用上述的这种特殊文本来标记冲突是否解决, 那岂不是我这篇博客就提交不上去了, 毕竟博客中有这种文本 ... 😅 啊这... 无语了 ... 😑\n文件状态的存储库 : 索引 (Index)经过大量搜索后, 我了解到了一件大事, 那就是原来 index 就是 stage area, 也就是 暂存区! ! (早说嘛, 早说暂存区不早就明白了 ? ! 哭了 ...) 暂存区的内容就是存储在 .git/index 文件中的\n直接对冲突标记前后的 index 文件进行比较, 左侧是标记解决前的, 右侧是标记解决后的\n\n变更1\n\n\n变更 1 并没有看到有明显含义的变更, 需要更深一步按照十六进制解读才行\n\n变更2\n\n\n变更 2 种可以看到标记解读后, 多了一个 REUC 的字符串\n\nREUC 释义\n\n\n经查阅官方手册, REUC 是用来解决冲突后复原冲突的\n由此也可以证明文件的各种状态都是在暂存区, 也就是索引库 .git/index 文件中保存的, 使用 git status 命令也可以看到各个文件的状态, 更详细的可以直接查阅手册\nhttps://git-scm.com/docs/git-status/en\n\n&#39; &#39; &#x3D; unmodified\nM &#x3D; modified\nT &#x3D; file type changed (regular file, symbolic link or submodule)\nA &#x3D; added\nD &#x3D; deleted\nR &#x3D; renamed\nC &#x3D; copied (if config option status. renames is set to &quot;copies&quot;)\nU &#x3D; updated but unmerged\n\n其中 U 就是代表 未合并 状态的,  到这里小总结一下\n\n\n\n问题\n状态\n解释\n\n\n\n1 为什么自己新建仓库无法复现问题 ?\n未解决\n\n\n\n2 为啥合并前提示没有冲突, 随着合并的进行, 却出现了冲突 ?\n未解决\n\n\n\n3 为啥 added 的解决方式会错误的解决冲突 ?\n已解决\n因为并没有修改文件, 而是直接修改了标记\n\n\n4 为啥文本中明明还存在冲突描述却被 Git 认为冲突解决了 ? 难道冲突的标记不是描述文本吗 ?\n已解决\n冲突描述文本并不是用来标记冲突的\n\n\n5 是什么标记了冲突是否解决呢 ?\n已解决\n在 &quot;.git&#x2F;index&quot; 文件中存储着冲突标记\n\n\n6 图形化软件无法正确执行 Merge 操作\n已解决\n可以正确执行 Merge\n\n\n7 图形化软件可以正确执行 Merge 操作, 但是无法正确解决冲突\n已解决\n对于 &quot;树冲突&quot; 图形化软件确实无法解决需要使用文本工具手动解决\n\n\n🧐思路 3 : 重命名操作上面表格中第 2 个点让我注意到了另一件事, 一件非常非常重要的事, 之前的注意力一直在 冲突描述文本残留 上, 却没有注意到 发生冲突的文件压根不是一个文件呀 !!!\n先回到最初的起点\n\n最初的起点\n\n\n回到最初的起点后可以看到发生冲突的文件居然是 Coat_159.FBX.meta 和 HolySword_7_Lobby.fbx.meta 文件, 这压根不是同一个文件啊, 也就是说想要这两个文件冲突, 必然要发生 重命名操作, 难道是重命名导致的 ?\n再次回到 Coat_159.FBX.meta 的历史记录, 并没有发现重命名的提交\n\n切到另一条合并分支, 查看 HolySword_7_Lobby.fbx.meta 的历史记录, 这个记录更少, 只有一次新增\n\n这也太难受了 ... 这个思路也行不通吗 ...\n🧐思路 4 : 冲突的识别 &#x2F; 重命名的识别 &#x2F; 同文件的识别在检查历史记录并发现并没有重命名的操作之后, 我突然意识到会不会是 Git 主动把这两个文件当成同一个文件了 ? ? ? 这也就引出了关于重命名检测的思考\n\n疑惑 6 : Git 是如果识别重命名操作的 ? 对于常见的重命名操作, Git 是如何知道改名后的文件和改名前的文件是同一个文件并将变更类型标记为 &quot;重命名&quot; 的呢 ? 对于两条存在重命名提交的分支, 它们的合并操作中 Git 是如何识别冲突的呢 ?\n\n又是一番搜索查阅, 最终在官方手册中找到了答案, Git 冲突的检测确实存在多种情况, 具体取决于使用的合并策略\n合并策略Git 中的 Merge 还可以设置多种合并策略: ort, recursive, resolve, octopus, ours, subtree, 不同的策略对待文件变更的态度完全不同, 也就导致冲突的不同, 感兴趣的可以直接查阅手册\nhttps://git-scm.com/docs/git-merge/en\n重命名检测机制Git 中有一个 重命名检测机制, 这个机制就是用来检测变更前后名称不一致的文件是否是同一个文件的, 可以使用 --find-renames[=&lt;n&gt;] 开启检测, 也可以使用 --no-renames 关闭检测\n\n继续翻阅后发现, Git 中的默认设置为开启重命名检测, 并且检测的阈值为 50% : find-renames=50%\n\n30% 的含义就是一对 delete &#x2F; add 操作的两个文件之间的有 30% 是一模一样的, 就认为是同一个文件, 90% 也就是需要 90% 是一模一样的才会被认为是同一个文件, 那么设置为 100% 就意味着两个文件必须完全一致才会被认为是同一个文件\nUnity meta 文件有了重命名检测机制的理论基础, 再联想到 Unity 的 meta 文件的特点 ... 嗯 ... 🤔 ... 啊 ! 😮 啊 ! ! 😮 啊 ! ! ! 😮 对的对的, 就是这样 !\nUnity 的 meta 机制决定了存在大量相似的 meta 文件, 像 目录, 配置文本 等无特殊处理类资源, 以及 预制体, 材质球, 场景 等复合类资源所序列化的 meta 文件极其相似, 更何况它们同种类资源之间的 meta 文件了, 那更是除了 guid 其他的完全一致 ! 因此非常容易被 Git 识别为相同的文件, 也就是误识别为 重命名 操作\n目录序列化出的 meta 文件// 目录 序列化出的 meta 文件fileFormatVersion: 2guid: f41c5b2d49a72dc47a07d681a9ba2bf0folderAsset: yesDefaultImporter:  externalObjects: &#123;&#125;  userData:   assetBundleName:   assetBundleVariant: \n\n文本文件序列化出的 meta 文件// 文本文件序列化出的 meta 文件fileFormatVersion: 2guid: 368f799b221cab84782a3f0ec5d8459cTextScriptImporter:  externalObjects: &#123;&#125;  userData:   assetBundleName:   assetBundleVariant: \n\n场景资源序列化出的 meta 文件// 场景资源序列化出的 meta 文件fileFormatVersion: 2guid: 62c4bca74e32619458a3997c632ed9e7DefaultImporter:  externalObjects: &#123;&#125;  userData:   assetBundleName:   assetBundleVariant: \n\n预制体资源序列化出的 meta 文件// 预制体资源序列化出的 meta 文件fileFormatVersion: 2guid: c838f6f228af3d44bb70ab0d05c54fa4PrefabImporter:  externalObjects: &#123;&#125;  userData:   assetBundleName:   assetBundleVariant: \n\n材质球资源序列化出的 meta 文件// 材质球资源序列化出的 meta 文件fileFormatVersion: 2guid: 6493dc037fa3ed14f83f9cbd0228376cNativeFormatImporter:  externalObjects: &#123;&#125;  mainObjectFileID: 0  userData:   assetBundleName:   assetBundleVariant: \n\n上面几种的 meta 文件是不是几乎一致 ?\n同样, 对于具有复杂导入设置的图片资源, 即使所序列化得到的 meta 文件很复杂, 但是大量的图片的导入设置都是一模一样的, 是的, 一模一样的导入设置, 这也就导致了序列化出来的 meta 相似度更高 !\n随便从项目中找了两张, 就发现仅仅只有 guid 不同, 在如此大量的文本总量下, 这至少得是 90% 的相似度了吧 😨\n\n同样的模型也是一样, 在一致的导入设置下, 如果都是使用了同一套骨骼, 也不导入内嵌材质球, 那不同的地方少之又少, 基本就只剩下 guid 了 !\n比较两个简单模型之间的不同, 发现仅仅只有 guid 和内嵌材质球的名字不同而已, 这也应该达到  90% 的相似度了吧 😨 \n\n对于更复杂的模型, 也只是增加了内嵌材质球的名字 (前提是开启了内嵌材质球导入) 以及骨骼的名字 等几处不同而已, 相似度还是很高 !\n\n😀问题解决直接设置重命名检测的阈值为 100%, 这样就必须完全一致才会认为是同文件\n直接使用命令进行合并 git merge -s ort -X find-renames=100%\nPS E:\\Sausage_Release\\Assets\\Art&gt; git merge -s ort -X find-renames=100% MergeTest/Old_Develop\n\n\n完美合并 !\n\n\n完美的合并, 没有发生任何冲突 ! ! ! 完美 ! 收工 ! 🤔 啊来 ? 我是不是漏了什么 ? 突然有点感觉不对劲 ...\n啊 ! Σ(っ °Д °;)っ 想起来了, 是最开始遇到的问题, 没想到最后的时候解决的是最开始的问题😂, 这里总结一下\n\n\n\n问题\n状态\n解释\n\n\n\n1 为什么自己新建仓库无法复现问题 ?\n已解决\n因为不是 Unity 项目, 且变更简单, 没有复杂的 delete&#x2F;add 操作, 无法触发重命名检测机制\n\n\n2 为啥合并前提示没有冲突, 随着合并的进行, 却出现了冲突 ?\n已解决\nUnity 的 meta 文件机制和 Git 重命名检查机制共同作用导致\n\n\n3 为啥 added 的解决方式会错误的解决冲突 ?\n已解决\n因为并没有修改文件, 而是直接修改了标记\n\n\n4 为啥文本中明明还存在冲突描述却被 Git 认为冲突解决了 ?难道冲突的标记不是描述文本吗 ?\n已解决\n冲突描述文本确实不是用来标记冲突的\n\n\n5 是什么标记了冲突是否解决呢 ?\n已解决\n在 &quot;.git&#x2F;index&quot; 文件中存储着冲突标记\n\n\n6 图形化软件无法正确执行 Merge 操作\n已解决\n可以正确执行 Merge\n\n\n7 图形化软件可以正确执行 Merge 操作, 但是无法正确解决冲突\n已解决\n对于 &quot;树冲突&quot; 图形化软件确实无法解决需要使用文本工具手动解决\n\n\n8 Git 是如果识别重命名操作的 ?对于重命名操作, Git 是如何知道改名后的文件和改名前的文件是同一个文件呢 ?对于两条存在重命名提交的分支, 它们的合并操作中 Git 是如何识别冲突的呢 ?\n已解决\n多种合并策略以及重命名检测机制\n\n\n至此全部的疑问都得到了解答, 舒服 ~\n🤡关于 Fork 历史记录显示错误的解释经过此次问题的处理, 我查阅了大量 Git 官方的手册, 于是也试着从手册中寻找答案, 果然, Git log 命令中同样存在参数控制, --follow 参数便可以得到和 Fork 软件中一样的结果\n--follow    Continue listing the history of a file beyond renames (works only for a single file).\n\n\n看, 是不是和 Fork 中显示的历史记录一致了 !\n[注意] 了解 Git 设计思想的应该都知道, Git 是不会保存任何文件名称变更的, tree 只会保存名称, blob 只会保存内容, 因此 Git 中甚至没有 diff 的概念, 所以强烈建议禁止使用 --follow, 在没有 diff 概念的 Git 中重命名的检测完全没有意义! 即使是两个内容完全一致的文件, 背后的操作也不一定是重命名! 想要了解更多的内容就得去了解 Git 设计之初的思想了, 这里就不展开了, 感兴趣的话可以直接找后面的参考链接阅读.\n🦄总结此次问题本质上来说就是由于 Unity 的 meta 文件机制 和 Git 重命名检查机制 共同作用所导致的 树冲突 无法自动合并, 想要解决此问题, 由于 meta 文件无法改变, 那么只能改变重命名检测机制了\n使用设置 diff.renameLimitgit config diff.renameLimit 1\n限制 diff 时重命名检测的文件数量为 1, 不建议使用, 可能会导致签出, 提交等操作时无法识别任何重命名操作\nThe number of files to consider in the exhaustive portion of copy/rename detection;equivalent to the git diff option -l.If not set, the default value is currently 1000.This setting has no effect if rename detection is turned off.\n\n使用设置 merge.renameLimitgit config merge.renameLimit 1\n限制 merge 时重命名检测的文件数量为 1, 不建议使用, 真正的重命名操作也不会被识别到\nThe number of files to consider in the exhaustive portion of rename detection during a merge.If not specified, defaults to the value of diff.renameLimit.If neither merge.renameLimit nor diff.renameLimit are specified, currently defaults to 7000.This setting has no effect if rename detection is turned off.\n\n使用参数 find-renames[&#x3D;&lt;n&gt;] (建议使用)git merge -s ort -X find-renames=100% &lt;branch&gt;\n设置只有文件完全一致时才会识别为重命名操作\nTurn on rename detection, optionally setting the similarity threshold.This is the default.This overrides the merge.renames configuration variable.\n\n👀问题原理解析想要解析问题背后的原理, 就必须先解释什么是 树冲突, 树冲突是 SVN 类版本控制系统的一种冲突类型, SVN 冲突包括 内容冲突 和 树冲突, 虽然树冲突是 SVN 中的概念, 但是 Git 中同样存在树冲突\n这次问题的冲突类型就是树冲突, 最常见的树冲突就是同一个文件, 在 A 分支删除或者新增, 在 B 分支修改, 此时将 A 和 B 合并, 这就产生了树冲突 ... 甚至 B 分支不做任何变更, 也会导致树冲突, 回顾一下此次合并时的冲突\n\n可以看到恰好就是一条分支新增文件, 另一条分支修改文件, 导致了典型的树冲突, 那么为什么会导致树冲突呢?\n很好理解, 通过分别切换到两条分支上发现, 这两个文件 Coat_159.FBX.meta 和 HolySword_7_Lobby.fbx.meta 分别在两条分支上, 这里简称为 C 和 H, 一条分支是对 C 的新增和修改, 另一条是对 H 的新增, 汇总到最终的合并上, 只看最后的提交就是一条分支是对 C 的修改, 另一条是对 H 的新增, 但是由于 Git 将这两个文件识别为了同一个文件, 于是就变成了两条分支, 一条是对文件的修改, 一条是对文件的新增, 于是出现了树冲突!\n📕参考链接\n官方手册\nhttps://git-scm.com/docs/git-merge/en\nhttps://git-scm.com/docs/git-diff/en\nhttps://git-scm.com/docs/index-format\nhttps://git-scm.com/docs/git-status/en\nhttps://git-scm.com/docs/git-update-index/en\nhttps://git-scm.com/docs/git-log/en\nhttps://git-scm.com/docs/git-config/en\n\n\nGit 社区手册\nhttps://gitbook.liuhui998.com/\n\n\n深入 Git 索引\nhttps://untitled.pw/software/1176.html\n\n\nGit 权威指南\nhttps://www.worldhello.net/gotgit/03-git-harmony/020-conflict.html\n\n\n深入理解 Git\nhttps://taoshu.in/git/git-internal.html\n\n\n\n","categories":["Git"],"tags":["Git"]},{"title":"Git 和 Fork","url":"/git/git_learn.html","content":"\n\n推荐一个 Git 的学习网站, 以游戏的方式来学习 Git. 点我\n用户信息 (Windows)Windows 系统的用户文件夹下有一个 .gitconfig 文件, 这个文件中存储了 git 的全局设置, 包括提交时的用户名以及邮件地址, 还可以设置一些 git 长命令的别名, 用于简化操作.\nGit 版本库中每一个 commit 节点都有一个提交者, 这个提交者默认就是用户文件夹下 .gitconfig 文件中配置的用户名和邮件地址. 但是如果不同的仓库需要不同的提交者怎么办呢?\nGit 版本库在所使用的提交者信息有 3 个层级, 分别是: 仓库级 local, 全局级 global, 系统级 system.\n系统级用户信息系统级的配置文件是 Git安装目录&#x2F;etc&#x2F;gitconfig 文件, 这个文件中的配置优先级最低, 会被另外两个配置文件中的配置所覆盖.\n全局级用户信息全局级的配置文件是 用户文件夹&#x2F;.gitconfig 文件, 这是一个隐藏文件, 其中最重要的设置就是保存了默认的用户信息. 由于这里保存的是默认信息, 因此除非配置错误, 否则不要修改 .gitconfig 中的配置.\n仓库级用户信息仓库级的配置文件是 仓库文件夹&#x2F;.get&#x2F;config 文件. 只要在这个文件中给你再次配置一个 [user] 信息便可以实现不同的仓库使用不同的提交者信息.\nGit 版本控制结构Git 在实现版本控制时的结构如下图:\n\n其中的 Repository, Index, Workspace 为本地文件, Remote 是远程文件.\n在克隆远程仓库之后的整个文件夹就是我们的仓库目录, 其中除了 .git 文件夹以外的文件及文件夹称为工作区, 默认情况下, 同目录下的 .git 文件夹保存了这个仓库的版本提交信息.\n图中各个图标的解释:\n\nworkspace: 工作区, 我们实质的项目文件.\nRepository: 本地的版本控制信息. 位于 .git 文件夹中, 其中保存了从开始进行版本控制以来所有的提交记录, 后面的暂存区也在这个文件夹中.\nIndex: 暂存区, 我们所有改动在提交之前都必须先放到暂存区中. 也在 .git 文件夹中. Fork 软件中的 Stage 命令就是将改动保存到暂存区.\nRemote: 远程服务器上的文件.\n\nbranch-name 和 HEADbranch-name 和 HEAD 都不是提交信息, 这两个都只是一个游标, 它们指向特定的节点.\nHEAD 也称作 current branch, 是一个指向当前工作区所处位置的游标, 主要由 checkout 命令控制, HEAD 不仅可以指向分支名, 也可以直接指向某个提交节点.\n在签出本地仓库中的一个分支时, HEAD 便会指向这个分支名, 比如签出了 bugFix 分支, 则: HEAD-&gt;bugFix-&gt;bugFix-commit.\n在签出远程仓库中的一个分支时, HEAD 会变成分离状态, 比如签出了 bugFix 分支, 则: HEAD-&gt;bugFix-commit. 这样是为了保证用户必须在自己新建的本地分支上工作, 不能直接在远程分支上进行修改和提交, 生成 commit 节点.\nGit, GitHub 和 GitLabGit 是一个分布式版本控制工具, 一个仓库所有的提交记录全部保存在 .git 文件夹中. 随着项目的开发, .git 文件夹的体积会越来越大.\nGitHub 是一个注重点为 开源 的代码托管网站, 他的特点就是仅支持 Git 作为版本控制工具, 并且提供了很多 Git 相关的便利操作, GitHub 和 Git 是完全不同的两个事物. 由于 GitHub 的注重点为开源, 因为对于开发闭源软件的团队而言, GitHub 就不适用了.\nGitLab 是一个面向企业团队的代码托管网站, 和 GitHub 非常相似, 最大的不同就是 GitLab 上的仓库是隐私的(现在 GitHub 也可以创建私有仓库了😂), 而且提供了更好的隐私权限管理工具, 适合公司的内部团队使用.\nGit 命令\ngit init: 创建一个初始的 git 版本库 (git 仓库).\ngit add: 将当前的改动提交至暂存区 (暂存区一般称为: stage 或 index).\ngit commit: 提交到本地版本库, 提交后会在本地版本库中会新增一个节点.\ngit branch new-branch-name: 在当前位置新建一个分支, 但是并不会立即签出到新的分支上.\ngit branch new-branch-name HEAD-position : 在指定位置新建一个分支, 不会立即签出到新的分支上.\ngit branch -f branch-name HEAD-position: 强制修改特定分支到指定的 HEAD 位置. 不会修改节点信息, 只会修改分支名 (分支名是一个游标).\ngit checkout branch-name: 签出到特定分支上, 修改 HEAD 指向指定的分支名.\ngit checkout -b new-branch-name: 在当前位置新建一个分支, 并签出到这个新分支上.\ngit checkout -b new-branch-name HEAD-position: 在指定的位置新建一个分支, 并签出到这个新分支上.\ngit merge branch-name: 将特定分支归并到当前分支中, 合并分支的一种方式, 提交树中会有明显的合并痕迹. 归并模式\ngit rebase branch-name: 将当前分支移动到特定分支中, 合并分支的另一种方式, 由于是直接移动, 所以被合并的分支会消失. 移动模式\ngit rebase branch-name-a branch-name-b: 将分支 b 移动到分支 a 中.\ngit reset branch-name^: 将当前分支撤销一步提交, 具有 3 种撤销方式. 仅对本地有效 [推荐使用]\ngit revert branch-name: 将当前分支撤销一步提交. 本地和远程都有效 [不推荐使用]\n\n相对引用 (HEAD-position)\ngit checkout branch-name^/~number: 相对引用.\ngit checkout main^ : 将 HEAD 修改为 main 分支回退 1 次后的节点.\ngit checkout bugFix~4 : 将 HEAD 修改为 bugFix 分支回退 4 次后的节点.\ngit checkout HEAD^ : 将 HEAD 回退 1 次. HEAD 必须大写\ngit checkout HEAD~4 : 将 HEAD 回退 4 次.\n\n\n\n图形客户端 Fork用户信息设置在仓库名的右侧有一个设置按钮, 可以对自己提交时的用户信息进行设置.\n\n勾选 Use global git credentials 时会使用全局级设置, 在需要单独设置用户信息时, 需要取消勾选并设置自己的用户信息.\n\n添加本地仓库如果本地已经有仓库了, 可以将仓库直接添加到 Fork 中. 点击 File-&gt;New Tab, 打开一个新的标签页, 或者直接点击标签栏最右侧的 + 号也可以创建新 Tab 页.\n\n将自己本地的仓库文件夹 (内部有一个 .git 文件夹的文件夹) 直接拖到 Repositories 处即可添加本地仓库. 另外还可以在 Repositories 处, 右键&#x3D;&gt;新建文件夹, 进行仓库的整理和归类. 双击添加的仓库即可打开仓库.\n多工作区在 Fork 中每一个标签页 (Tab) 就是一个仓库的信息, 可以在一个窗口中打开多个仓库, 这样上方就会同时出现多个 Tab 页.\n\n但是不同的工作内容 (修复 Bug; 新增功能; 修改美术或音频资源) 可能需要用到不同的仓库, 不同的分支, 此时多标签页已经无法满足要求了.\n这个时候可以使用多工作区来解决. 在软件的右上角有一个 Workspaces 按钮可以对工作区进行设置. 这个按钮上显示的文字是当前工作区的名称.\n\n可以理解为一个窗口一个工作区, 不同的工作区中可以放不同的标签页, 并且可以很方便的来回切换. 具体的自己去配置一下试试吧.\n添加远程仓库在仓库的下方有 Branches 和 Remotes, Branches 里面的是本地仓库的分支情况, Remotes 则是远程仓库中的分支情况.\n\nRemotes 中可以配置多个远端仓库, 虽然只能同时引用其中的一个, 但是可以随时修改引用哪一个仓库. 这个引用 git 中叫做追踪关系(tracking).\n在 Remotes 上右键, Add New Remote, 填入远程仓库的名称以及网络地址即可.\n\n本地的版本库信息 (也就是提交记录) 保存在本地仓库的 .git 文件夹内, 同样远端仓库的版本库信息保存在远端服务器的 .git 文件夹内. 添加远端服务器之后需要使用 Fetch 命令来拉取远程仓库中的版本信息, 拉取完之后就可以展开看到目前远端仓库中所有的分支了, 没有拉取的时候是没有左侧的三角号的, 也不能点击. 后面会说明 Fetch 命令, 当然你可以现在就跳转: Fetch 命令\nQuick Lunch说一下上方的几个按钮, 首先是 Quick Launch, 这是一个快速操作入口, 点击后会弹出一个窗口, 里面有很多常用的操作可以快速执行, 找不到需要的操作时可以进行搜索.\n\nFetch场景 1: 我们在刚来公司的时候克隆 (clone) 了远端仓库的所有内容, 此时我们本地仓库和远程仓库是一模一样的, 然后我们找到需要工作的分支, 新建分支开始工作, 工作了一周之后, 我们本地的 .git 版本库中新增了很多我们自己的提交, 但是你会发现整个的提交树中并没有这一周内其他人的提交情况, 因为其他人的提交情况全部保存在他们自己的电脑上或者他们 push 到了远端的 .git 文件夹内.\n场景 2: 我们在 Fork 上新加了一个远程仓库, 但是这个仓库的提交信息却没有任何显示, 怎么都找不到, 明明远程是有提交信息的.\n这时候就需要使用 fetch 了, 这个命令可以将远程仓库中的提交记录拉取到本地, 这样我们也就可以看到其他人的工作情况了. 在 Fork 软件中点击 Fetch, 选择要拉取哪个仓库的信息, 之后拉取即可.\nfetch 命令完成了很重要的两步:\n\n从远程仓库下载本地仓库中缺失的提交记录\n更新提交树中的远程分支游标\n\n[注]\n\nFork 的默认配置中会自动进行 Fetch, 每次在打开一个标签页或者切换标签页的时候都会自动 Fetch, 我这里是选择了关闭这个自动 Fetch, 因为他让我失去了一部分掌控感, 还是自己需要 Fetch 的时候手动去 Fetch 一下更有实感! 😂\n  \n\nfetch 只是拉取一遍提交记录, 也就是软件界面中间部分的提交树信息, 所以一般在需要查看目前仓库的提交情况时使用这个命令, 另外因为 fetch 不会对文件做任何的改动, 所以基本上来说这个按钮可以随便点. 当设置了多个远程仓库的时候, 点击 fetch 需要选择拉取的仓库.\n\n\nPullpull 也是拉取远端服务器的数据, 和 fetch 不同的是, pull 在拉取之后会将刚刚拉取的节点合并到当前签出的分支上. 等于先执行 fetch 命令, 之后执行 merge 命令.\n应用场景: 我们签出了远程分支 origin&#x2F;feature, 一周后在本地进行了一次提交, 但是在这一周内 origin&#x2F;feature 分支在远程仓库上进行了新的提交, 此时就需要先拉取远程仓库的提交, 之后再将刚刚拉取的远程节点合并到我们的本地分支上. 要实现这个效果可以先执行 fetch 命令, 之后执行 merge 或者 rebase 命令, 也可以直接执行 pull 命令.\n\n\n\n命令\n等效命令\n\n\n\npull\nfetch + merge\n\n\npull --rebase\nfetch + rebase\n\n\nPushPush 和 Pull 相反, Push 是将本地 .git 文件夹中的提交记录上传到远程服务器中. 比如要修改一个 Bug, 我们先找到 Bug 存在的分支, 之后新建一个分支开始工作, 工作过程中产生了很多的提交, 这些新的提交信息我们在本地都是可以清楚的看到的, 但是远程服务器中是没有这些提交信息的, 甚至连我们新建的那个分支都没有... 此时我们就可以使用 Push 命令将我们的工作情况上传上去. 第一次提交时由于我们是新建的分支, 远程版本库是没有的, 因此提交的时候软件会默认在远程版本库上新建一条同名的分支, 这是 Git 的默认操作, 我们不需要进行额外操作. 此时他人使用 Fetch 命令就可以看到我们的提交记录了.\npush 默认上传的时当前签出的分支, 可以使用参数将指定的分支进行上传.\n\npush remote-repository-name branch-name : 将本地的 branch-name 分支上传到远程的 branch-name 分支. 此时本地分支和远程分支同名.\npush remote-repository-name local-branch-name:remote-branch-name : 将本地的 local-branch-name 分支上传到远程的 remote-branch-name 分支. 此时本地分支和远程分支不同名, 并且 local-branch-name 也可以直接写一个节点. 记得本地位置和远程分支之间必须使用冒号 : 连接.\npush remote-repository-name :remote-branch-name : 本地分支参数省略时, 此命令的效果是删除远程的 remote-branch-name 分支.\n\ncheckoutCheckout 是签出操作, 将当前仓库中的所有文件变成指定分支中的样子. 一旦签出, 我们的工作区就和分支中的完全相同, 因此在切换分支的时候必须对当前分支上所作的变动全部保存或者直接提交.\n进阶操作cherry-pickcherry-pick 命令可以选择性地将提交树上其他分支的提交记录复制过来追加到 HEAD 上, 需要知道节点的 hash 值.\ncherry-pick node1-hash [node2-hash] [node3-hash] : 将节点 1 2 3 转移到当前分支上.\n[注] 未合并的节点所作的改变将被丢弃.\n在命令行中 cherry-pick 是这样使用的, 但是在 Fork 软件中怎么使用呢?\n场景想象: 我们在自己的工作分支上工作, 其中做了 5 次提交: a, b c d e, 这些提交中的 a, c, e 是真正有效的提交, 虽然 b, d 两次提交也作出了修改, 但是 b 中的修改全部都是 Debug 时用的测试代码, d 中的提交也全部都是 Print 时输出信息用的代码. 这些代码不需要合并到主分支上, 就是说这两次提交需要舍弃, 那么此时就可以使用 cherry-pick 了.\n首先将工作分支上的改动全部提交, 之后签出到要合并的主分支上, 如 develop 分支, 之后同时选中需要合并的 a, c, e 节点, 右键, 选择Cherry-pick... 就可以将 a, c, e 复制到主分支上了. 由于 cherry-pick 是复制操, 所以我们自己的工作分支还是保持不变的, 后面可以选择是否进行删除操作.\nrebase interactive命令格式: git rebase -i HEAD-position\n直译为: 交互式 rebase, 使用此命令会打开 UI 界面, 对指定范围的节点进行自定义操作, 下图中是所有可以做的操作.\n\n和 cherry-pick 一样, 被舍弃 (Drop) 的节点中所做的改变也会被舍弃.\ngit rebase -i HEAD~4 : 对当前节点以及前面的 3 个节点 (共 4 个节点) 进行自定义操作. 由于是移动模式, 所以被修改的节点会在原分支消失, 直接被移动到了主分支.\ntags &amp;&amp; describeGit 中有一个标签功能 (里程碑功能). 标签(里程碑)的作用就是一个不可变的永久指针, 它指向最初定义它的位置. 当发布了一个全新版本, 或者进行了一个大型重构等都可以使用标签对那次重大提交打一个 &quot;标记&quot;.\ngit tag tag-name node-name : 在指定的节点上新建一个标签(里程碑).\n标签(里程碑)主要是用来定位, 可以使用 git describe 命令来进行定位, 命令返回的格式为: [tag-name]-[step-number]-[position-hash].\n\ngit describe : 距离当前最近的里程碑到当前位置的提交次数. 假设当前节点 hash 为 c2, 是 v1 版本提交了 12 次后的结果, 则此命令返回: v1-12-c2.\ngit describe main : 距离 main 分支最近的里程碑到 main 分支的提交次数. 假设 main 分支 hash 为 c3, 是 v2 版本提交了 5 次后的结果, 则此命令返回: v2-5-c3.\ngit describe develop : 距离 develop 分支最近的里程碑到 develop 分支的提交次数. 假设 develop 分支 hash 为 c6, 是 v4 版本提交了 7 次后的结果, 则此命令返回: v4-7-c6.\n\n问题处理如何消除冗余提交 Squash &amp;&amp; Reset情景: 在工作时由于进行了多次不必要的提交, 所以提交树上产生了很多冗余的提交, 这对于强迫症来讲是坚决不能忍受的. 比如下图中在编写 Git 博客的时候产生了多次添加图片的冗余提交.\n\n\n方案1: 仅适应于本地仓库中的冗余提交, 一旦提交已经 Push 到了服务器上就不推荐使用这个方案了, 虽然理论上行得通, 但是容易出现冲突. 这个方案的想法是使用 Fork 上的 Squash (直译: 压扁) 来压缩提交数量. 首先将目前工作区所有的改动保存并提交, 之后同时选中所有需要压缩的节点 (顺序选择, 不要挑着选, 不然可能会有冲突), 右键, 选择: Squash into Parent..., 在弹出的窗口中会出现操作的详情, 窗口左下角默认会勾选备份, 确认无误后就可以点击右下方 Rebase 压缩提交记录了.\n\n[注] 这个操作需要对操作树中的节点具有很强的掌控感, 节点选择多了一个都会导致后期合并起来出问题, 强烈建议使用此操作之前找个空仓库多练习几次.\n\n方案2: 仅适应于本地或者 Push 到服务器但是还没有合并的情况. 应该说任何已经合并到主分支的提交都不能由非管理员进行回退! 方案 2 的想法就是使用 Reset 回退提交. Reset 的回退有 3 种方式, 每个对应的参数以及效果见下图.\n\n\n使用 Reset 回退之后 Push 到远端时默认会报错, 因为将一个旧的提交去覆盖新的提交肯定不行, 此时就需要使用 强制提交, 强制覆盖掉远端的提交记录.\n如何避免产生冗余提交 commit --amend\n第一种方案: git commit –amend 命令在提交时不会生成新的提交记录, 而是直接修改当前 HEAD 指向的节点, 这样就不会产生冗余的提交记录了, 但是 Fork 软件中好像没有这个功能. (我没有找到)\n\n第二种方案: 使用 Reset 命令先消除之前的无意义提交再重新提交, 回退时使用 Soft 方式即可. 完全掌控的情况下使用默认的 Mixed 方式也可以.\n\n第三种方案: 使用 Stash 功能.(推荐)\n\n适用情景: 当前我们在 A 分支上正在非常聚精会神加高度专注地实现一个屌炸天的模块, 思如泉涌, 简直键盘如飞地在编写代码~~~~然后这时, 收到一封邮件反馈出一个 bug, 非常严重, 必须马上解决, 优先级为 0 !!! 于是, 我们需要立即签出到 B 分支上 checkout 新的分支进行工作, 但是我们那个屌炸天的功能还没完成怎么办? 如果直接提交的话就会出现一个无意义的提交啊!! 咋整??\n使用 stash 命令. Stash 命令用来保存当前工作进度, 会把暂存区和工作区的改动保存起来, 在提交树中会显示为一个抽屉(?或者箱子?), 不会生成 commit 节点.\n\n\n\n如何修改之前提交的同时避免产生冗余提交场景: 当前在工作分支上有 3 次提交: a, b, c, 其中 b 提交仅仅只是提交了一个美术素材, 但是现在需要修改这个美术素材的分辨率, 怎么办? 虽然可以直接在当前位置修改然后再创建一个提交 d, 但是这样提交就乱套了.\n\n第一种方案: 使用 rebase -i 来调整 a, b, c 的提交顺序为: a, c, b, 之后使用 commit --amend 修改 b 提交, 最后再次使用 rebase -i 把提交顺序换回去. 但是这个方案中 rebase 很容易产生冲突, 所以弃用.\n\n第二种方案: 首先使用 cherry-pick 将 b 单独取出来到一个新分支上, 之后在新分支上对 b 进行修改, 提交后为 b2, 然后将 b2, c 这两个提交  cherry-pick 到另一个新分支上, 之后使用这个新分支继续工作, 这样可以保证不会产生冲突. 最后那两个旧分支可以删除.\n\n\n使用 merge 还是 rebase先看一下 rebase 和 merge 相比时, rebase 的优缺点:\n\nrebase 的优点: rebase 使提交树变得很干净, 所有的提交都在一条线上, 不会保留工作时的分支记录.\n\nrebase 的缺点: rebase 修改了提交树的历史, 比如, commit A 可以被 rebase 到 B 之后, 从提交树中看的话 A 中的工作是在 B 之后进行的, 但是实际上是在 B 之前.\n\n\n因此如果没有这方面的规定的话, 使用 merge 还是 rebase 取决于个人爱好, 如果你喜欢保留所有的提交历史, 这样从提交树中看来浏览整个项目的发展历程, 那么你自然需要使用 merge, 如果你不喜欢那些历史性的分支, 而是喜欢看到一颗非常干净的提交树, 那么你自然需要使用 rebase. 这东西仁者见仁, 智者见智.\n如何有效避免 .git 文件体积增大首先最重要的就是必须设置 .gitignore 文件, 这个是提交前必做的事项, 项目中全部的临时文件都不能上传到 Git 上, 其他的就是一句话概括: 禁止提交大文件!\n当然这也太笼统了, 哈哈!\nGit 最害怕的就是无法进行内容修改比对的文件, 比如图片, 音频文件, 这些文件一旦修改了, Git 只能重新保存一份新的数据, 无法像文本文件, 代码文件那样仅保存改动信息, 因此这些文件如果提交到了 Git 上则需要确保不能进行频繁修改. 规避掉这一点就能有效避免 .git 文件夹体积过大.\n如何让 Git 识别文件名称的大小写变化Git 默认不区分文件名大小变化.\n首先我们创建一个文件叫 readme.txt, 编辑内容, 之后提交, 推送到远程仓库.\n然后我们在本地修改文件名为 Readme.txt, 之后再次提交, 但是此时会发现 Git 检测不到任何变化.\n原因是 Git 默认对于文件名大小写是不敏感的, 所以当我们仅修改了文件名的大小写时, Git 并没有检测到任何改动.\n解决方案: 在仓库目录中打开 Git 终端, 输入 git config core.ignorecase false, 回车即可.\n执行完之后在仓库级别的 (不明白看文章开头) 配置文件中就会多一行配置\n\n这样 Git 就可以不会再忽略大小写改动了.\n为什么 Git 中文件的修改纪录会发生跳跃 ? 为什么本次的修改不是以上次的结果为基准 ?一句话描述就是发生了舍弃操作, 把一部分修改舍弃了\n进行变基或者合并操作时, 修改的内容产生了冲突, 在解决冲突的时候直接舍弃掉了某一方的修改, 这样查看修改记录时就会发现出现了跳跃\n为什么文件中会残留冲突描述文本 ?这 TMD 绝对是某些人用了什么诡异的操作, 没有按照正规的变基流程进行变基, 怒!!!\n已查明原因, 请移步 这里 查看!\n如何一键删除本地全部冗余分支 ?git branch | grep -v &quot;$(git branch --show-current)&quot; | xargs git branch -d\n","categories":["Git"],"tags":["Git"]},{"title":"入门 MPV 播放器","url":"/kuroha/how_to_use_mpv_player.html","content":"\n\n播放器简介默认情况下, MPV 播放器并不提供 GUI 界面, 需要通过命令行或配置文件进行设置, 它配置灵活, 性能优秀, 支持硬件解码.\n基于开源, MPV 衍生出来一大批第三方播放器, 比如 Mac 平台上的 IINA, 以及 Baka MPlayer, bomi, mpc-qt, xt7-player-mpv 等, 它们的核心都是 MPV.\n播放列表\n   MPV 支持播放列表文件 (如: m3u).\n   如果需要临时播放多个文件, 打开MPV, 选中多个文件拖入窗口.\n   鼠标右键单击 上一个 或者 下一个 按钮可以临时显示当前播放列表.\n   如果需要将该目录的所有文件全部添加进 MPV 的播放列表中, 使用命令: mpv *.*\n\n文件关联\n   解压 mpv-install-master.zip 文件, 这里是下载地址.\n\n   将三个文件（mpv-document, mpv-install.bat, mpv-uninstall.bat）移动到自定义的 MPV 程序目录下.\n\n   以管理员身份运行 mpv-install.bat 进行文件关联. mpv-uninstall.bat 则是用来解除文件关联的.\n\n   没做第 3 步之前, 进入 Win10 Setting 设置默认应用时, 会找不到 MPV, 做完第 3 步之后就可以进入 Win10 Setting 设置默认应用了.\n\n\n快捷键 (区分大小写)播放控制\n\n\n快捷键\n快捷键\n作用说明\n\n\n\np\nSpace\n暂停, 继续播放\n\n\nNum&#x2F;\nNum*\n减少音量 &#x2F; 增加音量\n\n\n9\n0\n减少音量 &#x2F; 增加音量\n\n\nm\n\n静音\n\n\n←\n→\n快退 &#x2F; 快进 5 秒\n\n\n↑\n↓\n快进 &#x2F; 快退 1 分钟\n\n\n&lt;\n&gt;\n上一个 &#x2F; 下一个（播放列表中）\n\n\nEnter\n\n下一个（播放列表中）\n\n\nl\n\n设定 &#x2F; 清除 A - B 循环点\n\n\nL\n\n循环播放\n\n\ns\n\n对本机画面进行全屏截图\n\n\nS\n\n对源画面进行全屏截图\n\n\nq\n\n停止播放并退出\n\n\nQ\n\n保存当前播放进度并退出\n\n\n视频音频控制\n\n\n快捷键\n快捷键\n作用说明\n\n\n\n_\n\n循环切换可用视频轨\n\n\nA\n\n循环切换视频画面比例\n\n\nAlt+0\n\n0.5倍源视频画面大小\n\n\nAlt+1\n\n1倍源视频画面大小\n\n\nAlt+2\n\n2倍源视频画面大小\n\n\n#\n\n循环切换可用音频轨\n\n\nCtrl +\nCtrl -\n音轨延迟+&#x2F;- 0.1秒\n\n\n.\n\n下一帧\n\n\n,\n\n上一帧\n\n\n字幕控制\n\n\n快捷键\n快捷键\n作用说明\n\n\n\nV\n\n开启&#x2F;关闭字幕\n\n\nj\nJ\n循环切换可用字幕轨\n\n\nx\nz\n字幕时间轴 + &#x2F; - 0.1 秒\n\n\nr\nt\n上移&#x2F;下移字幕位置\n\n\n窗口控制\n\n\n快捷键\n作用说明\n\n\n\nf\n进入&#x2F;退出全屏\n\n\nESC\n退出全屏\n\n\n播放速度控制\n\n\n快捷键\n作用说明\n\n\n\n[\n0.9倍慢速播放\n\n\n]\n1.1倍快速播放\n\n\n{\n0.5倍慢速播放\n\n\n}\n2.0倍快速播放\n\n\nBackspace\n重置为正常播放速度\n\n\n色彩调节\n\n\n快捷键\n快捷键\n作用说明\n\n\n\n1\n2\n对比度-&#x2F;+\n\n\n3\n4\n亮度-&#x2F;+\n\n\n5\n6\n伽马-&#x2F;+\n\n\n7\n8\n饱和度-&#x2F;+\n\n\n其他功能\n\n\n快捷键\n快捷键\n作用说明\n\n\n\ns\nS\n包含 &#x2F; 不包含字幕进行截图\n\n\ni\n\n显示视频的详情参数\n\n\n自定义配置程序配置文件路径C:\\Users\\Kirito\\AppData\\Roaming\\mpv\\mpv.conf\n快捷键配置文件路径C:\\Users\\Kirito\\AppData\\Roaming\\mpv\\input.conf\n下面是我的自定义快捷键设置\n# 鼠标滑轮调节音量WHEEL_UP add volume 1WHEEL_DOWN add volume -1# 等号键循环切换窗口置顶= cycle ontop# alt + 方向键旋转画面 (依赖 cycle-video-rotate.lua 脚本)alt+left script-message Cycle_Video_Rotate -90alt+right script-message Cycle_Video_Rotate 90\n\n脚本文件路径C:\\Users\\Kirito\\AppData\\Roaming\\mpv\\scripts\\...\n脚本是 MPV 配置的重头戏. MPV 启动时, 保存在 scripts 文件夹里的脚本文件会自动加载并且执行. 官方 wiki 里有收录的脚本列表, 可以自行查阅, 寻找自己喜欢的功能脚本.\n脚本推荐autoload.luaautoload.lua: 自动加载当前播放文件目录里的视频文件到播放列表, 也就是自动连播, 原生 MPV 不具有这个功能.\nmpv_thumbnail_script.luampv_thumbnail_script.lua: 生成并显示预览缩略图.\nsave-sub-delay.luasave-sub-delay.lua: 遇到外挂字幕时间轴不正确的情况, 调好之后, 这个脚本会保存 delay 信息.\ncycle-video-rotate.luacycle-video-rotate.lua: 实现旋转屏幕效果.\n下载地址脚本下载地址: Github MPV Tools\n","categories":["LifeTips"],"tags":["MPV"]},{"title":"如何购买一款理想的路由器","url":"/kuroha/how_to_buy_a_router.html","content":"\n\n考虑因素一: 频段与带宽单频, 双频, 三频早期的无线路由器只支持 2.4GHz 一个频段, 现在的主流无线路由器都支持 2.4GHz 和 5GHz 两个频段, 就是所谓的双频路由器. 也有部分高端路由器支持一个 2.4GHz 和两个 5GHz 频段, 就是三频路由器.\n\n单频路由器: 只支持 2.4GHz 一个频段.\n双频路由器: 支持一个 2.4GHz 和一个 5Ghz 共两个频段.\n三频路由器: 支持一个 2.4GHz 和两个 5GHz 共三个频段.\n\n2.4GHz 和 5GHz 两种频段各自的优缺点电磁波的物理特性是 &quot;波长越长, 传播过程中的衰减越少&quot;2.4GHz 的信号波长长, 所以衍射和反射能力很强, 在室内环境下比 5GHz 的信号覆盖的范围更广, 也就是常说的穿墙能力强. 缺点是目前工作在这个频段的设备太多, 相互干扰比较严重, 大家互相抢占带宽, 速度会比较慢.\n5GHz 的信号波长短, 所以在与路由器相同距离的情况下, 5GHz 的信号强度比 2.4GHz 的信号强度弱.  但是, 由于 5GHz 支持新的通信协议并且目前工作在这个频段的设备较少, 所以速度要快很多.\n\n由此可以得出结论:**信号强速度就快是不对的! **\n比如一个有 2 格信号的 5GHz WIFI 和一个有 4 格信号的 2.4GHz WIFI, 那么 4 格信号的 WIFI 速度就比 2 格信号的 WIFI 速度快. 这是不对的! 不对的! 不对的!\n带宽是 &quot;信道的宽度&quot;因为有一些协议支持将相邻的信道绑在一起以增加带宽(信道宽度), 所以不同协议下的带宽(信道宽度)有所不同. 再加上高通公司还出了 QAM 技术, 也会增加带宽(信道宽度), 所以带宽(信道宽度)要具体情况具体分析.\n \n考虑因素二: 协议IEEE 802.11 协议簇是用于无线局域网通用的标准.常用的协议包括:\n\n802.11a: 工作频率为 5GHz, 最大原始数据传输率为 54Mb&#x2F;s.\n802.11b: 其载波的频率为 2.4GHz, 可提供 1, 2, 5.5 及 11Mbit&#x2F;s 的多重传送速度.\n802.11g: 其载波的频率为 2.4GHz（跟802.11b相同）, 共14个频段, 原始传送速度为 54Mbit&#x2F;s, 净传输速度约为 24.7Mbit&#x2F;s（跟802.11a相同）. 802.11g 的设备向下与 802.11b 兼容.\n802.11n: 增加了对 MIMO (多用户输入多用户输出) 的支持, 允许 40MHz 的无线频宽, 最大传输速度理论值为 600Mbit&#x2F;s.\n802.11ac: 通过 5GHz 频带进行无线局域网通信. 理论上:\n\n1: 进行多站式无线通信, 它能够提供最少每秒 1 Gbit&#x2F;s 的带宽.\n\n\n\n2: 进行单信道无线通信, 它能够提供最少每秒 500 Mbit&#x2F;s 的带宽.\n\n\n\n\n\n\n协议\n常见速率(单信道)\n2.4GHZ\n5GHZ\n\n\n\n802.11a\n54 Mbit&#x2F;s\n\n支持\n\n\n802.11b\n11 Mbit&#x2F;s\n支持\n\n\n\n802.11g\n54 Mbit&#x2F;s\n支持\n\n\n\n802.11n\n72.2 Mbit&#x2F;s\n支持\n支持\n\n\n802.11ac\n433.3 Mbit&#x2F;s\n\n支持\n\n\n考虑因素三: SU-MIMO 和 MU-MIMO\nSU-MIMO 是 Single-User Multiple-Input Multiple-Output 的缩写, 即: 单用户多输入多输出技术. 简称 MIMO, 即:  Multiple-Input Multiple-Output, 多输入多输出技术. 能利用发射端的多个天线各自独立发送信号, 同时在接收端用多个天线接收并恢复原信息.\n\nMIMO 技术可以成倍地增加带宽. 假设发射端和接收端都有一组天线, 记做 1x1, 此时的带宽为 x. 那么如果发射端和接收端各有 2 组天线, 且都支持MIMO, 记做 2x2, 那么此时的带宽就变成了 2x.\n\nMIMO 也包含旧的 SIMO（单输入多输出系统）和 MISO（多输入单输出系统）. SIMO 和 MISO 的好处是可以增加信号的灵敏度.\n\nMU-MIMO 是 Multi-User Multiple-Input Multiple-Output 的缩写, 即: 多用户多输入多输出技术. 只有 802.11ac Wave 2 及以上协议才支持的一种技术, 可以让路由器同时和多个终端建立联系, 并且做到多个终端互不干扰, 最重要的是只需发射端支持即可.\n\n【注】SU-MIMO 路由器每次只连接一个设备, 但它会在所有的连接设备中快速的切换, 给人一种好像同时连接了多个设备一样, 但其实同一时刻只连接一个设备. 而 MU-MIMO 路由器就可以真正地做到同时连接多个设备.\n\n\n考虑因素四: 调制方式正交幅度调制: QAM 即: Quadrature Amplitude Modulation正交幅度调制 (QAM) 即: Quadrature Amplitude Modulation, 它是一种在两个正交载波上进行幅度调制的调制方式. 这两个载波通常是相位差为 π&#x2F;2 的正弦波, 因此被称作正交载波.\n\n802.11n 使用 64-QAM 在 40MHz 带宽下速率可以达到 150Mb&#x2F;s.\n802.11ac 使用 256-QAM 在 80MHz 带宽下速率可以达到 433.3Mb&#x2F;s.\n\n高通推出了一种调制方案:\n\n对 802.11n 协议的信号进行 256-QAM 调制, 突破了协议限制的最高速率, 可以达到 200M, 称为 Turbo QAM.\n\n对802.11ac 协议信号进行 1024-QAM 调制, 突破了协议限制的最高速率, 可达到 541.7M, 称为 Nitro QAM.\n\n\n要使用这种技术, 需要发射端和接收端都支持才可以.\n部分 TP-Link 路由器参数\n\n\n型号\nMU-MIMO\nTurbo QAM\n千兆\n2.4G 天线\n5G 天线\n2.4G 带宽\n5G 带宽\n实际带宽\n宣传带宽\n\n\n\nWR742N\nN\nN\nN\n1\n0\n150 Mb&#x2F;s\n0 Mb&#x2F;s\n150 Mb&#x2F;s\n150 Mb&#x2F;s\n\n\nWR890N\nN\nN\nN\n3\n0\n450 Mb&#x2F;s\n0 Mb&#x2F;s\n450 Mb&#x2F;s\n450 Mb&#x2F;s\n\n\nWDR5600\nN\nN\nN\n3\n1\n450 Mb&#x2F;s\n433 Mb&#x2F;s\n889 Mb&#x2F;s\n900 Mb&#x2F;s\n\n\nWDR6300\nN\nN\nN\n2\n2\n300 Mb&#x2F;s\n433X2 Mb&#x2F;s\n1166 Mb&#x2F;s\n1200 Mb&#x2F;s\n\n\nWDR6500\nN\nN\nN\n3\n2\n450 Mb&#x2F;s\n433X2 Mb&#x2F;s\n1316 Mb&#x2F;s\n1300 Mb&#x2F;s\n\n\nWDR7500\nN\nN\nN\n3\n3\n450 Mb&#x2F;s\n433X3 Mb&#x2F;s\n1749 Mb&#x2F;s\n1750 Mb&#x2F;s\n\n\nWDR8500\nY\nN\nN\n3\n4\n450 Mb&#x2F;s\n433X4 Mb&#x2F;s\n2182 Mb&#x2F;s\n2200 Mb&#x2F;s\n\n\nWDR8600\nY\nY\nY\n4\n4\n800 Mb&#x2F;s\n433X4 Mb&#x2F;s\n2532 Mb&#x2F;s\n2600 Mb&#x2F;s\n\n\n总结: 如何选择路由器宽带速度\n如果宽带速度大于 100Mb&#x2F;s, 就一定要选择具有千兆有线接口的路由器.\n如果有 NAS 这种需要高速连接的设备, 也要选择具有千兆有线接口的路由器.\n【注】现在的路由器都宣称 &quot;千兆路由&quot;, 这个千兆其实指的是无线速度, 就是从路由器向终端设备传输的速度. 但是我们这里所说的 &quot;千兆&quot; 是指有线速度, 从光猫向路由器传输的速度, 就是 WAN 口和 LAN 口的速度.\n\n\n如上图左面这一款路由器, 它只有无线支持千兆, 但是有线并不支持千兆, 这样其实是没啥用的. 假设你家里网线的带宽为 200 Mb&#x2F;s, 那么其中 100 Mb&#x2F;s 的带宽就浪费掉了, 因为路由器的有线接口并不支持千兆. 因此我们需要购买千兆路由的话, 自然要选择右面这一款.\n无线频段\n双频路由: 这是目前市场的主流, 支持 802.11ac 的终端也越来越多, 所以推荐购买双频路由.\n三频路由: 现在这种还算是新产品, 价格昂贵! 所以......\n单频路由: 除非特别原因已经不推荐购买了.\n\n千万不要一味追求高端路由器在实际使用中是很难达到理论最高速度的.\n因为会有其他无线路由器的信号干扰\n因为终端设备 (手机, 空调, 冰箱, 电脑等可以连接路由器 WiFi 的设备) 并没有那么多组天线支持 MIMO. 一般来说低端手机是 1 组天线, iPhone 是2 组, iMac 和一些高端笔记本是 3 组, 支持 4 组天线的终端屈指可数.所以根本没有必要刻意追求高端路由器, 一般来说 2.4GHz 和 5GHz 各有 2 组天线, 即标称 1200M 的路由器已经足够一般家庭日常使用.\n若终端多, 则可以适度提高选购型号因为高端路由内存大, CPU 性能好, 能够保证在多个设备连接的场景下也不会卡顿.\n\n噱头 (常见误区)天线内置与外置! ?结论1: 天线内置或外置并不影响信号的强度\n国内市场消费者更倾向于购买多外置天线的路由器, 动辄 6 个以上外置天线. 在这点上 TP-Link 品牌尤其明显. 其在国内的产品, 300 元就能做到外置 6 天线, 而其在国外的产品, 价格 2000+ 的高端产品也只是 3 个可见的外置天线. 但显然后者的信号更强, 更稳.\n结论2: 外置天线的数量和信号的强度没有正相关\n结论3: 全部天线的数量和信号的强度正相关 ( 天线数量 &#x3D; 内置天线数量 + 外置天线数量 )\n\nUSB 接口! ?这个通常出现在中高端路由器上, 一般是用来接存储设备或打印设备的.\n考虑到我国家庭的打印机保有量, 就不提打印设备了. 大家一般都是挂移动硬盘来下载电影, 起到一个低端 NAS 的作用.\n但由于路由器的芯片计算能力比较差, 通常 IO 性能都比较弱. 甚至有些路由器由于设计问题, USB3.0 接口太靠近 2.4GHz 天线, 反而影响了 2.4GHz 信号, 这就有点得不偿失了.\n结论4: **目前 USB 接口功能纯属画蛇添足! **\n智能路由! ?路由器其实可以看做是一个嵌入式系统, 一般来说, 这个系统在出厂预装后就很少再有更新, 厂商也很少升级.\n在某个事件后, 大神们明白了路由器的系统是如何操作路由器硬件的, 于是就有了第三方固件. 第三方固件的好处是可以支持更多的功能, 比如去广告, 科学上网等. 常见的第三方固件有 openwrt padavan ddwrt 等. 通常来说刷第三方固件都会让你的路由变得不稳定, 但是如果你是魔法师的话, 还有什么可畏惧的呢.\n因此目前国内市场上的一些所谓 &quot;智能路由&quot;, 都是基于 openwrt 系统, 加上一些插件和管理 APP 而已. 本质上就是 &quot;非智能路由&quot; 刷了第三方固件而已, 你可以近似理解为安卓手机的刷机, 苹果手机的越狱.\n结论5: **智能路由? 对于爱折腾的人来说, 这就是在浪费钱, 对于不爱折腾的人来说, 这就是一个扣分项. **\n","categories":["LifeTips"],"tags":["生活知识"]},{"title":"QBittorrent 实现自动追番","url":"/kuroha/qbittorrent_proxy.html","content":"\n\n下载安装先下载安装一下 QBitTorrent, 喜欢折腾的话也可以再下载一下自己喜欢的主题\nQBitTorrent\nQBitTorrent Theme\n\n蜜柑计划RSS 订阅集合, 傻瓜式使用难度, 只说明一点, 不会获取 RSS 链接的话, 直接在 RSS 图标上打开右键菜单, 点击复制链接即可\n蜜柑计划\nQBitTorrent 设置之 &quot;代理服务器&quot;\n打开 &quot;设置&quot;, 找到 &quot;连接&quot; 项, 其中有一个 &quot;代理服务器&quot; 的子项目\n&quot;类型主机端口&quot; 一栏按照自己的代理设置进行填写, 例如: 类型选择 &quot;HTTP&quot;, 主机填写 &quot;127.0.0.1&quot;, 端口填写 &quot;1080&quot;\n通过代理查找主机名由于之前的蜜柑计划需要翻墙, 所以必须勾选\n认证一般不需要勾选\n对 BitTorrent 目的使用代理一般不需要勾选\n使用代理服务器进行用户连接一般不需要勾选\n对 RSS 目的使用代理建议勾选\n对常规目的使用代理建议勾选\nQBitTorrent 设置之 &quot;RSS 订阅&quot;\n在 RSS 设置项中勾选 &quot;启用获取 RSS 订阅&quot;\nQBitTorrent 设置之 &quot;自动下载&quot;在 RSS 设置项中勾选 &quot;启用 RSS Torrent 自动下载&quot;\n添加 RSS 订阅\n配合 Jellyfin 以及 MPV 食用更佳下面是我现在的配置\n\n\n\n","categories":["LifeTips"],"tags":["QBittorrent"]},{"title":"社会保险制度","url":"/kuroha/social_insurance.html","content":"\n\n社会保险的结构构成\n注: 由于后续政策可能变动, 所以在阅读本文之前, 请注意文章的最新更新时间.\n\n直接上图:\n\n\n&quot;社会保险&quot; 简称 &quot;社保&quot;, &quot;城镇职工社会保险&quot; 简称 &quot;职保&quot;, &quot;城乡居民社会保险&quot; 简称 &quot;居保&quot;.\n\n&quot;社保&quot; 一词非常广泛, 内部包含 7 种社会保险.\n\n&quot;社保&quot; 分为两个大类: 一个是针对就业群体的 &quot;职保&quot;, 另一个是针对无业人群的 &quot;居保&quot;.\n\n&quot;职保&quot; 全称: &quot;城镇职工社会保险&quot;, 它包含五种保险: &quot;城镇职工基本养老保险&quot;, &quot;城镇职工基本医疗保险&quot;, &quot;城镇职工失业保险&quot;, &quot;城镇职工工伤保险&quot;, &quot;城镇职工生育保险&quot;.\n\n&quot;居保&quot; 全称: &quot;城乡居民社会保险&quot;, 它只包含两种保险: &quot;城乡居民基本养老保险&quot; 和 &quot;城乡居民基本医疗保险&quot;. 由于 &quot;失业保险&quot;, &quot;工伤保险&quot;, &quot;生育保险&quot; 都是和工作息息相关的, 所以 &quot;居保&quot; 自然不包含这三种保险.\n\n&quot;医保&quot; 一词非常容易混淆, 它指代两种保险: &quot;城镇职工基本医疗保险&quot; 和 &quot;城乡居民基本医疗保险&quot;, 不同情况下要弄清具体含义.\n\n\n城镇职工基本养老保险\n&quot;城镇职工基本养老保险&quot; 的目的是保障我们年迈退休后的基本生活需求, 为我们提供稳定可靠的生活经济来源.\n\n&quot;城镇职工基本养老保险&quot; 是由企业和我们按照不同的缴费比例共同缴纳费用的. 按月缴纳.\n\n&quot;城镇职工基本养老保险&quot; 的待遇是当我们退休后可以领取到养老金. (有前提条件)\n\n\n城镇职工基本医疗保险\n&quot;城镇职工基本医疗保险&quot; 简称 &quot;医保&quot;.\n\n&quot;城镇职工基本医疗保险&quot; 的目的是减轻我们生活中因患病或受伤害而带来的医疗开销.\n\n&quot;城镇职工基本医疗保险&quot; 也是由企业和我们按照不同的缴费比例共同缴纳费用的. 按月缴纳.\n\n&quot;城镇职工基本医疗保险&quot; 的待遇是当我们患病并去医疗机构就诊而发生医疗费用后, 由医疗保险机构给予一定的经济补偿.\n\n\n城镇职工失业保险\n&quot;城镇职工失业保险&quot; 的目的是为那些因失业而暂时中断生活经济来源的劳动者提供物质帮助以保障其基本生活, 并通过专业训练, 职业介绍等手段为其再就业创造条件.\n\n&quot;城镇职工失业保险&quot; 也是由企业和我们按照不同的缴费比例共同缴纳费用的. 按月缴纳.\n\n&quot;城镇职工失业保险&quot; 的最主要待遇是当我们失业时可以领取到失业保险金. (有前提条件)\n\n\n城镇职工工伤保险\n&quot;城镇职工工伤保险&quot; 是指劳动者在工作中或在规定的特殊情况下, 遭受意外伤害或患职业病导致暂时或永久丧失劳动能力甚至死亡时, 劳动者或其遗属从国家和社会获得物质帮助的一种社会保险制度.\n\n&quot;城镇职工保险&quot; 生效的认定办法: 工伤保险实行无过错责任原则. 无论工伤事故的责任归于用人单位还是职工个人或第三者, 用人单位均应承担保险责任.\n\n&quot;城镇职工工伤保险&quot; 的缴费: 劳动者不缴纳工伤保险费, 全部费用由用人单位负担, 按月缴纳.\n\n&quot;城镇职工工伤保险&quot; 的待遇是当我们因工负伤或职业病暂时或永久失去劳动能力以及死亡时, 可以获得工伤保险金.\n\n\n城镇职工生育保险\n&quot;城镇职工生育保险&quot; 是在劳动者因生育子女而导致劳动力暂时中断时, 由国家和社会及时给予物质帮助的一项社会保险制度.\n\n&quot;城镇职工生育保险&quot; 的缴费: 劳动者不缴纳生育保险费, 全部费用由用人单位负担, 按月缴纳.\n\n&quot;城镇职工生育保险&quot; 的待遇主要包括两项: 一是生育津贴, 二是生育医疗待遇.\n\n\n城乡居民基本养老保险\n&quot;城乡居民基本养老保险&quot; 的目的是保障城镇老年居民和乡村老年居民的基本生活需求, 为他们提供稳定可靠的生活经济来源.\n\n&quot;城乡居民基本养老保险&quot; 的缴费是自选档次进行缴费, 档次越高费用越高, 国家补贴一部分费用. 按年缴纳.\n\n&quot;城乡居民基本养老保险&quot; 的待遇也是可以领取到养老金, 采用多缴多得原则, 年轻时上缴的总金额越多, 年迈时领取到的养老金也就越多. (有前提条件))\n\n\n城乡居民基本医疗保险\n&quot;城乡居民基本医疗保险&quot; 也简称 &quot;医保&quot;, 医保是最需要大家关注的保险, 应当深入了解学习.\n\n&quot;城乡居民基本医疗保险&quot; 的目的是减轻城镇居民和乡村居民因患病或受伤害而带来的医疗开销.\n\n&quot;城乡居民基本医疗保险&quot; 的缴费也是自选档次进行缴费, 档次越高费用越高, 国家补贴一部分费用. 按年缴纳.\n\n&quot;城乡居民基本医疗保险&quot; 的待遇也是当我们患病并去医疗机构就诊而发生医疗费用后, 由医疗保险机构给予一定的经济补偿, 但是报销比例比起 &quot;城镇职工基本医疗保险&quot; 要低一些.\n\n\n常见问题我只是一个农民, 我想知道我一直缴纳的 &quot;社保&quot; 是什么?农民不属于职工, 所以农民所缴纳的社保就是指 &quot;城乡居民社会保险&quot;, 包含 &quot;城乡居民基本养老保险&quot; 和 &quot;城乡居民基本医疗保险&quot; 两种.\n我现在只是一名学生, 既不是失业, 也不是就业, 那么我一直缴纳的 &quot;社保&quot; 是什么?学生也不属于职工, 所以学生所缴纳的社保也是指 &quot;城乡居民社会保险&quot;, 但是学生不同于农民的地方是学生所缴纳的社保中不包含 &quot;城乡居民基本养老保险&quot;, 只包含 &quot;城乡居民基本医疗保险&quot;. 所以大多数时候老师或者校方会直接询问你是否缴纳 &quot;医保&quot;, 而不是询问你是否缴纳 &quot;社保&quot;. 当然这里所说的 &quot;医保&quot; 就是指 &quot;城乡居民基本医疗保险&quot;.\n我刚刚参加工作, 听说了 &quot;五险一金&quot;, 它是什么?由于已经参加了工作, 便成为了职工人员, 所以就出现了 &quot;五险一金&quot;. &quot;五险&quot; 自然就是指 &quot;城镇职工社会保险&quot; 了, 由于 &quot;城镇职工社会保险&quot; 包含五种保险, 所以也被称作 &quot;五险&quot;, 而 &quot;一金&quot; 指的是 &quot;住房公积金&quot;.\n我听说 &quot;五险一金&quot; 中有一个叫做 &quot;生育险&quot;, 可是我一个男生, 交 &quot;生育险&quot; 有什么用?\n虽然男生们不能生育宝宝, 但是男生们在公司也是有 10 天看护假期的, 按照生育险规定, 已参保的男性职工按规定享受看护假假期津贴.\n\n男生们不能生育宝宝, 但是你的太太是要生育宝宝的啊, 如果你的太太没有就业, 也就没有缴纳生育险, 但是由于你缴纳了 &quot;职保&quot;(职保包含生育险), 那么你的太太同样可以享受其中的生育险待遇.\n\n\n参考链接\n知乎用户 ID: 51社保余清泉\n\n","categories":["LifeTips"],"tags":["生活知识"]},{"title":"游戏笔记","url":"/game/game_note.html","content":"\n\n常用 Emoji😈🤠👻🦄🐔🐬🐤👀🦴✨🎄🔑💊📚⏳🍖🍸🥝🍉🍍🍑🍒🍓🍅🍐🍏🍎🍋🍊🍈🍀🌴🌈⚡🔥\n游戏灵感 - 剧情、故事、剧本[惰性系列] 廉价的真诚一个人的命运其实可以理解为是这个人的认知和经验阅历总和的体现.\n一个人要发展, 要成就更多的人, 那么就必须过 &quot;钱&quot; 这一关, 去做距离钱很近的事情, 才能慢慢地懂得人性, 才能慢慢摸清社会底层的运转规则, 只有懂得了人性、摸清了规则你才能成为强者去保护你想保护的人。\n真诚这项能力, 和其他能力组合都是极其强大的, 但是如果只有真诚本身, 那说明这个人是一个思想上极为懒惰的人, 当你的品质只有真诚时, 真诚就会变为单纯, 而极度的单纯就是思想上的极度懒惰。\n一定要学会去思考人性, 去和人性打交道, 不要懒, 去尝试, 去参与, 去体会, 只有真正学会这些, 了解这些, 才能称为是自己这本故事书的主人公, 而不是别人人生的陪演。\n[惰性系列] 做成年人的选择感悟自蜀国大将军姜维\n姜维在蜀国选择投降时, 依然心存希望, 选择假意投降, 联合钟会谋反让蜀国幽而复明, 虽然最终失败, 但是这才是成年人的选择, 而不是一死了之, 那是未成年人的做法\n面对困难首先想到的是逃避, 放弃, 一死了之, 这是不行的. 卧薪尝胆是困难的, 但正因为是困难的, 所以它才需要努力, 它才值得去争取! 从这里也可以延申推断出拖延症的症结也是逃避, 逃避那些困难的事件, 这也是不对的, 适当的劳逸结合可以, 但不能始终去逃避.\n[反战] 战争、武力、和平观点来自高达 00 中的玛丽娜. 武力解决问题确实很方便, 打就完事了嘛, 最后谁活着谁是对的!\n但不管是什么理由的战争与暴力, 即使是出自正义的理由, 也一样会伤害到无辜的人。对暴力和武力彻底的拒绝, 以及探索如何实现暴力和武力的彻底杜绝, 才是一个真正和平的社会应抱有的态度.\n[寿命论]来自芙莉莲. 芙莉莲作为精灵族, 寿命几乎无限, 面对昔日的朋友, 异常开心, 使用大量镜头刻画芙莉莲和旧友的感情, 但是最终旧友的一句鼓励: 加油啊, 一定要打败魔王! 直接泪目, 因为魔王早就被打败了! 昔日的好友也早已苍老糊涂了.\n[克隆人]来自蜡笔小新. 一开始便从被机械化的主角出发来讲故事, 去体验家人的情感变化. \n家人见到机械化的主人公, 从恐慌, 到交流, 到理解, 到最后接受, 总之让玩家觉得主人公被机械化, 虽然遇到了各种不便, 虽然内心极度恐慌, 虽然家人们一开始也不接纳自己, 但好在家人们理解自己, 经过几周, 几月, 几年的相处, 自己还是融入了家庭, 这是一个非常温馨的故事.\n但紧接着故事大反转, 主人公其实并没有机械化, 这个机械的只是主人公的机械体, 真正的主人公还活着, 但是家人们已经接受了目前的主人公, 两个主人公都是主人公啊, 这一点一定要突出刻画, 他俩没有善恶之分, 机械的也是在追求自己的爱人, 自己也是真心爱着家人们的, 而且这段时间内, 几年内, 明明一直都是自己陪在家人身边的, 为什么突然一个所谓的 &quot;真的&quot; 来了, 然后我就要离开 ? ! 凭什么呀 ? ! 为什么我要离开 ?\n[基础概念] 为人处世的基础概念\n如果你决定不再和某个人有任何的联系, 那么就不需要再去得罪他&#x2F;她, 再去和他&#x2F;她产生任何的交集, 直接默默断开联系即可.\n\n伺候和照顾的区别, 照顾是帮忙做他&#x2F;她不会做或者做不到的事情, 而伺候是, 他&#x2F;她自己会做的, 能做到的事情, 却还要帮他&#x2F;她做.\n\n\n游戏灵感 - 玩法、机制、表现[通用] 元素机制风 火 电 水 土 冰 木 光 暗 毒 生命\n生命 &#x3D; 光 + 木毒 &#x3D; 暗 + 木沼泽 &#x3D; 水 + 土毒沼泽 &#x3D; 毒 + 沼泽气 &#x3D; 电 + 水火 &#x3D; 光 + 木\n风会助长火势电可以在有水的地形上蔓延火可以在草原上蔓延水可以让毒素蔓延山体阻挡狂风\n[通用] 出力机制攻击力可调, 攻速也可调, 此机制可以实现的效果:\n\n可以实现手下留情的机制, 宝可梦抓宠物, 剧情中饶对方一命;\n另外也可以强制初始出力 50%, 越打越猛, 实现类似龙珠中的悟空的效果. 即所有人打架都是看状态的, 一开始状态不可能全开, 肾上腺素还没开始分泌呢, 对吧 ? 所以一开始是不会使出全力的, 那么玩家同样, 对付小兵完全可以不用全力, 面对 BOSS, 在长时间的战斗后, 出力的上限越来越高, 甚至突破上限.\n或者设置高的出力会消耗更多的体力, 让玩家在面对 boss 前要温存体力, 但这样就有点像机战中机体的能量设定了, 需要取舍;\n\n[日式战棋] 迷雾机制这个东西有利有弊, 也没啥特殊的地方, 可以参考战场兄弟, 英雄联盟等迷雾机制, 可以用于迷雾森林, 比如异世界的世界观下, 探索迷雾森林很常见啦, 再就是夜晚等特殊剧情地图, 尽量不要作为基础的游戏机制.\n[日式战棋] 伏兵机制指定我方一名角色, 指定的角色消失, 当有敌人走到消失的位置附近 2 格时, 角色出现, 造成恐慌 buff. 这个机制设计的重点是必须表现出一种提前埋伏好的感觉, 那种运筹帷幄的计谋感.\n[日式战棋] 朝向机制主要也是为刺客准备的, 比如可以设置偷袭技能, 当被刺时可以提高伤害. 另外也可以用来演变成夹击甚至包围等战略或者剧情, 比如腹背受敌, 壮烈牺牲的剧情.\n[日式战棋] 隐身+再动机制也是为刺客准备的机制, 毕竟战棋中的刺客还是很难体现出刺杀的感觉嘛. 可以无视敌人的仇恨, 进行绕后偷袭.\n[日式战棋] 协乘机制为飞行单位准备的机制, 可以拉一个人移动.\n[日式战棋] 禁锢、抓取、推开机制参考自三国志 11, 游戏中可以抓取敌军的单位, 抓到面前来, 或者推开敌方单位, 推到落石处, 推到埋伏处, 推到陷阱处等等. 可以禁锢单位, 无法移动, 只能使用道具, 原地攻击等. 甚至还可以有眩晕, 直接强制待机.\n[日式战棋] 分身+夹击+包围机制只要是为了弥补夹击和包围很难触发的问题, 甚至可以结合朝向机制进行联动.\n[日式战棋] 一击脱离+致残机制一击脱离自身很难直接拉开距离, 但是配合致残, 就可以无限拉扯, 被致残的人是追不上的.\n[日式战棋] 切换机制灵感来自刀剑神域的 Switch, 主要体现角色之间的配合, 这也是我像制作的战棋游戏的终极目标: 配合感, 制作出像刀剑神域中一样的配合感的战棋游戏. 这里的切换可以完全按照刀剑神域中的演出来, 一个角色攻击后, 招架对方的攻击, 此时队友可以立即与其交换位置, 打出连携, 如果被切换的人同样可以切换, 甚至可以再切换回来, 另外想到的关于剧情的, 可以刻划一个悲伤的故事, 主人公四人的绝技, 四连斩, 但最后仅剩下主角一人, 在困境中, 其他三人的英灵出现, 四人久违的再次联手, 用出当年的绝技.\n[日式战棋] 连携作战机制连携作战机制, 使用行动条来规定行动的顺序, 当特定的角色在地图中的位置相邻一定范围, 并且行动顺序满足条件, 比如可以一起行动, 甚至间隔行动时, 会触发连携机制 (这样可以强行拉动行动慢的角色), 打出连携技, 比如水平四方斩, 高额伤害, 比起每个人的伤害相加都要高, 可以搭配类似的职业, 比如忍者职业, 可以变身成场景物品, 类似红警的幻影, 变成树, 变成石柱等地形, 而斥候可以识别出这些\n[日式战棋] 侦察盗贼, 斥候的技能, 可以探查一片区域是否有埋伏, 也就是会触发援兵的点, 或者陷阱, 或者埋伏, 固定剧情或许用处不大, 但是肉鸽地图呢, 每次都是随机的地图, 必须要盗贼\n[卡牌] 弃牌机制参考 &lt;带我去地下城吧&gt; 这部作品, 摒弃卡牌的抽牌概念, 转而使用弃牌, 既可以体现探索地牢是物资越来越少的感觉, 又可以完全取消抽牌所带来的运气要素, 切记运气是 rogue 游戏的大忌.\n游戏灵感 - 画面、特效、美术[武器] 刀枪模式灵感来自宇宙星神盖亚的炮剑, 异世界舅舅中女主的圣物, 轨迹系列中男二的枪斧, 血色佣兵中女狂战的刀型枪, 主要就是近战远程可以来回切换.\n[地图] 地图基础设计理念一副地图中, 大多数的不合理之处都来自于脱离发展过程的高楼平地. 其实先拟一遍城市从村落慢慢变为城市的逻辑过程, 这样推演出来的最终城市, 恢宏的同时又能兼具合理性, 如同桥是为了交通, 但交通是为了地区人口的流动, 不能为了一座看起来会很方便的桥梁而在两侧安插居民区, 而是为了两侧的居民区安置一座并不是效率最高的桥梁. 模拟的发展过程还能帮助完善城市的各个区域功能作用和背景.\n游戏网站\nFC 游戏集合\n\nDOS 游戏集合\n\nHTML 5 魔塔游戏集合\n\n俄罗斯方块\n\n\n游戏王\nMDPro3 作者: 赤子奈落\n\n游戏王娱乐力量全开\n\n游戏王 223 服务器\n\n联机匹配: 主机地址的两个空分别填入 s1.ygo233.com 和 233, 密码留空\n\n人机对战: 主机地址的两个空分别填入 s1.ygo233.com 和 233, 密码: AI\n\n好友约战: 房间密码输入任意文字, 房间名前加 M# 为比赛模式, T# 为 2V2 模式. 详细查阅: 房间设置\n\n\n泰拉瑞亚\n官网: Terraria\n\nMOD: 制作教程\n\n以下 MOD 均可以通过模组浏览器下载, 其对应的汉化包都可以使用模组 Localizer 下载\n\nLocalizer：汉化器\nCheatSheet：作弊器\nUnLeveled：血量界面美化\nBossChecklist：BOSS 进度查询\nCalamityMod：灾厄\nRecipeBrowser：合成表\nWheresMyItems：物品辅助查找\n\n\n\n星露谷物语\nMOD 加载器: SMAPI\n\nMOD 搜索器: SMAPI Search\n\n手册: WiKi\n\n农场上传: 星露谷物语农场\n\nMOD 网站: N 站\n\n\n","categories":["Game"],"tags":["Game"]},{"title":"CEMU 模拟器的正确使用姿势","url":"/game/game_cemu.html","content":"\n\n🍑 前言CEMU 是模拟任天堂 WiiU 平台的模拟器, WiiU 长下面这样, 是不是很像一台掌机呢? 当然这只是一个 Pad, 其实它是一台家庭主机!\n\n这篇博客会讲一下如何安装 CEMU 模拟器, 以及如何安装 CEMU 可用的游戏\n如果你是想要知道如何设置画面可以让游戏帧率最高且画质不会太差, 亦或是你想知道如何安装 Hook, 以及如何设置体感, 那你就需要找其他的文章了\n那我为什么要单独写一篇博客说明这件事情呢 ? 安装软件和游戏不是很简单吗 ?\n是很简单, 但是网上没有一篇文章是好好讲解这个事情的, 而且绝大多数人的使用方法都存在问题, 或者云里雾里, 搞得小白完全不知道该怎么设置\n于是就有了这篇博客, 我来手把手带你安装 CEMU 模拟器\n🥝 下载模拟器直接去 CEMU 模拟器的官方网站下载即可: https://cemu.info/\n点击最下方的按钮下载最新版本, 本博客编写时最新版本为 2.6, 应该不会更新了吧\n🍉 安装模拟器首先解压下载后的压缩包, 得到下图所示的两个文件夹和一个 exe 程序, 此时千万不要启动 ! 不要启动 ! 不要启动 ! 下面称此目录为根目录\n\n⚡ 启动前的准备在启动 exe 之前, 先在根目录中新建一个文本文件, 然后重命名此文件为 settings.xml\n记得在 查看 中开启 文件扩展名\n\n✨ 启动模拟器只要你目前的根目录和上一步图片中的一样, 就可以启动模拟器了\n启动模拟器后, 你的根目录将变成这个样子\n\n🐬 语言设置为中文跟随截图, 打开模拟器设置, 将语言设置为中文, 至此模拟器安装完毕\n\n是不是很简单? 既不需要设置什么游戏目录, 也不需要设置什么 MLC 目录, 也不需要复制粘贴任何文件, 即使是图形包也不需要下载, 总之就是什么都不需要, 哈哈哈\n🍀 下载游戏安装游戏前自然你要先准备好游戏资源, 游戏资源去哪里找呢 ?\n一种就是去各大网站下载, 具体有哪些网站, 自己 google 搜索一下, 一大片\n还有一种用 USBHelperLauncher 这是一个为了方便给 WiiU 主机安装游戏的软件\ngithub 上有人给它做了一个工具, 叫 USBHelperInstaller 可以在 windows 上使用\n至于怎么用这个工具下载游戏, 本教程不负责, 毕竟网上教程太多了, 我就不赘述了\n\n\n👻 游戏目录构成这里需要先讲解一下游戏文件的构成, 游戏资源分为 3 个部分, 分别是本体, 更新包和 DLC, 我这里分别命名为 base, update, dlc, 你可以按照自己的喜好起名\n\n以模拟器可以直接使用的 rpx 格式为例, 每个部分里面都是由 code content meta 三个文件夹组成\n🍒 安装本体上方菜单栏中找到 工具, 打开下拉菜单中的 档案管理器, 在新页面的左下角有一个 安装档案 的按钮, 点击后会提示你选择 meta.xml 文件, 这个文件就在游戏每个部分的 meta 文件夹中\n首先安装本体, 选择你游戏本体的 meta.xml 文件即可, 我这里就是 base&#x2F;meta&#x2F;meta.xml 文件\n\n之后会有一个进度, 这里就是在拷贝你的游戏到 MLC 文件夹中, MLC 文件夹就是模拟器模拟的主机的内部存储\n\n这样游戏本体就安装好了, 但是此时启动游戏你会发现并不能正常游玩游戏, 这是为什么呢 ?\n\n模拟器中会出现上述的画面\n\nゼルダの伝説　ブレス オブ ザ ワイルドは\nソフトの更新をしないと\nゲームを始める事はできません。\nWii Uメニューに戻ります。\n\n大概翻译一下\n\n塞尔达传说 荒野之息\n如果不进行软件更新\n将无法开始游戏\n将返回 WiiU 菜单\n\n这就很清晰了, 意思是我们需要更新游戏, 那么怎么更新游戏呢 ? 就是需要安装更新包部分了\n🍒 安装更新包同样是打开 档案管理器, 点击左下角的 安装档案 的按钮, 不过这次需要选择更新包部分的 meta.xml 文件, 我的就是 update&#x2F;meta&#x2F;meta.xml 文件, 同样等待进度条走完, 这样更新包就安装完成了, 如下图所示\n\n此时我们就可以正常游玩游戏了\n🦄 为什么要新建 settings.xml ?因为 CEMU 模拟器会检测根目录下是否存在 settings.xml 文件, 从而决定是否将文件生成在根目录中, 如果直接启动模拟器, 配置文件会默认生成在用户文件夹中, 一般来说就是你的 C 盘\n🔑 安装 DLC如果游戏有 DLC 部分, 记得还要安装 DLC 哦!\n\n🍸 删除游戏资源当你的游戏内容完全安装完成后, 就可以删除之前准备好的游戏资源了, 因为这些资源都已经被复制到 MLC 文件夹中了 (默认叫 mlc01)\n如果你空间足够, 想做备份, 那无所谓, 一般来说就都可以删掉了\n🌴 为什么不设置游戏目录 ?我个人认为这里是一个很大的坑\n按照我的流程安装游戏, 你会发现你游戏的本体, 更新包, DLC 结构非常清晰, 而且都存在于 MLC 文件夹中, 其中本体的文件夹是 00050000, 更新包的文件夹是 0005000e, DLC 的文件夹是 0005000c\n但是如果你设置了游戏目录, 你会发现你的游戏本体在自己设置的目录中, 但是模拟器并不能自动检测到游戏的更新包和 DLC, 也就是说你同样还是需要走档案安装来安装更新包和 DLC, 这样更新包和 DLC 的文件便会存在于 mlc 文件夹中\n于是你游戏资源的目录便被强行拆开了, 这样会让新手理解起来就会非常困难, 新手按照这个步骤操作将会一脸懵逼, 而且大概率更新包和 DLC 会保留 2 份, 白白浪费磁盘空间\n因此请不要设置游戏目录, 全部走档案安装的方式来安装游戏, 无论是本体还是更新包, DLC\n🍖 为什么不设置 MLC 目录 ?一方面因为 CEMU 模拟器会检测根目录下是否存在 settings.xml 文件, 从而决定是否将文件生成在根目录中, 所以就不再需要单独设置 MLC 文件夹了\n另一方面, 即使你启动模拟器后, 在模拟器中设置新的 MLC 文件夹, 模拟器也只是会迁移 MLC 文件夹而已, 其他的配置文件, 像控制器配置, 游戏配置, 着色器缓存等都不会进行迁移, 因此不选择启动后再设置 MLC 文件夹的方案\n🤠 图形包是什么 ?用过 PPSSPP 高清纹理包的, 或者用过 FC 高清纹理包的人或者会认为这里的图形包就是一些高清的纹理, 能够让游戏更加清晰\n实际上并不是, 这里的图形包概念其实是 插件 或者 模组 的概念\n各种突破原游戏的设置以及功能都是通过这里的 图形包 实现的, 比如超远视距, 240 FPS, 无限耐久, 新皮肤, 4K 分辨率等等, 是不是很神奇 ?\n","categories":["Game"],"tags":["Cemu"]},{"title":"战棋游戏命中率研究","url":"/game/game-true-hit.html","content":"研究一下战棋游戏代表《火焰纹章》中命中率的设定, 学习一下前辈的经验\n\n\n🎄声明下文中 y 代指真实命中, x 代指显示命中\n🌴&quot;1RN&quot; 命中系统查看火焰纹章 WIKI 中对命中率的解释, 这里是原文: WiKi\n在 多拉基亚776 之前的火焰纹章均使用 y &#x3D; x 的设定, 即真实命中就是玩家所看到的显示命中, 称为 &quot;1RN&quot; 命中系统, 下面是曲线图\n\n🍉&quot;2RN&quot; 命中系统&quot;真实命中&quot; 的概念首次出现在 GBA 的 封印之剑 中, 并出现在包括 觉醒 在内的大多数后续游戏中\n在这些游戏中不再只掷一个随机数, 而是掷两个, 通过计算这两个随机数的平均值, 并将平均值与显示的命中率进行比较, 如果平均值小于命中率则攻击命中, 这种方式称为 &quot;2RN&quot; 命中系统, 下面是对比曲线图\n\n\n绿色的是 2RN 命中系统\n紫色的是 1RN 命中系统\n\n可以看出 2RN 系统更加鼓励低命中时闪避, 高命中时击中, 这种情况下闪避高的角色和命中高的角色将会十分强力\n✨混合命中系统某些火焰纹章中采用了一种介于 &quot;1RN&quot; 和 &quot;2RN&quot; 之间的新命中率系统\n当显示命中率低于 50% 时游戏将使用 &quot;1RN&quot; 命中系统, 此时真实命中就是玩家看到的显示命中\n当显示命中率达到或超过 50% 时游戏将掷出一个随机数, 之后使用特定的数学函数进行比较, 下面是对比曲线图\n\n\n红色的是 混合 命中系统\n绿色的是 2RN 命中系统\n紫色的是 1RN 命中系统\n\n可以看出混合命中系统依旧鼓励高命中, 但是不再鼓励玩家利用闪避型的角色去规避伤害, 更鼓励玩家利用高防御角色吸收伤害\n🦄&quot;2RN&quot; 命中系统的命中率表\n\n\n显示命中\n真实命中\n显示命中\n真实命中\n显示命中\n真实命中\n显示命中\n真实命中\n显示命中\n真实命中\n\n\n\n0\n0.00\n20\n8.20\n40\n32.40\n60\n68.40\n80\n92.20\n\n\n1\n0.03\n21\n9.03\n41\n34.03\n61\n69.97\n81\n92.97\n\n\n2\n0.10\n22\n9.90\n42\n35.70\n62\n71.50\n82\n93.70\n\n\n3\n0.21\n23\n10.81\n43\n37.41\n63\n72.99\n83\n94.39\n\n\n4\n0.36\n24\n11.76\n44\n39.16\n64\n74.44\n84\n95.04\n\n\n5\n0.55\n25\n12.75\n45\n40.95\n65\n75.85\n85\n95.65\n\n\n6\n0.78\n26\n13.78\n46\n42.78\n66\n77.22\n86\n96.22\n\n\n7\n1.05\n27\n14.85\n47\n44.65\n67\n78.55\n87\n96.75\n\n\n8\n1.36\n28\n15.96\n48\n46.56\n68\n79.84\n88\n97.24\n\n\n9\n1.71\n29\n17.11\n49\n48.51\n69\n81.09\n89\n97.69\n\n\n10\n2.10\n30\n18.30\n50\n50.50\n70\n82.30\n90\n98.10\n\n\n11\n2.53\n31\n19.53\n51\n52.47\n71\n83.47\n91\n98.47\n\n\n12\n3.00\n32\n20.80\n52\n54.40\n72\n84.60\n92\n98.80\n\n\n13\n3.51\n33\n22.11\n53\n56.29\n73\n85.69\n93\n99.09\n\n\n14\n4.06\n34\n23.46\n54\n58.14\n74\n86.74\n94\n99.34\n\n\n15\n4.65\n35\n24.85\n55\n59.95\n75\n87.75\n95\n99.55\n\n\n16\n5.28\n36\n26.28\n56\n61.72\n76\n88.72\n96\n99.72\n\n\n17\n5.95\n37\n27.75\n57\n63.45\n77\n89.65\n97\n99.85\n\n\n18\n6.66\n38\n29.26\n58\n65.14\n78\n90.54\n98\n99.94\n\n\n19\n7.41\n39\n30.81\n59\n66.79\n79\n91.39\n99\n99.99\n\n\n20\n8.20\n40\n32.40\n60\n68.40\n80\n92.20\n100\n100.00\n\n\n📚参考资料火焰纹章 wiki\nTrue Hit\n火焰纹章中的显示命中与实际命中\n","categories":["Game"],"tags":["Game"]},{"title":"委托(二) 委托与 \"回调和回调函数\"","url":"/csharp/csharp_delegate_02.html","content":"\n\n回调与回调函数我也不太清楚为什么会出来一个 &quot;回调函数&quot; 的概念, 回调函数不就是一个参数吗?\n\n将方法 A 作为 方法 B 的一个参数传入到方法 B 中, 那么方法 A 就是方法 B 的回调函数.\n\n可以这样理解:\n\n&quot;回调&quot; 是一种技术: 将方法作为参数传入另一个方法! 在各大编程语言, 脚本语言中都有实现这门技术!\n\n&quot;回调函数&quot; 就是作为参数的方法!\n\n\n强调: 回调是一项技术! 回调函数是一个参数!\n&quot;回调&quot; 的用途\n因为 A 是作为参数传入 B 的, 那么在 B 中就可以编写很多的判断逻辑来准确控制 A 的执行时机, 当然用 retuan 返回执行标志, 通过执行标志来控制 A 的执行也是可以的, 但是这样不是还得对执行标志进行一次判断吗? 当然这个没什么影响, 但是万一这个执行标志无法返回呢, 对吧?\n\n如果 B 中需要处理很复杂的数据, 而且这个数据很难使用 return 返回, 甚至可能根本无法使用 return, 但是 A 又必须要用到这个数据, 此时就可以利用 &quot;回调&quot; 这项技术了, 将 A 传入 B, 在 B 的内部执行 A, 这样 A 就可以获取到需要的数据了.\n\n假设方法 B 可以随机获得一种食材, 食材有多种多样烹饪方法, 可以红烧, 可以清蒸, 可以煎炸, 此时就可以给 B 添加一个 &quot;回调函数&quot; 参数, 这个参数就是烹饪方法 A, 那么在执行方法 B 获取食材的同时就可以将烹饪方法 A 一并传入, 这样一道菜就直接做好了! 而且只要传入不同的 A 就可以做出不同的菜, 甚至在 B 里面还可以写判断方法, 控制某些食材只能用某些特定的烹饪方法!\n\n\n总结: &quot;回调&quot; 可以做菜~!\n示例csharp 中由于方法无法作为参数进行传递, 所以想要在 csharp 中实现 &quot;回调&quot; 需要使用委托来实现, 下面是一个简单的示例.\nusing System;namespace namespace_CallBackTest&#123;    class CallBackTest    &#123;        // 随机器        public readonly Random random = new Random();        public static void Main()        &#123;            CallBackTest callBackTest = new CallBackTest();            // 获取食材的同时将烹饪方法作为参数传入, 实现内部调用 -- 这就是 &quot;回调&quot; !            // 含义为: 先获取食材, 之后使用参数内的烹饪方式对食材进行处理, 得到烹饪后的食物.            callBackTest.GetIngredients(callBackTest.Cook1);//烧烤            callBackTest.GetIngredients(callBackTest.Cook1);//烧烤            callBackTest.GetIngredients(callBackTest.Cook2);//清蒸            callBackTest.GetIngredients(callBackTest.Cook1);//烧烤            callBackTest.GetIngredients(callBackTest.Cook3);//煎炸            callBackTest.GetIngredients(callBackTest.Cook1);//烧烤            Console.ReadKey();        &#125;        /// &lt;summary&gt;        /// 获取食材        /// &lt;/summary&gt;        /// &lt;param name=&quot;cook&quot;&gt;烹饪方法&lt;/param&gt;        public void GetIngredients(Action&lt;string&gt; cook)        &#123;            string str_ingredient = string.Empty;            int int_ingredient = random.Next(1, 100);            if (int_ingredient &gt; 75)            &#123;                str_ingredient = &quot;大棒肉(&quot; + int_ingredient + &quot;)&quot;;            &#125;            else if(int_ingredient &gt; 25)            &#123;                str_ingredient = &quot;鲈鱼(&quot; + int_ingredient + &quot;)&quot;;            &#125;            else if (int_ingredient == 25)            &#123;                str_ingredient = &quot;杂烩兔肉块(&quot; + int_ingredient + &quot;)&quot;;            &#125;            if (string.IsNullOrEmpty(str_ingredient))            &#123;                Console.WriteLine(&quot;白忙了一天, 没有获得任何食材(&quot; + int_ingredient + &quot;) !&quot;);            &#125;            else            &#123;                cook(str_ingredient);            &#125;        &#125;        /// &lt;summary&gt;        /// 烧烤        /// &lt;/summary&gt;        /// &lt;param name=&quot;ingredient&quot;&gt;&lt;/param&gt;        public void Cook1(string ingredient)        &#123;            Console.WriteLine(&quot;获得了 &lt;烧烤&quot; + ingredient + &quot;&gt; !&quot;);        &#125;        /// &lt;summary&gt;        /// 清蒸        /// &lt;/summary&gt;        /// &lt;param name=&quot;ingredient&quot;&gt;&lt;/param&gt;        public void Cook2(string ingredient)        &#123;            Console.WriteLine(&quot;获得了 &lt;清蒸&quot; + ingredient + &quot;&gt; !&quot;);        &#125;        /// &lt;summary&gt;        /// 煎炸        /// &lt;/summary&gt;        /// &lt;param name=&quot;ingredient&quot;&gt;&lt;/param&gt;        public void Cook3(string ingredient)        &#123;            Console.WriteLine(&quot;获得了 &lt;炸&quot; + ingredient + &quot;&gt; !&quot;);        &#125;    &#125;&#125;\n\n参考链接\n回调函数（callback）是什么？\n\njs的回调函数一般都用来做什么\n\n\n","categories":["CSharp"],"tags":["编程基础"]},{"title":"委托(三) 委托的初始化","url":"/csharp/csharp_delegate_03.html","content":"\n\n初始化委托对象先定义一个委托类型, 然后使用定义的委托类型实例化一个委托对象.\n// 定义一个委托类型public delegate string MyDelegate(int a, int b);// 实例化一个 MyDelegate 类型的委托对象, 此时还没有初始化MyDelegate myDelegate;\n\nMyDelegate myDelegate 只是实例化出了一个空的委托对象, 没有内容, 必须对其初始化. 委托的初始化方式经历了几种变化:\n\nC# 1.0 中, 使用 &quot;在代码中其他位置定义函数&quot; 的方法, 显式初始化委托.\nC# 2.0 引入了 匿名方法 的概念, 以一种可在委托调用中执行的 &quot;未命名内联语句块&quot; 的方式来初始化委托.\nC# 3.0 引入了 Lambda 表达式 或者 Lambda 语句块, 这是另一种匿名方法的书写形式, 但更具表现力并且更简练.\n通常, 面向 .NET Framework 3.5 或更高版本的应用程序应使用 Lambda (λ) 表达式或 Lambda 语句块来初始化委托.\n\n\n第一种: [C# 1.0] 写法上和初始化类一样, 使用 New 关键字.\n\n// 初始化 myDelegate 委托myDelegate = new MyDelegate(program.Add);\n\n\n第二种: [C# 1.0] 写法上和初始化值类型一样, 直接赋值.\n\n// 初始化 myDelegate (直接赋值)myDelegate = program.Add;\n\n\n第三种: [C# 2.0] 使用匿名方法的原始写法进行初始化\n\n匿名方法同样是使用 delegate 关键字定义 (强烈建议不再使用匿名方法, 了解即可, 转而使用 Lambda 表达式或 Lambda 语句块), 返回值无需特别指明, 只需使用 return 来指明返回值及其类型即可, 匿名方法参数的指明方式和普通方法的指明方式一致, 但是必须和委托定义时声明的方法签名吻合.\nmyDelegate = delegate (int a, int b)&#123;    return (a + b).ToString();&#125;;\n\n\n第四种: [C# 3.0] 使用匿名方法的简化写法--Lambda 表达式或 Lambda 语句块进行初始化 (强烈建议使用!)\n\nLambda 表达式和 Lambda 语句块也是委托初始化的一种手段, 它比匿名方法更为简洁, 而且不会混淆 (谁让委托类型的定义和匿名方法的定义使用同样的关键字的, 唉... 乱套了吧... 我瞎说的~~), 总之正如微软文档说的一样, 学习使用 lambda 表达式吧, 为什么呢? 因为如果你不会的话, 连别人的程序都看不懂啊😥\nLambda\nLambda 的特征符号是: =&gt;. &#x3D;&gt; 符号的左边是参数, 使用小括号 ( ) 括起来, 右侧是语句或表达式, 当右侧是语句时, 必须使用大括号 { } 括起来, 当右侧是表达式时, 则不能带有大括号, 且表达式只能有一句.\n\nLambda 中右侧是语句时, 使用 return 语句来指明返回值及其类型, 返回值的类型必须符合委托的要求.\n Func&lt;int, int, int&gt; funA = (int x, int y) =&gt; &#123; return x + y; &#125;;\n\nLambda 中参数的类型可以注明, 如上面的例子, 也可以省略, 如下面的例子.\n Func&lt;int, int, int&gt; funB = (x, y) =&gt; &#123; return x * y; &#125;;\n\nLambda 中的参数, 当且仅当只有一个时, 小括号可以省略.\n Func&lt;int, int&gt; funC = x =&gt; &#123; return x * 2; &#125;; // 当且仅当只有一个时, 小括号可以省略.Func&lt;float&gt; funD = () =&gt; &#123; return 3.1415926f; &#125;; // 零个参数时, 小括号不可以省略.Func&lt;int, int, int, int&gt; funE = (x, y, z) =&gt; &#123; return x * 2 + y * 3 + z * 4; &#125;; // 两个及以上参数时, 小括号不可以省略.\n\nLambda 中右侧是表达式时, 大括号必须去掉, 并且此时 return 也必须省略, 因为 return 是语句, 不是表达式.\n Func&lt;int, int, int&gt; funF = (x, y) =&gt; x * y; // 大括号和 return 必须同时存在, 或同时去掉.\n\n大括号存在时, 大括号中只能写 语句. 此时称为: Lambda 语句块. 或者说当书写语句时, 必须用 语句块符号 { } 括起来.\n\n大括号不存在时, 则只能写 表达式, 并且 表达式只能写一句 . 此时称为: Lambda 表达式.\n myDelegate = (a, b) =&gt;&#123;    return (a + b).ToString();&#125;; // Lambda 语句块Action action = () =&gt; Console.WriteLine(&quot;action&quot;); // Lambda 表达式\n\n多播委托前面讲了委托的四种初始化方式全部都是使用了 = 运算符, 其实委托还可以通过 += -= 运算符进行注册和取消注册, 而且可以实现多播委托.\n\n多播委托: 一个委托实例一次性委托多个实例方法, 调用委托时会依次调用所有被委托的方法.\n\n委托不仅仅可以 (取消) 注册方法, 也可以 (取消) 注册委托!\n\n\n下表是 + 和 - 的运算规则:\n\n\n\nExpression\nResult\n\n\n\nnull + d1\nd1\n\n\nd1 + null\nd1\n\n\nd1 + d2\n[d1, d2]\n\n\nd1 + [d2, d3]\n[d1, d2, d3]\n\n\n[d1, d2] + [d2, d3]\n[d1, d2, d2, d3]\n\n\n[d1, d2] - d1\nd2\n\n\n[d1, d2] - d2\nd1\n\n\n[d1, d2, d1] - d1\n[d1, d2]\n\n\n[d1, d2, d3] - [d1, d2]\nd3\n\n\n[d1, d2, d3] - [d2, d1]\n[d1, d2, d3]\n\n\n[d1, d2, d3, d1, d2] - [d1, d2]\n[d1, d2, d3]\n\n\n[d1, d2] - [d1, d2]\nnull\n\n\n","categories":["CSharp"],"tags":["编程基础"]},{"title":"CSharp 中 Thread 和 Foreach","url":"/csharp/csharp_foreach.html","content":"\n\n🌴前言最近一个项目中需要用到多线程, 而在研究多线程的过程中发现了 foreach 的一个特性.\n❓问题网上有一种说法, 如下代码会出现一个问题, 导致最后输出的结果为: 五个 555 字符串.\n理由和之前说过的 &quot;闭包和委托&quot; 结合容易引起的问题一样, 下面是一个博主的解释:\n\n由于被置于 ThreadPool 中的操作时异步的, 还没有来的及执行的时候, inFor 变量已经被循环改变, 等到 ThreadPool 执行的时候, inFor 已经是最后一个值了, 也就是 555, 所以最终的结果是输出了五次 555.\n\npublic static void MultiTest()&#123;    var list = new List&lt;int&gt; &#123;111, 222, 333, 444, 555&#125;;        foreach (var inFor in list)    &#123;        System.Threading.ThreadPool.QueueUserWorkItem(state =&gt;        &#123;            DebugUtil.Log($&quot;&lt;color=&#x27;red&#x27;&gt;&#123;inFor&#125;&lt;/color&gt;&quot;);        &#125;);    &#125;&#125;\n\n✨结论而实际经过实验之后发现, 目前 C# 和 Unity 中都不会再出现这种问题, 下面是我实验的代码:\npublic static void MultiTest()&#123;    var list = new List&lt;int&gt; &#123;111, 222, 333, 444, 555&#125;;        // 不使用外部变量    foreach (var inFor in list)    &#123;        System.Threading.ThreadPool.QueueUserWorkItem(state =&gt;        &#123;            DebugUtil.Log($&quot;&lt;color=&#x27;red&#x27;&gt;&#123;inFor&#125;&lt;/color&gt;&quot;);        &#125;);    &#125;        Thread.Sleep(10);        // 使用外部变量    int outFor;    foreach (var inFor in list)    &#123;        outFor = inFor;        System.Threading.ThreadPool.QueueUserWorkItem(state =&gt;        &#123;            DebugUtil.Log($&quot;&lt;color=&#x27;yellow&#x27;&gt;&#123;outFor&#125;&lt;/color&gt;&quot;);        &#125;);    &#125;&#125;\n\n最终得到的结果是:\n\n可以看到, 当仅使用 foreach 时得到的结果是完全正确的, 只有当使用一个外部变量的时候才会出现闭包机制引发的 Bug, 因此可得出表现上的结论:\nforeach 中的临时变量从表现上来看可以认作每次循环后都是一个新的变量.\n","categories":["CSharp"],"tags":["编程基础"]},{"title":"委托(一) 委托的基本用法","url":"/csharp/csharp_delegate_01.html","content":"\n\n本文重点\ndelegate 和 Delegate 的区别\n\n定义委托\n\n实例化委托\n\nAction 和 Func\n\n委托的基本用法\n\n\ndelegatedelegate 是一个类型关键字, 和它类似的还有: class, interface, enum 等等. 这类关键字都是用来定义的, 而不是实例化的. 枚举类型使用 enum 进行定义, 委托类型使用 delegate 进行定义. 因此 delegate 不是类! 它只是一个类型关键字! 用来定义类型的.\nSystem.String - string 和 System.Delegate - delegateSystem.String 是 .Net 框架中的一个类, .Net 框架中包含多种编程语言, 其中 C# 语言中给 System.String 起了一个别名 string, 因此 string str 和 System.String str 是没有区别的, string 就是一个类, string str 这一个代码不是在定义类型, 而是在实例化对象. 但是 delegate 和 System.Delegate 的关系就不是这样了. System.Delegate 是一个类, 而 delegate 则是一个 类型关键字, 它是用来定义委托的, 就像 class 定义类, struct 定义结构体, enum 定义枚举一样, 这些关键字是同一个级次的, 但他们都不是类.\n如下图, String, string, Delegate 都可以调用类中的静态方法, 这是因为他们都是类, 但是 delegate 则不可以, 因为它仅仅只是一个类型关键字.\n\n🦄如何定义一个委托类型\n使用 delegate 关键字\n指明待委托方法的两个特征: 1. 返回值 2. 参数\n\n//定义委托类型, 返回值为: int, 参数为: (int, int)public delegate int MyDelegate (int a, int b);\n\n[注] 其实 csharp 中已经有定义好的通用委托类型了, 基本无需自己定义委托类型.\n🐬如何实例化出一个委托实例实例化委托就是使用之前定义好的委托类型实例化出一个委托对象, 也叫做委托实例. 委托的实例化语法和类的实例化语法相同.\n// 实例化一个 MyDelegate 类型的委托对象, 此时还没有初始化MyDelegate myDelegate;\n\n[注] 实例化委托时通常不再使用自己定义的委托类型, 而是使用 csharp 中已经定义好的通用委托类型 Action&lt;&gt; 和 Func&lt;&gt;.\n🌴如何初始化一个委托实例\n方法 1: 使用 new 关键字初始化. 待委托方法作为参数传入.\n\n方法 2: 直接使用符合特征的方法赋值.\n\n\n[注] 待委托方法如果不是静态方法, 则必须是实例方法. 不能将未实例化的方法作为参数传入委托或对委托赋值.\n如何调用委托\n方式 1: 调用委托和调用方法在代码写法上一致.\n方式 2: 调用 Invoke() 方法.\n\n委托基本用法示例 (非静态)using System;using System.Collections.Generic;// CSharp 起别名的语法规则, 在 namespace 外部书写时必须写全部路径// using Package = System.Collections.Generic.Dictionary&lt;string, int&gt;;namespace MyDelegateTest&#123;    // CSharp 起别名的语法规则, 在 namespace 内部书写的时候可以嵌套引用 namespace 外的 using    using Package = Dictionary&lt;string, int&gt;;    // 定义一个委托类, 指明待委托方法的特征: 1. 返回值 (string) 2. 参数 (string, int, Package)    public delegate string DelegateBuy(string itemName, int num, Package package);    class Program    &#123;        public static void Main()        &#123;            // 实例化 玩家包裹            Package package = new Package();            // 实例化 委托            // 委托初始化时可以直接赋值, 也可以使用 new 关键字            // 当 &quot;待委托方法&quot; 是非静态方法时, 只能传递待委托方法的实例作为参数, 因此这里必须实例化 Program, 并写 &quot;program.Buy&quot;, 不能只写 &quot;Buy&quot;.            Program program = new Program();            DelegateBuy delegateBuy = program.Buy;            DelegateBuy delegateBuy2 = new DelegateBuy(program.Buy);            // 调用委托的写法和调用方法的写法一致            Console.WriteLine(delegateBuy(&quot;体力药水&quot;, 10, package));            Console.WriteLine(delegateBuy(&quot;体力药水&quot;, 25, package));            Console.WriteLine(delegateBuy2(&quot;魔力药水&quot;, 10, package));            Console.WriteLine(delegateBuy2(&quot;魔力药水&quot;, 5, package));            // 暂停            Console.ReadKey();        &#125;        /// &lt;summary&gt;        /// 待委托的方法        /// &lt;/summary&gt;        /// &lt;param name=&quot;itemName&quot;&gt;物品名称&lt;/param&gt;        /// &lt;param name=&quot;num&quot;&gt;物品数量&lt;/param&gt;        /// &lt;param name=&quot;package&quot;&gt;玩家包裹&lt;/param&gt;        public string Buy(string itemName, int num, Dictionary&lt;string, int&gt; package)        &#123;            string str;            if (package.ContainsKey(itemName))            &#123;                package[itemName] += num;                str = string.Format(&quot;您又购买了&#123;0&#125;个&#123;1&#125;!&quot;, num, itemName);            &#125;            else            &#123;                package.Add(itemName, num);                str = string.Format(&quot;您购买了&#123;0&#125;个&#123;1&#125;!&quot;, num, itemName);            &#125;            return str;        &#125;    &#125;&#125;\n\n委托基本用法示例 (静态)using System;using System.Collections.Generic;// CSharp 起别名的语法规则, 在 namespace 外部书写时必须写全部路径// using Package = System.Collections.Generic.Dictionary&lt;string, int&gt;;namespace MyDelegateTest&#123;    // CSharp 起别名的语法规则, 在 namespace 内部书写的时候可以嵌套引用 namespace 外的 using    using Package = Dictionary&lt;string, int&gt;;    // 定义一个委托类, 指明待委托方法的特征: 1. 返回值 (string) 2. 参数 (string, int, Package)    public delegate string DelegateBuy(string itemName, int num, Package package);    class Program    &#123;        public static void Main()        &#123;            // 实例化 玩家包裹            Package package = new Package();            // 实例化 委托            // 当 &quot;待委托方法&quot; 是静态方法时, 可以直接将静态方法作为参数传递.            DelegateBuy delegateBuy = Program.Buy;            DelegateBuy delegateBuy2 = new DelegateBuy(Program.Buy);            // 调用委托的写法和调用方法的写法一致            Console.WriteLine(delegateBuy(&quot;体力药水&quot;, 10, package));            Console.WriteLine(delegateBuy(&quot;体力药水&quot;, 25, package));            Console.WriteLine(delegateBuy2(&quot;魔力药水&quot;, 10, package));            Console.WriteLine(delegateBuy2(&quot;魔力药水&quot;, 5, package));            // 暂停            Console.ReadKey();        &#125;        /// &lt;summary&gt;        /// 待委托的方法        /// &lt;/summary&gt;        /// &lt;param name=&quot;itemName&quot;&gt;物品名称&lt;/param&gt;        /// &lt;param name=&quot;num&quot;&gt;物品数量&lt;/param&gt;        /// &lt;param name=&quot;package&quot;&gt;玩家包裹&lt;/param&gt;        public static string Buy(string itemName, int num, Dictionary&lt;string, int&gt; package)        &#123;            string str;            if (package.ContainsKey(itemName))            &#123;                package[itemName] += num;                str = string.Format(&quot;您又购买了&#123;0&#125;个&#123;1&#125;!&quot;, num, itemName);            &#125;            else            &#123;                package.Add(itemName, num);                str = string.Format(&quot;您购买了&#123;0&#125;个&#123;1&#125;!&quot;, num, itemName);            &#125;            return str;        &#125;    &#125;&#125;\n\nAction 和 Func在实例化委托的时候, 不仅仅可以使用自己定义的委托, 还可以使用 csharp 中已经定义好的两个泛型委托: Action&lt;&gt; 和 Func&lt;&gt; 来实例化 (强烈建议使用).\nActionAction&lt;&gt; 待委托的方法都是没有返回值的方法, 参数使用泛型进行指定.\nAction a; // 实例化出一个待委托方法特征为没有返回值, 没有参数的委托实例 aAction&lt;string&gt; b; // 实例化出一个待委托方法特征为没有返回值, 有一个 string 类型参数的委托实例 bAction&lt;string, int[]&gt; c; // 实例化出一个待委托方法特征为没有返回值, 具有一个 string, 一个 int 数组参数的委托实例 c\n\nFuncFunc&lt;&gt; 待委托的方法都是具有返回值的方法. 使用泛型来指定参数和返回值. 其中泛型中的最后一个类型为返回值的类型.\nFunc&lt;string&gt; a; // 实例化出一个待委托方法特征为没有参数, 返回值类型为 string 的委托实例 aFunc&lt;string, int&gt; b; // 实例化出一个待委托方法特征为有一个 string 类型的参数, 返回值为 int 类型的委托实例 bFunc&lt;int, string, int[]&gt; c; // 实例化出一个待委托方法特征为有两个 类型分别为 int 和 string 类型的参数, 返回值为 int 数组类型的委托实例 c\n\n总结\ndelegate 和 Delegate 的区别:\n Delegate 是类, delegate 是关键字.\n\n定义委托\n 不再自定义委托, 使用 Action&lt;&gt; 和 Func&lt;&gt;.\n\n实例化委托\n 使用泛型指明待委托方法的特征.\n\nAction 和 Func\n Action&lt;&gt; 指明无返回值, Func&lt;&gt; 最后一个泛型类型指明返回值.\n\n委托的基本用法\n 可以通过委托来调用方法.\n\n\n参考链接理解委托类型\n","categories":["CSharp"],"tags":["编程基础"]},{"title":"委托(四) \"委托与事件的区别\" 以及 \"观察者模式\"","url":"/csharp/csharp_delegate_04.html","content":"\n\n🌴前言最开始知道委托和事件是在 SiKi 的 C# 课程上(很抱歉, 大学就只上了 C 语言课, Java 课听了一节...😅), 由于之前没有接触过类似的语法, 又或是学习单片机的时候 C 语言语法在脑海中根深蒂固了 , 听课时就像是在听天书, 再加上之后也没有使用过这方面的语法, 基本全忘记了. 之前一段时间简单的了解了一下委托和事件, 然后网上都是用 &quot;观察者模式&quot; 去讲的...然而文章中连观察者都没有仔细去讲...所以这样更晕了好嘛...😑 于是自己抽时间多看了几篇文章, 做一下总结. 先说一下观察者模式吧, 毕竟委托和事件的区别用观察者去讲真的十分合适!\n🍁声明阅读下文需要对 &quot;委托&quot; 有基本了解, 如果未达到此基本要求, 请先打怪升级, 达到要求后再来挑战本副本! 推荐练级副本:\n\n委托(一) 委托的基本用法\n\n委托(二) 委托与回调和回调函数\n\n委托(三) 委托的初始化\n\n\n👀观察者模式&quot;模式&quot; 是什么?\n&quot;模式&quot; 这个东西和之前所学的大部分东西都不是一回事, &quot;模式&quot; 是一种套路, 对, 你没有听错, 套路, 或者说模板! 它是走在我们前面的那些码神们常年编写代码所总结出来的一种在特定场合下特别好用的代码模板. 就像是英语作文模板指导我们以怎样的结构去写英语作文一样, &quot;模式&quot; 是指导我们以一种怎样的结构去编写代码, 以达到减小编程时工作量以及减小日后维护成本的效果.\n\n观察者模式的内容是什么?\n需要描述的是一种 &quot;一对多&quot; 的依赖关系!\n\n当 &quot;一&quot; 的一方状态发生改变时, &quot;多&quot; 的一方中的全部成员都能够收到通知!\n\n&quot;多&quot; 的一方收到通知后, 全部的成员都会自动进行更新操作, 而非被动!\n\n\n这就是 &quot;观察者模式&quot; 了, &quot;一&quot; 的一方叫做 &quot;被观察者&quot;, &quot;多&quot; 的一方叫做 &quot;观察者&quot;, 也叫做: &quot;发布-订阅模型&quot;, 这时分别叫做 &quot;发布器&quot; 和 &quot;订阅器&quot;.\n\nQ: 为什么没有代码?\nA: 因为模式只是一种套路, 一种模板, 一种思想, 自然是没有代码的! 只要代码是按照这个模板去编写的, 就可以说使用了 &quot;观察者模式&quot;.\n\n观察者模式的代码实现接下来就是代码实现环节了, 一共写了 3 种 链表, 委托, 事件 代码实现, 都是使用的 csharp 语言.\nQ: 需要记忆的代码是哪个呢?\nA: 没有! 对, 就是没有! 真正要记忆的是前面 观察者模式的内容是什么 中所提到的 3 点. 看完代码后可不要本末倒置了哦!\n下面代码实现的场景就是当被观察者使用 &quot;发令枪&quot; 开枪时, 观察者们全部开跑~\n链表实现using System;using System.Collections.Generic;namespace Exercise&#123;    /// &lt;summary&gt;    /// 被观察者    /// &lt;/summary&gt;    public class Publisher_List    &#123;        // 保存所有的观察者对象        private readonly List&lt;Subscriber_List&gt; subscriberList = new List&lt;Subscriber_List&gt;();        // 进入赛道        public void EnterGame(Subscriber_List subscriber)        &#123;            subscriberList.Add(subscriber);        &#125;        // 发令枪        public void StartingGun()        &#123;            Console.WriteLine(&quot;预备~ . . . 砰! \\n&quot;);            // 遍历所有的观察者 (这一步就是在通知每一个观察者)            foreach (Subscriber_List t in subscriberList)            &#123;                t.Run(); // 自动更新            &#125;        &#125;    &#125;    /// &lt;summary&gt;    /// 观察者    /// &lt;/summary&gt;    public class Subscriber_List    &#123;        // 运动员姓名        private readonly string name;        // 初始化        public Subscriber_List(Publisher_List publisher, string name)        &#123;            this.name = name;            publisher.EnterGame(this);        &#125;        // 开跑        public void Run()        &#123;            Console.WriteLine(name + &quot; 开跑啦~ \\n&quot;);        &#125;    &#125;    public static class Program_List    &#123;        public static void Main()        &#123;            Publisher_List publisherList = new Publisher_List();            new Subscriber_List(publisherList, &quot;艾莉&quot;);            new Subscriber_List(publisherList, &quot;克里斯&quot;);            publisherList.StartingGun();            Console.ReadKey();        &#125;    &#125;&#125;\n\n// 程序输出:预备~ . . . 砰!艾莉 开跑啦~克里斯 开跑啦~\n\n上面就是一个最简单的观察者模式, 使用链表实现.\n\n\n\n特性\n实现方式\n\n\n\n1. 一对多\n被观察者只有一个实例, 使用链表保存所有的观察者实例\n\n\n2. 全部通知\n在方法中遍历所有的观察者, 每一个都进行特定的操作\n\n\n3. 自动更新\n在 &quot;被观察者&quot; 中调用 &quot;观察者&quot; 的方法, 对外界隐藏调用逻辑\n\n\n再来看一下 Main 方法:\npublic static void Main()&#123;    Publisher_List publisherList = new Publisher_List();    new Subscriber_List(publisherList, &quot;艾莉&quot;);    new Subscriber_List(publisherList, &quot;克里斯&quot;);    publisherList.StartingGun();    Console.ReadKey();&#125;\n\n此时对外界的 Main 方法而言, 我仅仅开了一下 &quot;发令枪&quot;, 艾莉和克里斯中的 Run 方法就 自动 被调用了. 如果不这么写, Main 方法就必须先调用发令枪方法, 然后再调用艾莉和克里斯的 Run 方法.\n委托实现using System;namespace Exercise&#123;    public static class Program    &#123;        public static void Main()        &#123;            Publisher publisher = new Publisher();            new Subscriber(publisher, &quot;艾莉&quot;);            new Subscriber(publisher, &quot;克里斯&quot;);            // 发令枪            publisher.StartingGun();            Console.ReadKey();        &#125;    &#125;    /// &lt;summary&gt;    /// 被观察者    /// &lt;/summary&gt;    public class Publisher    &#123;        // 委托, 保存所有的观察者        public Action PublisherDelegate;        // 发令枪        public void StartingGun()        &#123;            Console.WriteLine(&quot;预备~ . . . 砰! \\n&quot;);            PublisherDelegate?.Invoke(); // 判断 PublisherDelegate 是否是空, 如果不是空, 则调用里面的 Invoke 方法.        &#125;    &#125;    /// &lt;summary&gt;    /// 观察者    /// &lt;/summary&gt;    public class Subscriber    &#123;        // 运动员姓名        private readonly string name;        /// &lt;summary&gt;        /// 构造器        /// &lt;/summary&gt;        /// &lt;param name=&quot;publisher&quot;&gt;发布器&lt;/param&gt;        /// &lt;param name=&quot;name&quot;&gt;订阅器名称&lt;/param&gt;        public Subscriber(Publisher publisher, string name)        &#123;            this.name = name;            publisher.PublisherDelegate += Run; // 自动注册        &#125;        // 开跑        public void Run()        &#123;            Console.WriteLine(name + &quot; 开跑啦~ \\n&quot;);        &#125;    &#125;&#125;\n\n// 程序输出:预备~ . . . 砰!艾莉 开跑啦~克里斯 开跑啦~\n\n使用委托实现观察者模式与使用链表时的不同\n不再使用链表保存所有的观察者, 而是使用委托的多播特性进行保存.\n\n通知所有观察者的步骤不再使用遍历, 而是使用委托的多播特性进行逐个通知.\n\n注册观察者时不再使用链表的 Add() 方法, 而是使用委托的 +&#x3D; 和 -&#x3D;.\n\n\n直接使用委托实现观察者模式有几个不安要素:\n\n如果被观察者 Publisher 中的委托是 public 修饰, 那么外部便可以直接访问, 此时如果外部代码中使用了 &#x3D; 进行委托的注册, 那么委托中已有的注册将被全部清空, 这种隐患是十分恐怖的.\n\n如果被观察者 Publisher 中的委托是 public 修饰, 那么外部便可以直接调用此委托, 此时观察者们便无法收到任何通知, 这个隐患同样是致命的.\n\n\n使用事件实现观察者模式便解决了上面两个致命隐患.\n事件实现using System;namespace Exercise&#123;    public static class Program    &#123;        public static void Main()        &#123;            Publisher publisher = new Publisher();            Subscriber subscriberA = new Subscriber(publisher, &quot;艾莉&quot;);            Subscriber subscriberB = new Subscriber(publisher, &quot;克里斯&quot;);            // 发令枪            publisher.StartingGun();            Console.ReadKey();            // 对事件直接赋值 (不允许)            publisher.PublisherEvent = subscriberA.Run;            // 对委托直接赋值 (允许)            publisher.PublisherDelegate = subscriberA.Run;            // 外部直接调用事件 (不允许)            publisher.PublisherEvent();            // 外部直接调用委托 (允许)            publisher.PublisherDelegate();            Console.ReadKey();        &#125;    &#125;    /// &lt;summary&gt;    /// 被观察者    /// &lt;/summary&gt;    public class Publisher    &#123;        // 事件, 保存所有的观察者        public event Action PublisherEvent;        public Action PublisherDelegate;        // 发令枪        public void StartingGun()        &#123;            Console.WriteLine(&quot;预备~ . . . 砰! \\n&quot;);            PublisherEvent?.Invoke(); // 判断 PublisherEvent 是否是空, 如果不是空, 则调用里面的 Invoke 方法.        &#125;    &#125;    /// &lt;summary&gt;    /// 观察者    /// &lt;/summary&gt;    public class Subscriber    &#123;        // 运动员姓名        private readonly string name;        /// &lt;summary&gt;        /// 构造器        /// &lt;/summary&gt;        /// &lt;param name=&quot;publisher&quot;&gt;发布器&lt;/param&gt;        /// &lt;param name=&quot;name&quot;&gt;订阅器名称&lt;/param&gt;        public Subscriber(Publisher publisher, string name)        &#123;            this.name = name;            publisher.PublisherEvent += Run; // 自动注册            publisher.PublisherEvent = Run;        &#125;        // 开跑        public void Run()        &#123;            Console.WriteLine(name + &quot; 开跑啦~ \\n&quot;);        &#125;    &#125;&#125;\n\n上面的代码直接粘贴到 VS 中其实是报错的, 其中第 18 行, 第 23 行以及第 65 行会报错! 报错信息是一样的:\nCS0070  事件 &quot;Publisher.PublisherEvent&quot; 只能出现在 += 或 -= 的左边(从类型 &quot;Publisher&quot; 中使用时除外)\n从这里也就可以得出结论, 委托和事件的不同.\n🍀委托和事件的异同\n一个使用 public 修饰的委托实例, 在声明类的外部可以直接调用. 而事件即使修饰为 public, 也仅能在声明类内部调用, 外部调用时编译器会直接报错, 发现隐患.\n\n委托可以使用 &#x3D; 进行赋值, 但是事件不可以, 无论任何时候, 事件都仅能使用 +&#x3D; 和 -&#x3D; 进行注册, 使用 &#x3D; 时编译器会直接报错, 发现隐患.\n\n除此以外, 委托和事件一致.\n\n\n🌈参考链接\n菜鸟教程 - 观察者模式\n\nGraphic Design Patterns - 观察者模式\n\nC# 委托与事件区别简单总结\n\n\n","categories":["CSharp"],"tags":["编程基础"]},{"title":"存储类型和传递方式","url":"/csharp/csharp_parameter.html","content":"\n\n变量的存储类型csharp 中的存储类型有两种, &quot;值存储&quot; 和 &quot;引用存储&quot;.\n\n引用存储类型是指在堆中存储变量的实际内容, 在栈中存储指向堆中实际内容的指针. 引用储存类型由这两部分组成.\n\n值存储类型则是直接存储变量的实际内容, 不保存指向其的指针, 具体存储位置根据值类型的创建位置而定: 如果值类型是在一个方法中创建的, 那么它将跟随方法被压入栈内存中, 如果值类型是在一个引用类型内部创建的, 那么它将跟随这个引用类型存储在堆内存中.\n\n\n参数的传递方式csharp 中的传递方式有两种, &quot;值传递&quot; 和 &quot;引用传递&quot;.\n\n引用传递就是指将变量本身直接作为参数传递到方法内部. 比如你买了一支冰激凌, 朋友是只馋猫, 于是你直接把冰激凌送给了她, 她吃完后, 你也就没有冰激凌了...\n\n值传递就是指将变量复制一份, 然后将复制出来的副本传递到方法内部. 就像朋友也想吃的时候, 你去便利店又买了一支一模一样的冰激凌送给了她, 她吃完后, 你的冰激凌还是在自己手中的...自己的是自己的, 她的是她的.\n\n\n在默认情况下, CLR方法中传递参数的方式都是值传递! 即使变量采用的是引用存储.\n四种 &quot;存储--传递&quot;2 种存储类型在 2 种传递方式下就会诞生 4 种情况:\n值存储--值传递将一个值存储变量按照默认的传递方式传递就构成了 &quot;值存储--值传递&quot; 的情况.\nusing System;class Program&#123;    static void Main()    &#123;        Program program = new Program();        int param1 = 1;        int param2 = 2;        program.Edit(param1, param2);        Console.WriteLine(&quot;param1=&#123;0&#125;, param2=&#123;1&#125;&quot;, param1, param2);        Console.ReadKey();    &#125;    private void Edit(int param1, int param2)    &#123;        param1 = 3;        param2 = 4;    &#125;&#125;\n\n在上面的例子中, 最终输出的还是:\nparam1=1, param2=2\n\n引用存储--值传递将一个引用存储的变量使用默认的传递方式传递就构成了 &quot;引用存储--值传递&quot; 的情况.\nusing System;class Program&#123;    static void Main()    &#123;        Program program = new Program();        string str = &quot;我是测试字符串!&quot;;        program.Edit(str);        Console.WriteLine(&quot;str=&#123;0&#125;&quot;, str);        Console.ReadKey();    &#125;    private void Edit(string str)    &#123;        str = &quot;我被修改了!&quot;;    &#125;&#125;\n\n在上面的例子中, 最终输出的还是:\nstr=我是测试字符串!\n\nusing System;class Program&#123;    static void Main()    &#123;        Program program = new Program();        Car car = new Car(1000, &quot;价值一千元的车&quot;);        program.Edit(car);        Console.WriteLine(&quot;price=&#123;0&#125;, name=&#123;1&#125;&quot;, car.price, car.name);        Console.ReadKey();    &#125;    private void Edit(Car param)    &#123;        param = new Car(10000, &quot;价值一万元的车&quot;);    &#125;&#125;class Car&#123;    public int price;    public string name;    public Car(int param1, string param2)    &#123;        price = param1;        name = param2;    &#125;&#125;\n\n在上面的例子中, 最终输出的还是:\nprice=1000, name=价值一千元的车\n\n第一个例子中 param1 的值是 1, param2 的值是 2, 即使使用了 Edit() 方法进行修改, 这两个变量的值依旧没有变化; 第二个例子中, str 的值也没有发生改变; 第三个例子中, car 指向的是 &quot;价值为一千元的车&quot;, 之后使用了 Edit() 方法进行了修改, 但是 car 指向的还是那辆 &quot;价值为一千元的车&quot;, 对一万元的车视而不见! 由此可见, 值传递之后, 方法中修改的只是变量的副本, 并不会对原变量的值造成任何影响.\n[注] 第二个例子中的 car 变量的值和 car 所指向的 price 变量的值, name 变量的值完全是两码事!\n值存储--引用传递之前提到过, 在默认情况下, CLR方法中传递参数的方式都是值传递! 即使变量采用的是引用存储! csharp 既然提供了引用传递方式, 自然有其实现方式. ref, in, out 这三个修饰符就是用于修饰参数的, 3 个修饰符的差异先放一边, 只要知道被它们修饰后的参数将使用 &quot;引用传递&quot; 的方式进行传递就可以了.\n当值存储的变量作为参数传递时, 被 ref, out, in 修饰符修饰, 会使用引用传递方式进行传递, 就构成了 &quot;值存储--引用传递&quot; 的情况.\nusing System;class Program&#123;    static void Main()    &#123;        Program program = new Program();        int param1 = 1;        int param2 = 2;        program.Edit(ref param1, ref param2);        Console.WriteLine(&quot;param1=&#123;0&#125;, param2=&#123;1&#125;&quot;, param1, param2);        Console.ReadKey();    &#125;    private void Edit(ref int param1, ref int param2)    &#123;        param1 = 3;        param2 = 4;    &#125;&#125;\n\n在上面的例子中, 最终输出的值就变成了:\nparam1=3, param2=4\n\n引用存储--引用传递当引用存储的变量作为参数传递时, 被 ref, out, in 修饰符修饰, 也会使用引用传递方式进行传递, 就构成了 &quot;引用存储--引用传递&quot; 的情况.\nusing System;class Program&#123;    static void Main()    &#123;        Program program = new Program();        string str = &quot;我是测试字符串!&quot;;        program.Edit(ref str);        Console.WriteLine(&quot;str=&#123;0&#125;&quot;, str);        Console.ReadKey();    &#125;    private void Edit(ref string str)    &#123;        str = &quot;我被修改了!&quot;;    &#125;&#125;\n\n在上面的例子中, 最终输出的值就变成了:\nstr=我被修改了!\n\nusing System;class Program&#123;    static void Main()    &#123;        Program program = new Program();        Car car = new Car(1000, &quot;价值一千元的车&quot;);        program.Edit(ref car);        Console.WriteLine(&quot;price=&#123;0&#125;, name=&#123;1&#125;&quot;, car.price, car.name);        Console.ReadKey();    &#125;    private void Edit(ref Car param)    &#123;        param = new Car(10000, &quot;价值一万元的车&quot;);    &#125;&#125;class Car&#123;    public int price;    public string name;    public Car(int param1, string param2)    &#123;        price = param1;        name = param2;    &#125;&#125;\n\n在上面的例子中, 最终输出的值就变成了:\nprice=10000, name=价值一万元的车\n\n第一个例子中 param1 的值是 1, param2 的值是 2, 使用了 Edit() 方法修改后, 这两个变量的值就变成了 3 和 4; 第二个例子中, str 的值也被修改为了 &quot;我被修改了!&quot;; 第三个例子中, car 原本指向的是 &quot;价值为一千元的车&quot;, 之后使用了 Edit() 方法进行了修改, car 便指向了 &quot;价值为一万元的车&quot; ! 由此可见, 引用传递之后, 方法中修改的就是原变量的值.\nref, out, in这三个关键字都可以实现引用传递, 并且引用传递时, ref 和 out 还要求不仅需要在方法签名中声明参数为哪种引用传递, 在调用方法的时候也必须添加对应的修饰符, 从上面引用传递的举例中也可以看出, 在调用方法时, 参数中也必须注明 ref 和 out, 但是这三者有什么区别呢?\n什么时候用 ref ?当你的目的是使用方法处理变量的值的时候, 就可以使用 ref 修饰符了. 因此 ref 有一个这样的语法规则:\n\nref 修饰的参数在传递前必须已经初始化了.\n\n很明显, 这条规则进一步强调了 ref 的运用场景是: 我已经有一吨苹果了, 我现在需要将苹果送入造酒工厂, 让造酒工厂帮我处理这么多苹果! 所以前提是我们必须得先有苹果啊! 😅\n什么时候用 out ?当你的目的是使用方法造出一个东西的时候, 就可以使用 out 修饰符了. 因此 out 修饰符就没有必须先初始化的限制. 这也是其使用场景决定的: 比如现在造酒工厂已经把苹果酒制作好了, 那么我只需要将酒带回家就可以了, 并不需要提前准备什么.\nusing System;class Program&#123;    static void Main()    &#123;        Program program = new Program();        program.Cook(out string food);        Console.WriteLine(&quot;food=&#123;0&#125;&quot;, food);        Console.ReadKey();    &#125;    private void Cook(out string food)    &#123;        food = &quot;早餐&quot;;    &#125;&#125;\n\n比如上面的例子, Cook() 方法中的 food 变量并没有初始化, 依旧可以正常输出:\nfood=早餐\n\nin 修饰符又有什么用呢?由上面可以就看出, ref 和 out 已经可以涵盖所有的情况了, 为什么还有一个 in 呢? in 自然也是有它的应用场景的.\n某一天你买了一幅名画, 十分贵重, 几乎花光了你至今为止所有的积蓄, 但是你的好朋友也想要看一下, 提出想要拿到自己家中好好观摩两天. 此时你心想, 使用 &quot;值传递&quot; 的方式吧, 就得复制一副相同的画, 虽然朋友也说了就算是复制品也可以, 但是请人再去临摹一份一模一样的, 这个开销太大了(对应程序中传递一个体积很大很大的值存储变量, 比如结构体变量, 复制一份的话, 内存占用就很高), 于是你还是决定直接将原画借给朋友看, 也就是 &quot;ref 引用传递&quot;, 但是心里始终是不放心啊, 万一朋友不小心把画作弄脏了, 弄丢了, 那自己这一辈子岂不凉凉了~\n于是在这个场景下就可以使用修饰符 in 了, 使用 in 修饰的引用传递, 在方法中只能使用参数值, 无法修改参数值. 这样就不用担心画作的安全问题了.\n\n[注] ref 和 out 参数在方法调用时必须显式注明 ref 和 out, 否则编译器直接报错! 但是从上图中可以看出, 我在调用 Friend 方法的时候并没有显式注明 in, 也就是说 in 并没有这个要求, 但是还是建议养成注明引用传递的习惯!\n由此可见, 在程序中, in 关键字主要用于程序优化, 节省内存. 当然这里说的 in 只是参数修饰符 in, 自然不包括在 foreach 中的 in 啦~\nparams使用 params 关键字可以指定采用数目可变的参数的方法参数, 因此当方法需要的参数个数无法确定的时候, 就可以使用 params 关键字.\nparams 使用时具有诸多语法限制:\n\nparams 修饰的参数类型必须是一维数组. 如果 params 修饰的不是一维数组, 直接发生编译错误;\n\n在方法声明中 params 关键字修饰的参数之后不允许有任何其他参数;\n\n在方法声明中只允许有一个 params 关键字.\n\n\n调用具有 params 修饰参数的方法时，可以传入:\n\n一维数组元素类型的逗号分隔列表;\n\n指定类型的一维数组;\n\n无参数. 如果未发送任何参数, 则 params 列表长度为零.\n\n\n[注]\n\nparams 修饰的参数类型必须是一维数组, 但是这里的 &quot;一维数组&quot; 指代的并不仅仅是这种简单的一维数组 int[], 任何类型的一维数组都可以, 包括交错数组: int[][].\n\n在方法声明中的 params 关键字之后不允许有任何其他参数, 就意味着 params 修饰的参数必须放在参数列表的最后一个, 同时也意味着只允许有一个 params 修饰的参数.\n\n\nusing System;using System.Collections.Generic;class Program&#123;    static void Main()    &#123;        Program program = new Program();        List&lt;string&gt; appleList = new List&lt;string&gt;();        appleList.Add(&quot;富士苹果&quot;);        appleList.Add(&quot;红龙苹果&quot;);        appleList.Add(&quot;香蕉苹果&quot;);        //......        appleList.Add(&quot;蜜脆苹果&quot;);        string[] apples = appleList.ToArray();        program.Factory();        program.Factory(&quot;富士苹果&quot;, &quot;红龙苹果&quot;);        program.Factory(&quot;富士苹果&quot;, &quot;红龙苹果&quot;, &quot;香蕉苹果&quot;, &quot;蜜脆苹果&quot;);        program.Factory(apples);        Console.ReadKey();    &#125;    private void Factory(params string[] apples)    &#123;        string str_log = string.Empty;        if (apples.Length &gt; 0)        &#123;            foreach (string apple in apples)            &#123;                str_log += apple + &quot;酒! &quot;;            &#125;        &#125;        else        &#123;            str_log = &quot;请提供原材料!&quot;;        &#125;        Console.WriteLine(str_log);    &#125;&#125;\n\n上面的例子输出的结果就是:\n请提供原材料!富士苹果酒! 红龙苹果酒!富士苹果酒! 红龙苹果酒! 香蕉苹果酒! 蜜脆苹果酒!富士苹果酒! 红龙苹果酒! 香蕉苹果酒! 蜜脆苹果酒!\n\n可以看出调用方法时, 传递不定个数的参数以及一维数组都是可以的!\n参考链接Microsoft Docs ref\nMicrosoft Docs params\n","categories":["CSharp"],"tags":["编程基础"]},{"title":"CSharp 迭代器","url":"/csharp/csharp_ienumerator.html","content":"\n\n🌴前言在之前的 csharp 学习过程中学习了索引器, 这样我自定义类中的数据也就可以使用方括号的形式进行访问啦, 同时我还看到了一个 &quot;迭代器&quot; 的词汇, 这是啥东西啊? 网上一查, 标志性词汇是 &quot;IEnumerable&quot; 和 &quot;IEnumerator&quot;...这个我熟悉啊, Unity 的协程 &#39;Coroutines&#39; 技术中也使用到了这个词汇, 那赶紧看看其中的知识吧.\n🍀C# 1.0 中的迭代器C# 1.0 中, 迭代模式是通过两个接口实现的: IEnumerable 和 IEnumerator.\n\n&quot;正确实现了 IEnumerable 接口&quot; 或者 &quot;具有完全符合特征的方法&quot; 的类型可以被迭代访问, 比如 C# 内置的数组, 链表类型, 这些都可以被迭代访问, 它们都实现了 IEnumerable 接口.\n \n\n\n但是正确实现了 IEnumerable 接口的并不是迭代器, IEnumerable 接口中只有一个需要实现的方法 GetEnumerator(), 这个方法作用是会返回一个迭代器, 并不是实现一个迭代器.\n\n正确实现了 IEnumerator 接口的类型才是迭代器.\n\nC# 1.0 中如何自己实现一个可迭代访问的类型C# 1.0 中, 想要实现一个可以被迭代访问的类型, 只要让这个类型正确实现 IEnumerable 接口即可. IEnumerable 接口中只有一个需要实现的方法 GetEnumerator(), 没有参数, 返回值类型是 IEnumerator. 比如实现一个可以迭代访问的 CharList 类型.\n/// &lt;summary&gt;/// 可迭代类型 CharList/// &lt;/summary&gt;public class CharList : IEnumerable // 继承接口 IEnumerable&#123;    /// &lt;summary&gt;    /// 枚举数据    /// &lt;/summary&gt;    private readonly string charArray;    /// &lt;summary&gt;    /// 构造器    /// &lt;/summary&gt;    /// &lt;param name=&quot;str&quot;&gt;枚举数据&lt;/param&gt;    public CharList(string str)    &#123;        charArray = str;    &#125;    /// &lt;summary&gt;    /// IEnumerable 中的 GetEnumerator 方法    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public IEnumerator GetEnumerator()    &#123;        return new CharEnumerator(charArray); // new 一个迭代器并返回    &#125;&#125;\n\nC# 1.0 中如何自己实现一个迭代器类型C# 1.0 中, 想要实现一个迭代器类型, 只要让这个类型正确实现 IEnumerator 接口即可. IEnumerator 接口中需要实现的内容有:\n\n&gt;public interface IEnumerator&gt;&#123;   //   // 摘要:   //     获取集合中位于枚举数当前位置的元素。   //   // 返回结果:   //     集合中位于枚举数当前位置的元素。   object Current &#123; get; &#125;   //   // 摘要:   //     将枚举数推进到集合的下一个元素。   //   // 返回结果:   //     如果枚举数已成功地推进到下一个元素，则为 true；如果枚举数传递到集合的末尾，则为 false。   //   // 异常:   //   T:System.InvalidOperationException:   //     创建枚举器后，已修改该集合。   bool MoveNext();   //   // 摘要:   //     将枚举数设置为其初始位置，该位置位于集合中第一个元素之前。   //   // 异常:   //   T:System.InvalidOperationException:   //     创建枚举器后，已修改该集合。   void Reset();&gt;&#125;\n\nCurrent 属性. 必须是 public 修饰, 必须返回 object 类型, 必须实现 Get 器, 必须遵守的 Get 器规则: 获取当前索引位置的值.\n\nMoveNext 方法. 必须是 public 修饰, 必须返回 bool 类型. 必须遵守的返回值规则: 如果可以获取下一个值, 返回 true, 如果无法或许下一个值, 则返回 false.\n\nReset 方法. 必须是 public 修饰, 必须返回 void 类型. 必须遵守的逻辑规则: 将此时的索引位置设置为 第一个元素之前.\n\n\n只有同时满足了上面全部要求, 才算是正确实现了一个迭代器.\n/// &lt;summary&gt;/// 迭代器 CharEnumerator/// &lt;/summary&gt;public class CharEnumerator : IEnumerator // 继承 IEnumerator 接口&#123;    /// &lt;summary&gt;    /// 枚举数据    /// &lt;/summary&gt;    private readonly string charArray;    /// &lt;summary&gt;    /// 索引位置    /// &lt;/summary&gt;    private int currentIndex;    /// &lt;summary&gt;    /// 构造器    /// &lt;/summary&gt;    /// &lt;param name=&quot;str&quot;&gt;枚举数据&lt;/param&gt;    public CharEnumerator(string str)    &#123;        currentIndex = -1; // 初始化索引位置        charArray = str; // 初始化枚举数据    &#125;    /// &lt;summary&gt;    /// IEnumerator 中的 Current 属性    /// &lt;/summary&gt;    public object Current    &#123;        get        &#123;            return charArray[currentIndex]; // 获取当前索引位置的值        &#125;    &#125;    /// &lt;summary&gt;    /// IEnumerator 中的 MoveNext 方法    /// &lt;/summary&gt;    /// &lt;returns&gt;如果可以获取下一个值, 返回 true, 如果无法或许下一个值, 则返回 false.&lt;/returns&gt;    public bool MoveNext()    &#123;        return ++currentIndex &lt; charArray.Length; // 如果 &quot;索引位置&quot; 自增后小于枚举数据长度, 说明可以获取下一个值, 返回 true, 否则返回 false.    &#125;    /// &lt;summary&gt;    /// IEnumerator 中的 Reset 方法    /// &lt;/summary&gt;    public void Reset()    &#123;        currentIndex = -1; // 将索引位置设置为第一个元素之前    &#125;&#125;\n\n上面的代码段实现了一个最基础的迭代器, 这样 CharList 这个类型便可以使用 foreach 进行迭代访问了.\n✨C# 2.0 中的迭代器C# 2.0 中便可以使用 yield return 来简化迭代器的实现. 这样相比 1.0, 我们直接可以省略一个 CharEnumerator 类的实现, 方便了很多.\npublic class CharList : IEnumerable&#123;    /// &lt;summary&gt;    /// 枚举数据    /// &lt;/summary&gt;    private readonly string charArray;    /// &lt;summary&gt;    /// 构造器    /// &lt;/summary&gt;    /// &lt;param name=&quot;str&quot;&gt;枚举数据&lt;/param&gt;    public CharList(string str)    &#123;        charArray = str;    &#125;    /// &lt;summary&gt;    /// IEnumerable 中的 GetEnumerator 方法    /// &lt;/summary&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public IEnumerator GetEnumerator()    &#123;        for (int i = 0; i &lt; charArray.Length; i++)        &#123;            yield return charArray[i]; // 使用 yield return 构造一个迭代器        &#125;    &#125;&#125;\n\n🦄迭代器的执行顺序将 C# 1.0 迭代器例子补全 (本文最后附有已补全的代码), 并在一个 foreach 中进行逐步调试就可以看到迭代访问时的代码执行顺序.\nforeach (var item in charList)\n\ncharList: 调用 GetEnumerator 方法.\n\nin: 调用 MoveNext 方法.\n\nitem: 获取 Current 属性.\n\n\n但是如果我们没有使用 C# 1.0 提供的形式实现迭代器, 而是使用了 C# 2.0 中的 yield return 实现迭代器, 那么此时迭代器的执行顺序又是什么呢?\n我们来做一个例子测试一下, 先创建一个类 CreateEnumerable, 这个类可以返回一个可迭代器类型 IEnumerable&lt;int&gt;, 之后使用 GetEnumerator 方法获取迭代器, 然后使用 while 循环手动调用迭代器的 MoveNext 方法以及 Current 属性, 并输出执行顺序.\nusing System;using System.Collections.Generic;namespace Exercise&#123;    public class Program    &#123;        static int runIndex = 0;        static readonly string Padding = new string(&#x27;\\t&#x27;, 4);        static IEnumerable&lt;int&gt; CreateEnumerable()        &#123;            Console.WriteLine(&quot;&#123;0,3&#125; : &#123;1&#125;Start of CreateEnumerable&quot;, runIndex, Padding); runIndex++;            for (int i = 0; i &lt; 3; i++)            &#123;                Console.WriteLine(&quot;&#123;0,3&#125; : &#123;1&#125;\\tBefore yield &#123;2&#125;&quot;, runIndex, Padding, i); runIndex++;                yield return i;                Console.WriteLine(&quot;&#123;0,3&#125; : &#123;1&#125;\\tAfter yield&quot;, runIndex, Padding); runIndex++;            &#125;            Console.WriteLine(&quot;&#123;0,3&#125; : &#123;1&#125;Yielding final value&quot;, runIndex, Padding); runIndex++;            yield return -1;            Console.WriteLine(&quot;&#123;0,3&#125; : &#123;1&#125;End of CreateEnumerable()&quot;, runIndex, Padding); runIndex++;        &#125;        private static void Main()        &#123;            // 创建一个可以迭代访问的实例            IEnumerable&lt;int&gt; iterable = CreateEnumerable();            // 获取这个实例中的迭代器            IEnumerator&lt;int&gt; iterator = iterable.GetEnumerator();            Console.WriteLine(&quot;&#123;0,3&#125; : Starting to iterate&quot;, runIndex); runIndex++;            while (true)            &#123;                Console.WriteLine(&quot;&#123;0,3&#125; : Calling MoveNext()...&quot;, runIndex); runIndex++;                bool result = iterator.MoveNext(); // 调用迭代器的 MoveNext 方法                Console.WriteLine(&quot;&#123;0,3&#125; : ...MoveNext result=&#123;1&#125;&quot;, runIndex, result); runIndex++;                if (!result) break;                Console.WriteLine(&quot;&#123;0,3&#125; : Fetching Current...&quot;, runIndex); runIndex++;                Console.WriteLine(&quot;&#123;0,3&#125; : ...Current result=&#123;1&#125;&quot;, runIndex, iterator.Current); runIndex++; // 获取迭代器的 Current 属性            &#125;            Console.Read();        &#125;    &#125;&#125;\n\n输出结果为:\n 0 : Starting to iterate 1 : Calling MoveNext()... 2 :                           Start of CreateEnumerable 3 :                                   Before yield 0 4 : ...MoveNext result=True 5 : Fetching Current... 6 : ...Current result=0 7 : Calling MoveNext()... 8 :                                   After yield 9 :                                   Before yield 110 : ...MoveNext result=True11 : Fetching Current...12 : ...Current result=113 : Calling MoveNext()...14 :                                   After yield15 :                                   Before yield 216 : ...MoveNext result=True17 : Fetching Current...18 : ...Current result=219 : Calling MoveNext()...20 :                                   After yield21 :                           Yielding final value22 : ...MoveNext result=True23 : Fetching Current...24 : ...Current result=-125 : Calling MoveNext()...26 :                           End of CreateEnumerable()27 : ...MoveNext result=False\n\n从输出结果中可以看出使用 yield return 所创建的迭代器的运行步骤如下.\n\n直到第一次执行 MoveNext 方法时, 程序才会进入到 CreateEnumerable 方法中执行.\n\n之后在方法 CreateEnumerable 中, 遇到 yield return 时会跳出方法, 回到之前的 MoveNext 处, 使 MoveNext 返回 true, 并继续向下执行.\n\n直到经由 while 循环再次遇到 MoveNext 方法时, 程序便会再次进入 CreateEnumerable 方法, 并且是从上次跳出方法的位置, 即 yield return 位置处继续向下执行 for 循环.\n\n最后一次执行 MoveNext 方法时, 程序进入 CreateEnumerable 方法, 但是此时 CreateEnumerable 方法中已经没有可执行的 yield return 语句了, 于是运行完 CreateEnumerable 方法的最后一条语句后跳出 CreateEnumerable 方法, 使 MoveNext 返回 false, 并继续向下执行.\n\n遇到 break 跳出 while 循环, 程序结束.\n\n\n从 CreateEnumerable 内部来看, yield return 相当于暂时退出了方法去执行另一段代码, 另一端代码执行完之后, 再回到 yield return 的位置继续执行.\nyield break 退出迭代器一般情况下, return 的作用是用于返回给调用者方法的结果或者结果一个方法的运行, 并在返回数值或者结束方法运行之前运行 finally 中的语句.\n在返回值为 IEnumerable&lt;&gt; 类型的方法中, 如果想快速退出方法, 可以使用 yield break.\nusing System;using System.Collections.Generic;public class Program&#123;    public IEnumerable&lt;int&gt; CountWithTimeLimit(DateTime limit)    &#123;        try        &#123;            for (int i = 1; i &lt;= 100; i++)            &#123;                if (DateTime.Now &gt;= limit)                &#123;                    yield break;                &#125;                yield return i;            &#125;        &#125;        finally        &#123;            Console.WriteLine(&quot;Finally: Stopping&quot;);        &#125;    &#125;    static void Main()    &#123;        Program program = new Program();        DateTime stopTime = DateTime.Now.AddSeconds(2); // 获取 2 秒后的时间        Console.WriteLine(&quot;Start of Main&quot;);        foreach (int index in program.CountWithTimeLimit(stopTime))        &#123;            Console.WriteLine(&quot;\\tReceived &#123;0&#125;&quot;, index);            System.Threading.Thread.Sleep(300); // 毫秒        &#125;        Console.WriteLine(&quot;End of Main&quot;);        Console.Read();    &#125;&#125;\n\n输出结果为:\nStart of Main        Received 1        Received 2        Received 3        Received 4        Received 5        Received 6        Received 7Finally: StoppingEnd of Main\n\n可以看出, yield return 只是暂时离开方法, 到另一个位置执行其他的代码, 并不会执行 finally 语句块, 而 yield break 则直接转而执行了 finally 语句块中的语句, 并彻底结束了 foreach 的运行.\n🍒参考文献\nC#迭代器\n\n🙄代码using System;using System.Collections;namespace Exercise&#123;    class Program    &#123;        static void Main()        &#123;            CharList charList = new CharList(&quot;Hello World&quot;);            foreach (var item in charList)            &#123;                Console.Write(item);            &#125;            Console.ReadKey();        &#125;    &#125;    /// &lt;summary&gt;    /// 可迭代类型 CharList    /// &lt;/summary&gt;    public class CharList : IEnumerable // 继承接口 IEnumerable    &#123;        /// &lt;summary&gt;        /// 枚举数据        /// &lt;/summary&gt;        private readonly string charArray;        /// &lt;summary&gt;        /// 构造器        /// &lt;/summary&gt;        /// &lt;param name=&quot;str&quot;&gt;枚举数据&lt;/param&gt;        public CharList(string str)        &#123;            charArray = str;        &#125;        /// &lt;summary&gt;        /// IEnumerable 中的 GetEnumerator 方法        /// &lt;/summary&gt;        /// &lt;returns&gt;&lt;/returns&gt;        public IEnumerator GetEnumerator()        &#123;            return new CharEnumerator(charArray); // new 一个迭代器并返回        &#125;    &#125;    /// &lt;summary&gt;    /// 迭代器 CharEnumerator    /// &lt;/summary&gt;    public class CharEnumerator : IEnumerator // 继承 IEnumerator 接口    &#123;        /// &lt;summary&gt;        /// 枚举数据        /// &lt;/summary&gt;        private readonly string charArray;        /// &lt;summary&gt;        /// 索引位置        /// &lt;/summary&gt;        private int currentIndex;        /// &lt;summary&gt;        /// 构造器        /// &lt;/summary&gt;        /// &lt;param name=&quot;str&quot;&gt;枚举数据&lt;/param&gt;        public CharEnumerator(string str)        &#123;            currentIndex = -1; // 初始化索引位置            charArray = str; // 初始化枚举数据        &#125;        /// &lt;summary&gt;        /// IEnumerator 中的 Current 属性        /// &lt;/summary&gt;        public object Current        &#123;            get            &#123;                return charArray[currentIndex]; // 获取当前索引位置的值            &#125;        &#125;        /// &lt;summary&gt;        /// IEnumerator 中的 MoveNext 方法        /// &lt;/summary&gt;        /// &lt;returns&gt;如果可以获取下一个值, 返回 true, 如果无法或许下一个值, 则返回 false.&lt;/returns&gt;        public bool MoveNext()        &#123;            return ++currentIndex &lt; charArray.Length; // 如果 &quot;索引位置&quot; 自增后小于枚举数据长度, 说明可以获取下一个值, 返回 true, 否则返回 false.        &#125;        /// &lt;summary&gt;        /// IEnumerator 中的 Reset 方法        /// &lt;/summary&gt;        public void Reset()        &#123;            currentIndex = -1; // 将索引位置设置为第一个元素之前        &#125;    &#125;&#125;","categories":["CSharp"],"tags":["编程基础"]},{"title":"CSharp 垃圾回收","url":"/csharp/csharp_garbagecollect.html","content":"\n\n🌴前言网上关于 Garbage Collect 的文章已多如牛毛, 所以这里主要说一下我遇到的问题和 GC 使用方面的一些注意事项以及自己对垃圾回收中几个方法的理解.\n[注] 以下 GC 的含义均为 : Garbage Collect.\n🍀.NET的 GC 机制先说一下 .Net 上的 GC 机制:\n\nGC 并不是能自动释放所有的资源, 它只能自动释放托管资源 .\n\nGC 并不是实时回收内存的, 具体回收内存的时间由 GC 自身的算法控制.\n\n\n🥝托管资源和非托管资源这两个具体怎么定义的没去查, 只说一下 GC 对待他们的区别.\n托管资源.NET 可以自动释放托管资源并回收其内存, 不需要人工干预.\n这句话的意思就是说当我们写程序时, 创建了一个托管资源, 我们使用了一段时间后就不用了, 此时我们并不需要告诉程序: &quot;这个资源已经用完了, 一会有空了的时候帮我回收一下这些内存, thank you!&quot;, .NET 会自动判断其是否已经不再使用, 如果 .NET 判断其确实已经不再使用了, 便会自动将其占用的内存回收.\n非托管资源.NET 不会自动回收非托管资源, 如需回收, 需要提前通知.\n常见的非托管资源: 文件, 字体, 窗口, 网络连接, 数据库连接, 画刷, 图标等.\n上面那句话的意思就是说当我们写程序时, 创建了一个非托管资源, 我们使用了一段时间后就不用了, 此时我们就必须告诉程序: &quot;这个我用完了, 有空了一定要记得回收一下这块内存哈! thanks!&quot;. 不然的话, 那个非托管资源就会一直被我们的程序占用. 即使每过一段时间 .NET 都会来内存处收垃圾, 但是 .NET 永远也不知道这个资源已经成为垃圾了, 因为我们并没有告诉他.\n这就是 .NET 对待两种资源的态度区别.\n🌼我们如何告诉 .NET 非托管资源已经用完了呢?想要给非托管资源打上一个 &quot;可被回收&quot; 标记, 需要使用 Dispose 方法.\n显式调用 Dispose() 方法对于实现了 IDisposable 接口的非托管资源, 可以直接调用其中的 Dispose() 方法, 这个方法可以用来告知程序: &quot;这个资源已经用完了, 你抽空安排一下吧!&quot; 😃\n使用 using 语句块隐式调用 Dispose() 方法所有实现了 IDisposable 接口的资源都可以放到 using 语句块中进行资源管理, 在 using 中进行声明以及实例化. 以下摘录自 Microsoft Document 中对 using 的介绍.\n\n\nIDisposable 对象的生存期限于单个方法时, 应在 using 语句中声明并实例化它.\n\nusing 语句会按照正确的方式调用对象上的 Dispose 方法, 即使 using 语句块中出现了异常, 也能保证 Dispose 被正常调用.\n\n在 using 块中, 对象是只读的并且无法进行修改或重新分配.\n\n不要先实例化资源对象, 然后将变量传递到 using 语句, 而是应该直接在 using 语句中实例化该对象, 并将其范围限制在 using 块中.\n\n\n\n🦄回收内存的非实时性GC 一个很大的特点就是内存的回收并不是实时的, 它内部有一套完整的算法会进行智能判断回收的时机. 而且文章上面所提到的各种通知系统资源已使用完毕的方式也仅仅只是告诉系统这个 &quot;非托管资源&quot; 已经成为垃圾了, 可以被回收了. 但是实际上此时这块内存还没有被回收, 具体什么时候回收是由系统决定的.\n👀GC.Collect() 方法因此系统提供了一个 GC.Collect() 方法, 这个方法会以系统的 root 为基础层层遍历, 将所有的可回收内存全部回收. 借由此方法, 程序员可以立即回收内存. 但是除非特殊情况, 不要主动调用此方法, 频繁调用会严重影响程序性能. (微软说的~)\n🙄我的问题当时我遇到的问题是, ASP 程序中需要将数据库中的 240 万条数据导出到一个文件中, 大概 500MB 左右, 而程序是一次性将这全部的 240 万行数据读取出来, 放到一个临时的 DataSet 中, 之后向文件中写入. 但是这个 DataSet 过大, 直接导致内存溢出了......\n于是我开始分批次读取, 并且使用 using 语句块进行资源的自动管理, 如下, 外面套了一层 for 循环.\n// 追加模式写入流, 使用 using 自动管理资源using (StreamWriter sw = new StreamWriter(path, true, Encoding.GetEncoding(&quot;GB2312&quot;)))&#123;    using (DataSet ds = new GOOGOSOFT.DATABASE.OracleHelper().GetDataSet(str_sql))    &#123;        WriteFileCSV(ds, i, sw);    &#125;&#125;\n\n我一共分了 8 个批次查询, 但是当程序循环到第 6 次时, 还是内存溢出了......我当时就很郁闷, 不是都已经使用 using 了吗, 为啥还内存溢出......后来才知道, using 只是会告诉程序资源使用完毕了, 但并不会立即回收那部分内存. 于是在每次开始新一轮循环的时候强制回收一次内存就可以了.\n// 追加模式写入流, 使用 using 自动释放资源using (StreamWriter sw = new StreamWriter(path, true, Encoding.GetEncoding(&quot;GB2312&quot;)))&#123;    using (DataSet ds = new GOOGOSOFT.DATABASE.OracleHelper().GetDataSet(str_sql))    &#123;        WriteFileCSV(ds, i, sw);    &#125;&#125;// 强制调用垃圾回收器, 回收上面资源占用的内存GC.Collect();\n\n我觉得释放和回收可以这样理解:\n\n释放是指解除对非托管资源的占用和锁定.\n\n比如一个文件, 在没有释放资源的时候, 不能对其进行其他操作, 比如删除操作. 释放资源后可以进行删除.\n\n回收是指将资源使用的内存进行回收.\n\n比如我之前遇到的问题, 释放资源只是将资源打上一个 &quot;可被回收&quot; 的标记等待被 GC 回收, 此时内存还是被占用的, 之后 GC 真正回收内存之后, 内存使用率才会真正降低...\n最后还是要在强调一下, 通常情况下, 我们应该避免调用 GC.Collect() 方法, 让垃圾回收器独立运行. 在大多数情况下, 对于执行回收的最佳时机, 垃圾回收器的算法更有优势.\n除非在某些特殊情况下, 我们的程序占用了大量的内存, 需要立即释放, 在这种情况下我们才能使用 GC.Collect() 方法手动回收内存.\n🐬参考文章\n从 C# 垃圾回收机制中挖掘性能优化方案\n\nusing 语句\n\n关于using和System.GC.Collect()对于释放资源的讨论\n\n.Net中Finalize()和Dispose()有什么区别?\n\n\n","categories":["CSharp"],"tags":["编程基础"]},{"title":"CSharp 中形形色色的参数","url":"/csharp/csharp_params.html","content":"\n\n必选参 与 可选参 与 不定参CSharp 中参数有必选参, 可选参和不定参, 用以实现更加灵活的方法调用.\n必选参通常用的方法传参就是必选参. 只要方法有参数, 调用这个方法时就必须传参.\n// 定义方法public void Test(string str)&#123;    Debug.Log(str);&#125;\n\n可选参可选参对外表现为: 当外部调用方法时, 参数可以传也可以不传~ 哈哈, 任不任性?\n那可选参是怎么编写的呢? 可选参就是给参数一个默认值, 此时参数就变成了可选参. 可选参也是有语法限制的, 可选参必须放到所有必选参的后面, 不定参不属于必选参.\n// 定义方法public void Test(string str, string star = &quot;default value&quot;)&#123;    Debug.Log(str + star);&#125;\n\n调用具有可选参的方法时, 可以直接和正常的方法一样进行传参, 打算使用默认值的可选参可以直接省略.\n// 调用方法Test(&quot;abc&quot;);Test(&quot;abc&quot;, &quot;def&quot;)\n\n但是这里有一个问题, 可选参的语法规则只限制了可选参必须在必选参的后面, 但是并没有限制可选参的数量, 如果有好多可选参, 而我想要只传递特定的参数的时候, 怎么办呢?\n比如下面的方法我想使用 star1 的默认值, star2 我想改为 &quot;, 你早就没了&quot;, 咋传参呢?\nprivate static void Test(string str, string star1 = &quot;我没带腰带&quot;, string star2 = &quot;star2&quot;)&#123;    Debug.Log(str + star1 + star2);&#125;\n\n此时就得使用可选参的另一种调用方式: 参数名: 参数值.\nTest(&quot;要不是因为&quot;, star2: &quot;, 你早就没了&quot;);\n\n不定参编写程序的时候, 有时会有这样的场景: 我需要写一个工具方法用来处理各种数据, 数据使用参数的形式传入方法, 但是问题在于每次我要传入的数据的数量都是不一致的, 这次可能传入 4 个, 下次可能需要 5 个, 甚至有时需要 10 个也说不定, 那这可咋办呢?\n在没有不定参之前, 只能使用数组来传输, 参数为一个数组, 传入数据的时候先将数据整合为一个数组, 然后整体传入, 但是如果我就是想逐个传入呢? 就像 string.Format(&quot;&#123;0&#125;, &#123;1&#125;, &#123;2&#125;&quot;, &quot;AAA&quot;, &quot;BBB&quot;, &quot;CCC&quot;); 一样, 后面的参数数量不确定, 并且传入的时候是逐个传入的.\n此时就需要语法糖-不定参啦! 不定参的对外表现就是可以传入同类型的数据任意多个, 数量是不确定的, 传入的时候参数也是允许逐个传入的.\n不定参使用 params 关键字和 数组 实现. 切记必须是 数组 类型.\n即从外部看来, 参数传入时是逐个传入的, 但是实际在传入之后会被整合为一个数组进行处理, 这也就是为什么数量可以不确定, 但类型必须是同类型的原因.\n// 不定参方法public void UseParams(params string[] stars)&#123;    foreach (var star in stars)    &#123;        Debug.Log(star);    &#125;&#125;// 调用 (同类型, 数量不定, 可以逐个传入, 可以整体作为数组传入)UseParams();UseParams(&quot;AAA&quot;);UseParams(&quot;AAA&quot;, &quot;BBB&quot;);UseParams(&quot;AAA&quot;, &quot;BBB&quot;, &quot;CCC&quot;);UseParams(new[]&#123;&quot;AAA&quot;, &quot;BBB&quot;, &quot;CCC&quot;&#125;);\n\n另外不定参也有语法要求, 不定参作为参数时, 必须放置在整个参数列表的最后.\n总结可选参:\n参数具有默认值.\n传参时可传可不传.\n可同时定义多个可选参.\n可以使用 &quot;参数名: 参数值&quot; 进行指定参数传值.\n\n不定参\n参数必须同类型.\n参数数量不确定, 且允许逐个传入.\n1 个参数列表中不定参最多只能有 1 个.\n使用 params 和 [] 实现. (是否仅此一种待考究, 目前暂时认为唯一方式)\n\n参数顺序( 必选参, 可选参, 不定参 )\nthis 修饰的参数无论是带有默认值的可选参还是使用 params 关键字的不定参, 它们的本质还是为了方法的参数服务的, 但是还有一种是使用了 this 关键字进行修饰的参数.\n使用 this 修饰更多的是为了类而服务, 目的是为了对类进行方法扩展.\n目前理解为: 使用 this 来实现 扩展方法, 对特定的非静态类进行行为补充. 切记是非静态类.\n比如有一个非静态类已经封装好了, 我们无法去修改类文件, 那么此时想要对其增加行为的话就可以使用这个语法.\n下面是一个 Student 类, 这个类文件已经无法查看与修改.\n// 简易类, 举例用public class Student&#123;    public string name;    public string id;&#125;\n\n此时在另一个地方使用这个类的一个实例, 需要增加一个特定的功能, 就可以这样写:\n// 先为这个 Student 添加想要的功能private static void NewAction(this Student student, string str)&#123;    Debug.Log($&quot;&#123;student.name&#125; : &#123;student.id&#125;, &#123;str&#125;&quot;);&#125;// 之后就可以使用类的实例直接调用var student = new Student &#123;name = &quot;Kuroha&quot;, id = &quot;0001&quot;&#125;;student.NewAction(&quot;就是我啦!&quot;);\n\n此语法还可以对 CSharp 原始类型进行扩展, 比如 int, string 等. 扩展方法也是具有语法限制的, 都放在总结里面了.\n\n使用 this 可以实现特定类型的方法扩展.\nthis 修饰的参数并不需要主动传参, 这个参数的值就是调用时类实例的值.\n扩展方法只能在非嵌套, 非泛型的静态类内部才能定义.\n扩展方法必须是静态方法. (毕竟在静态类中嘛)\n调用时必须使用实例进行调用. (虽然定义的时候是一个静态方法)\nthis 修饰的参数必须位于参数列表的第 1 个! (正好和 params 相反)\n\n","categories":["CSharp"],"tags":["编程基础"]},{"title":"CSharp 中的 Path 类","url":"/csharp/csharp_path.html","content":"\n\n方法\n\n\nAPI\n作用\n示例\n示例\n\n\n\nPath.Combine()\n连接多个路径字符串, 自动处理路径分隔符\nPath.Combine(&quot;C:\\Folder&quot;, &quot;SubFolder&quot;, &quot;file.txt&quot;)\nC:\\Folder\\SubFolder\\file.txt\n\n\nPath.TryJoin()\n尝试连接多个路径字符串, 返回 bool 表示是否成功\nPath.TryJoin(&quot;C:\\Folder&quot;, &quot;file.txt&quot;, out string result)\nC:\\Folder\\file.txt\n\n\nPath.Join()\n连接多个路径字符串, 不检查路径是否有效\nPath.Join(&quot;C:\\Folder&quot;, &quot;SubFolder&quot;, &quot;file.txt&quot;)\nC:\\Folder\\SubFolder\\file.txt\n\n\nPath.ChangeExtension()\n更改文件扩展名\nPath.ChangeExtension(&quot;file.txt&quot;, &quot;.jpg&quot;)\nfile.jpg\n\n\nPath.GetExtension()\n获取文件的扩展名\nPath.GetExtension(&quot;file.txt&quot;)\n.txt\n\n\nPath.HasExtension()\n判断路径是否包含扩展名\nPath.HasExtension(&quot;file.txt&quot;)\ntrue\n\n\nPath.GetDirectoryName()\n获取目录部分 (去除文件名)\nPath.GetDirectoryName(&quot;C:\\Folder\\file.txt&quot;)\nC:\\Folder\n\n\nPath.GetFileName()\n获取文件名 (包含扩展名)\nPath.GetFileName(&quot;C:\\Folder\\file.txt&quot;)\nfile.txt\n\n\nPath.GetFileNameWithoutExtension()\n获取文件名 (不含扩展名)\nPath.GetFileNameWithoutExtension(&quot;C:\\Folder\\file.txt&quot;)\nfile\n\n\nPath.GetTempFileName()\n生成一个唯一的临时文件路径 (会创建空文件)\nPath.GetTempFileName()\nC:\\Users...\\AppData\\Local\\Temp\\tmp1234.tmp\n\n\nPath.GetRandomFileName()\n生成一个随机文件名 (不会创建文件)\nPath.GetRandomFileName()\nax1b2c.tmp\n\n\nPath.GetFullPath()\n获取绝对路径\nPath.GetFullPath(&quot;file.txt&quot;)\nC:\\CurrentDirectory\\file.txt\n\n\nPath.GetTempPath()\n获取系统的临时文件夹路径\nPath.GetTempPath()\nC:\\Users...\\AppData\\Local\\Temp\\\n\n\nPath.GetRelativePath()\n获取相对路径\nPath.GetRelativePath(&quot;C:\\Folder&quot;, &quot;C:\\Folder\\SubFolder\\file.txt&quot;)\nSubFolder\\file.txt\n\n\nPath.GetPathRoot()\n获取路径的根目录部分\nPath.GetPathRoot(&quot;C:\\Folder\\file.txt&quot;)\nC:\\\n\n\nPath.IsPathRooted()\n判断路径是否包含根目录 (绝对路径)\nPath.IsPathRooted(&quot;C:\\Folder\\file.txt&quot;)\ntrue\n\n\nPath.IsPathFullyQualified()\n判断路径是否是完整路径 (不包含相对部分)\nPath.IsPathFullyQualified(&quot;C:\\Folder\\file.txt&quot;)\ntrue\n\n\nPath.GetInvalidPathChars()\n获取路径中无效的字符数组\nPath.GetInvalidPathChars()\n\n\n\nPath.GetInvalidFileNameChars()\n获取文件名中无效的字符数组\nPath.GetInvalidFileNameChars()\n\n\n\n属性\n\n\nAPI\n作用\n示例\n\n\n\nPath.PathSeparator\n获取环境变量路径分隔符 (Windows ;Linux :)\nPath.PathSeparator &#x2F;&#x2F; ;\n\n\nPath.DirectorySeparatorChar\n获取目录分隔符 (Windows \\ Linux &#x2F;)\nPath.DirectorySeparatorChar &#x2F;&#x2F; \\\n\n\nPath.VolumeSeparatorChar\n获取磁盘卷分隔符 (Windows : Linux 不存在)\nPath.VolumeSeparatorChar &#x2F;&#x2F; :\n\n\nPath.AltDirectorySeparatorChar\n获取备用的目录分隔符 (Windows &#x2F; 与 \\ 等价)\nPath.AltDirectorySeparatorChar &#x2F;&#x2F; &#x2F;\n\n\n","categories":["CSharp"],"tags":["编程基础"]},{"title":"Hexo + Github Pages 搭建个人博客","url":"/hexo/hexo_blog.html","content":"\n\n前言搭建个人博客的流程大概是: 先搭建博客环境, 就像你要玩电脑游戏, 首先得先买一台电脑一样. 这不废话吗 之后在电脑上创建博客的本地文件, 最后再将创建好的本地文件上传到网上就可以了. 这里我使用的是 Hexo 和 Github Pages 来搭建个人博客.\n环境配置安装 Git进入 Git 官方网站 下载安装即可.\n验证方法: 在桌面右键, 只要出现 Git GUI Here 和 Git Bash Here 就表示安装成功了.\n安装 Nodejs进入 Nodejs 官方网站 下载安装即可.\nLTS 版本即可满足使用, 可以在 cmd 中使用 node -v 和 npm -v 进行验证, 出现版本号就说明成功了.\n安装 Hexo安装 Hexo 之前, 如果你想要更改 Hexo 的安装位置 (Hexo 默认会安装在 C 盘), 可以在 cmd 中输入下面的命令, 记得把路径改为自己的:\nnpm config set prefix &quot;H:\\Programs Computer\\NodeGobal&quot;npm config set cache &quot;H:\\Programs Computer\\NodeCache&quot;\n\n之后可以使用以下命令查看设置:\nnpm config get prefixnpm config get cache\n\n先切换 npm 源: 打开 cmd, 输入下面的命令:\nnpm config set registry https://registry.npm.taobao.org\n之后安装 Hexo:\nnpm install -g hexo\n创建本地博客\n   新建一个文件夹, 来放置本地博客, 名字以及路径自己决定. 我的是: F:\\WorkSpace\\HexoBlog\n   进入这个空的文件夹, 点击鼠标右键, 选择 Git Bash Here, 会弹出一个类似 cmd 的窗口, 这个窗口会一直使用, 不要关闭, 如果不小心关闭了, 再次回到这个文件夹中, 在空白处点击鼠标右键, 选择 Git Bash Here 即可再次打开.\n   初始化本地博客, 在 Git Bash Here 中输入: hexo init\n   安装默认依赖包, 在 Git Bash Here 中输入: npm install\n   生成静态文件, 在 Git Bash Here 中输入: hexo generate 或者命令的缩写 hexo g, 此时网页就创建好了, 下面我们来预览一下博客的样子.\n   开启服务, 在 Git Bash Here 中输入 hexo server 或者命令的缩写 hexo s, 服务默认开启网址: http://localhost:4000 , 此时在浏览器中即可预览博客.\n\n【注】\n\n预览完毕后记得按 Ctrl + C 停止服务.\n如果不小心按了Ctrl + C 停止了服务, 再次输入 hexo s 开启服务即可.\n如果 http://localhost:4000 无法预览博客, 可能是 4000 端口被占用了, 我们先按 Ctrl + C 停止服务, 然后使用下面的语句切换端口:  hexo server -p 端口号 , 这里的端口号从 4000 往上加即可, 如: 4001, 具体使用哪个不用太纠结, 可以预览博客即可.\n\n关联 GitHub 和 Hexo经过前面两个步骤, 我们已经在本地创建好了博客, 也可以通过本地服务进行预览, 但是这样网页仅仅保存在本地, 网络上的人无法查看的, 此时我们就要将本地博客和 GitHub Pages 关联, 或者说上传到 GitHub 上, 这样所有人都可以查看了.\n开启 GitHub PagesGitHub Pages: 其本来用于介绍托管在 GitHub 上的项目, 由于它的空间免费稳定, 因此适合用来搭建个人博客, 但是有以下注意点:\n\n每个 GitHub 账号只能有一个仓库来存放个人主页,\n仓库的名字必须是 username.github.io,\n通过 http://username.github.io 来访问个人主页,\n个人主页的网站内容是在 master 分支下.\n\n接下来我们创建个人主页仓库: 在 GitHub 首页右上角头像左侧的加号处, 点击: New repository, 仓库名字必须是: 你的 Github 用户名.github.io, 下面选择 Public, 下面的选项是让你是否在仓库中初始化一个 README.md 文件, 自己随意. 最后点击创建仓库, 这样 GitHub Pages 就创建好了.\n获取 SSH 密钥直达车:\ngit config --global user.name &quot;KurohaKirito&quot;git config --global user.email &quot;KurohaKirito@gmail.com&quot;ssh-keygen -t rsa -C &quot;KurohaKirito@gmail.com&quot;\n\n至此, 我们的本地博客和 GitHub Pages 都准备好了, 下面就可以把网页部署 (上传) 到 GitHub Pages 上了. 在部署之前, 我们先设置一下 SSH 密钥. 因为如果不配置 SSH 密钥, 每次部署本地博客到 GitHub Pages 时, 都要输入 Github 账号密码, 非常繁琐.\n获取 SSH 密钥: 如果你是第一次使用 Git, 要先配置 Git 的用户名和邮箱, 在 Git Bash Here 中输入:\ngit config --global user.name &quot;username&quot;git config --global user.email &quot;mail&quot;\n\n上面的 username 改成你 GitHub 的用户名, mail 改成你 GitHub 的邮箱. 之后再次输入:\nssh-keygen -t rsa -C &quot;mail&quot;\n\nmail 要用你自己的 Github 邮箱. 回车后会依次出现三个选项, 直接全部回车即可. 这样 SSH 密钥就生成了, 接下来需要密钥填写到 GitHub 上.\n在 C:\\Users\\用户名\\.ssh目录中, 会出现这样两个文件: id_rsa 和 id_rsa.pub\n打开 id_rsa.pub 文件, 复制里面所有的内容.\n之后打开浏览器, 登录 GitHub, 依次点击头像下的 Settings, 左面的 SSH and GPG keys, 右上角的 New SSH key, 填写标题时, 最好和你那个网页文件夹的名字一致, 方便记忆和日后查找.点击 Add SSH key 并且验证 GitHub 密码, 即可完成密钥的添加.\n部署本地博客到 GitHub Pages之前的步骤中 SSH 密钥已经设置好了, 接下来就可以部署本地博客到 Github Pages 了, 在这里不建议直接使用 Git 进行部署, 而是使用 Hexo 中的 Hexo deploy 插件进行一键式部署, 方便快捷.\n首先要安装 Hexo deploy 插件, 还是在 Git Bash Here 中输入命令:\nnpm install hexo-deployer-git --save\n\n之后打开网页根目录下的 _config.yml 文件, 文件的末尾是这样的:\n# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type:\n\n修改成下面这样:\n# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: git@github.com:KurohaKirito/KurohaKirito.github.io.git  branch: master\n\nrepo 就是你仓库的地址: 有 SSH 和 HTTPS 两种格式, 你选择哪种都可以. 我选择的是 SSH 格式. 在你仓库页面上点击绿色按钮 Clone or download 即可获得仓库地址.\n配置完成之后, 执行部署命令, 还是在 Git Bash Here 中输入命令: hexo deploy 或者命令的缩写: hexo d, 输入 GitHub 用户名, 密码即可.\n验证方法: 在浏览器中输入网址: https://用户名.github.io , 用户名修改为你自己的 Github 用户名, 如果能看到之前博客的样子, 就说明部署成功了!\n附录常用 Hexo 命令\n\n\n命令\n作用\n\n\n\nhexo help\n查看帮助\n\n\nhexo -v\n查看本地环境\n\n\nhexo init\n初始化 hexo 目录\n\n\nhexo new &quot;postName&quot;\n新建文章\n\n\nhexo new page &quot;pageName&quot;\n新建页面\n\n\nhexo gernerate\n生成网页\n\n\nhexo server\n本地预览\n\n\nhexo deploy &#x2F; hexo d\n部署到远程服务器\n\n\nhexo clean\n清除缓存 建议每次执行命令前先清理缓存\n\n\nhexo clean &amp;&amp; hexo g &amp;&amp; hexo s\n一键生成部署\n\n\nhexo clean ; hexo g ; hexo s\n一键生成部署\n\n\nhexo 主题下面是我搜集的一些主题及其项目开源地址:\n\nGal\nIndigo\nSpfk\nSmackdown\nBlack-blue\nShana\nYilia\nWinterland\nOKCjs\nAnimaStars\nConey\nKiddochan\nLandscapeplus\nNexT\nHexo Themes Net\n\n警告与错误的处理Warning: LF will be replaced by CRLF问题原因: 不同操作系统所使用的换行符是不一样的:\n\nUnix &#x2F; Linux 采用换行符 LF 表示下一行 (LF: LineFeed 换行)\n\nDos &#x2F; Windows 采用 回车 + 换行 CRLF 表示下一行 (CRLF: CarriageReturn LineFeed 回车换行)\n\nMac OS 采用回车 CR 表示下一行 (CR: CarriageReturn 回车)\n\n\n在 Git 中, 可以通过以下命令来显示当前你的 Git 中采取哪种对待换行符的方式:\ngit config core.autocrlf\n此命令会有三种输出: true, false, input\n\ntrue: Git 会将你 add 的所有文件视为文本文件, 将结尾的 CRLF 转换为 LF, 而 checkout 时会再将文件的 LF 格式转为 CRLF 格式.\n\nfalse: line endings 不做任何改变, 文本文件保持其原来的样子.\n\ninput: add 时 Git 会把 CRLF 转换为 LF, 而 check 时仍旧为 LF, 所以 Windows 操作系统不建议设置此值.\n\n\n解决办法: 将 core.autocrlf 设为 false 即可解决这个问题, 不过如果你跨平台工作的话, 还是需要考虑一下.\n如果你想要将 core autocrlf 设置为 true , 有一个需要慎重的地方, 当你上传一个二进制文件, Git 可能会将二进制文件误以为是文本文件, 从而也会修改你的二进制文件, 从而产生隐患.\n如果你不跨平台的话, 进行如下设置即可: git config --global core.autocrlf false\nError: validation failed原因: issue 的 id 有长度限制! 最大长度限制是 50 个字符.\n每个 issue 有两个标签, 一个是 gitment, 另一个是 id. 将 id 进行如下配置: id: &#39;&lt;%= page.date %&gt;&#39;, 因为日期是永远不会超出 50 个字符的.\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"Hexo 3.9.0 + NexT 7.2.0 => Hexo 5.1.0 + NexT 8.0.0","url":"/hexo/hexo_update.html","content":"\n\n🌈惨案一个 Warning 引发的惨案!\n升级方式全新安装, 因为我不会升级啊~~😂\n安装 Git进入 Git 官方网站 下载安装.\n可以使用 git --version 进行验证, 出现版本号就说明成功了.\n安装 Nodejs进入 Nodejs 官方网站 下载安装.\n尽量选择安装长期支持版本 (LTS), 最新发布版可能会有警告, 甚至有错误发生!\n可以使用 node -v 和 npm -v 进行验证, 出现版本号就说明成功了.\n安装 Hexo安装 Hexo 之前, 设置 Hexo 的安装位置. 具体见我的另一篇博客: Hexo + Github Pages 搭建个人博客 这里不再赘述!\n安装 Hexo: npm install hexo-cli -g\n创建本地博客\n   新建文件夹, 放置本地博客, 名称随意. F:\\WorkSpace\\Hexo\n\n   初始化本地博客, 在 Git Bash Here 中输入: hexo init\n\n\n[注] 此步骤需要耗费较长一段时间, 我大概用了 25 分钟! 慢慢等吧!\n\nhexo init 是这次升级遇到的第一个大坑, 忘记了这个要执行好长一段时间, 好几次自己等不耐烦了, 直接 Ctrl + C 了! 😂\n\n\n   安装默认依赖包, 在 Git Bash Here 中输入: npm install\n\n[注] 在上一步中大部分的依赖其实已经安装了, 这里只是安装一小部分, 所以很快!\n\n   生成静态文件, 在 Git Bash Here 中输入: hexo generate\n\n   开启服务, 在 Git Bash Here 中输入 hexo server\n\n\n部署 Hexo\n安装 Hexo deploy 插件, 在 Git Bash Here 中输入: npm install hexo-deployer-git --no-optional\n\n在站点配置文件中配置:\n\n\ndeploy:  type: git  repo: git@github.com:KurohaKirito/KurohaKirito.github.io.git  branch: master\n\n[注] repo 仓库的地址: 有 SSH 和 HTTPS 两种格式, 推荐选择 SSH 格式, 如果选择 Https 格式, 每次发布时都必须输入账号密码, 不嫌麻烦的可以用!\n安装 NexT 主题\n这里是第二个大坑, 最新版的 NexT 的仓库已经换地址了, 我还傻乎乎地用之前的地址, 唉...😔\n\n\n2014-2017 &#x3D;&gt; https://github.com/iissnan/hexo-theme-next\n\n2018-2019 &#x3D;&gt; https://github.com/theme-next/hexo-theme-next\n\n2020-2020 &#x3D;&gt; https://github.com/next-theme/hexo-theme-next\n\n\n\n新版的 NexT 推荐使用 npm install hexo-theme-next --no-optional 进行安装, 作为一个 node_module 存在! 安装之后路径为: node_module&#x2F;hexo-theme-next.\n\n\n新版的 NexT 推荐用户不要修改主题目录下的配置文件, 而是在站点根目录下新建一个 _config[.主题名称].yml 文件, 作为新的主题配置文件.\n\n\n可以先从 node_module&#x2F;hexo-theme-next 文件夹中复制一份配置文件出来, 然后按照规则重命名, 最后修改其中的设置即可!\n自定义站点配置文件主题修改 theme 的值为 next, 这里的名字要和之前新建主题配置文件时使用的名称一致!\n博客网址样式permalink: :title.html\n\n关闭 &quot;半角字符自动转换全角字符&quot;marked:  smartypants: false\n\n生成站点地图 (谷歌版)\n安装依赖 hexo-generator-sitemap, 命令: npm install hexo-generator-sitemap --no-optional, 之后生成网站时, 便会自动在根目录生成一个 sitemap.xml 文件!\n\n在 source 文件夹下新建文本文件: robots.txt, 并写入以下内容:\n\n\nUser-agent: *Disallow:Sitemap: https://kuroha.vip/sitemap.xml\n\n\n\nUser-agent : 定义以下配置对哪些搜索引擎生效.\n\n\n\nAllow : 允许抓取的内容.\n\n\n\nDisallow : 不允许抓取的内容.\n\n\n\nSitemap : 站点地图的存放地址.\n\n\n\n重新发布之后, 便可以将站点地图提交给 Google Search 了!\n自定义主题配置文件配置文件中只需要改改设置就可以出现效果的就不提了, 说一下注意事项:\n开启自定义配置取消自定义配置文件的注释, 并且要在对应的路径下创建对应的文件.\n开启标签, 分类, 关于菜单取消相应的设置选项后, 必须在 source 文件夹下创建相应的路径, 并创建相应的 markdown 文件, 文件中的内容虽然很简单, 但是也必须添加! comments : false 可以使当前页面禁用评论系统.\n分类---type: &quot;categories&quot;comments: false---\n\n标签---type: &quot;tags&quot;comments: false---\n\n设置 Favicon 图标在 favicon 属性后设置路径之后, 必须在相应的路径下创建图片, 否则找不到文件会报错! 设置侧边栏头像时同理.\n添加预计阅读时间功能需要安装依赖: hexo-word-counter\nnpm install hexo-word-counter --no-optional\n[注] 所有需要安装依赖才能出现效果的, 安装完依赖并设置好之后, 必须清理缓存重新生成才会生效!\n[注] 某些特效需要关闭新版 NexT 中的 Pjax\n关闭最受欢迎文章功能NexT 中有这么一个设置: related_posts, 可以当作 &quot;最近受欢迎的文章&quot;, &quot;相关博客&quot; 或者 &quot;推荐阅读&quot; 使用, 但是由于其依赖有点过时, 推荐关闭此功能!\n代码高亮风格设置如果使用 Prism 进行代码高亮渲染, 并且选择较高级的一些效果, 需要安装依赖.\nnpm install prism-themes --no-optional\n并且要在 站点配置文件 中将 highlight 设为 false, prismjs 设为 true.\nhighlight:  enable: false  line_number: true  auto_detect: false  tab_replace: &#x27;&#x27;  wrap: true  hljs: falseprismjs:  enable: true  preprocess: true  line_number: true  tab_replace: &#x27;&#x27;\n\n最后在 主题配置文件 的 prism 后设置使用的渲染风格.\n本地搜索需要安装依赖: hexo-generator-searchdb\nnpm install hexo-generator-searchdb --no-optional\n音乐播放器 APlayer\nAPlayer 源码地址: APlayer\n\n新建目录: source/js/aplayer, 下载并解压源码, 将 dist 文件夹中的四个文件复制到 source/js/aplayer 中.\n返回 source/js 文件夹, 新建一个 fixedAplayer.js 文件, 输入以下代码:\nconst ap = new APlayer(&#123;    container: document.getElementById(&#x27;aplayer&#x27;),    fixed: true,    autoplay: false,    audio: [      &#123;        name: &#x27;歌曲的名字&#x27;,        artist: &#x27;歌手&#x27;,        url: &#x27;音乐文件的地址&#x27;,        cover: &#x27;封面图片的地址&#x27;,      &#125;    ]&#125;);\n\n之后在 source/_data/body-end.njk 中添加:\n&lt;!--APlayer 吸底式音乐播放功能--&gt;&#123;% if theme.aplayer_fixed %&#125;    &lt;link rel=&quot;stylesheet&quot; href=&quot;/js/aplayer/APlayer.min.css&quot;&gt;    &lt;div id=&quot;aplayer&quot;&gt;&lt;/div&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;/js/aplayer/APlayer.min.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;/js/fixedAplayer.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125;\n\n最后在 主题配置文件 中写入 aplayer_fixed: true.\n视频播放器 DPlayer\nDPlayer 源码地址: DPlayer\n\n新建目录: source/js/dplayer, 下载并解压源码, 将 dist 文件夹中的四个文件复制到 source/js/dplayer 中.\n在待添加视频博客的所需位置中添加以下代码:\n&lt;div id=&quot;dplayer&quot;&gt;&lt;/div&gt;&lt;script src=&quot;/js/dplayer/DPlayer.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt;const dp_update = new DPlayer(&#123;    container: document.getElementById(&#x27;dplayer&#x27;),    screenshot: true,    video:    &#123;        url: &#x27;/video/hexo_update/hexo_update.mp4&#x27;, //视频文件        pic: &#x27;/video/hexo_update/hexo_update.jpg&#x27;, //视频封面    &#125;,&#125;);&lt;/script&gt;\n\n自定义单行代码段样式打开 source/_data/styles.styl 文件, 添加对 Code 标签的自定义配置即可. 下面是我博客使用的配置.\n// 单行代码块code &#123;    font-size: 20px;    // color: #978665;    // background: #3B3C3E;    color: #c71585;    background: #fffafa;    // border: 1px solid #000000; // 边框    // border-radius: 4px; // 边框圆角    word-break: break-word; // 换行方式    padding: 2px 4px; // 占位扩充 (高度, 宽度)    margin: 0px; // 左右间隔&#125;\n\n自定义鼠标样式打开 source/_data/styles.styl 文件, 添加自定义配置.\n// 鼠标样式, 格式: *.ani (动态), *.cur (静态)body &#123;    cursor: url(&#x27;/cursor/arrow.cur&#x27;), default;&#125;a:link &#123;    cursor: url(&#x27;/cursor/link.cur&#x27;), pointer;&#125;a:hover &#123;    cursor: url(&#x27;/cursor/link.cur&#x27;), pointer;&#125;a:visited &#123;    cursor: url(&#x27;/cursor/arrow.cur&#x27;),&#125;a:active &#123;    cursor: url(&#x27;/cursor/arrow.cur&#x27;),&#125;\n\n自定义字体打开 source/_data/variables.styl 文件, 添加自定义配置. 参考: Hexo NexT 主题的字体更换\n// $font-family-chinese 负责调控中文字体, 但优先级最低$font-family-chinese = &quot;Noto Serif SC&quot;, &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;;// $font-family-base 负责调控全局字体, 主要是不被下面几类包括的文字$font-family-base = $font-family-chinese, sans-serif;$font-family-base = get_font_family(&#x27;global&#x27;), $font-family-chinese, sans-serif if get_font_family(&#x27;global&#x27;);// $font-family-logo 负责调控网站标题的字体$font-family-logo = $font-family-base;$font-family-logo = get_font_family(&#x27;title&#x27;), $font-family-base if get_font_family(&#x27;title&#x27;);// $font-family-headings 负责调控 h1-h6 的字体, 包括标题与文中小标题$font-family-headings = $font-family-base;$font-family-headings = get_font_family(&#x27;headings&#x27;), $font-family-base if get_font_family(&#x27;headings&#x27;);// $font-family-posts 负责调控正文字体$font-family-posts = $font-family-base;$font-family-posts = get_font_family(&#x27;posts&#x27;), $font-family-base if get_font_family(&#x27;posts&#x27;);// $font-family-monospace 负责调控代码块的字体$font-family-monospace = consolas, Menlo, monospace, $font-family-chinese;$font-family-monospace = get_font_family(&#x27;codes&#x27;), consolas, Menlo, monospace, $font-family-chinese if get_font_family(&#x27;codes&#x27;);\n\n添加捉小猫游戏\n下载捉小猫游戏源文件并解压, 之后将解压好的文件夹 source 和博客目录下的 source 文件夹合并. Catch The Cat\n\n在主题配置文件的 menu 处添加新菜单项: 捉小猫! 仅需两步, 大功告成!\n\n\nmenu:  捉小猫: /catch_the_cat/ || fa fa-cat\n\n鼠标右键菜单 GalMenu\n下载 GalMenu 源文件并解压, 之后将解压好的文件夹 galmenu 放到博客的 source/js 文件夹下. GalMenu 下载链接 解压密码是本网站首页地址\n\n在主题配置文件 _config.next.yml 中添加配置.\n\n\ngalmenu:  enable: true # 动漫菜单  audio: true # 菜单音效\n\n\n在 source/_data/body-end.njk 文件中添加配置.\n [注] 在这里可以自定义菜单项名称, 而且在 audio 标签中可以自定义音效文件名称, 建议不要修改路径. 修改名称后记得一定要在 source/js/galmenu/audio 文件夹中放入自定义的音效资源.\n\n\n&lt;!--动漫菜单--&gt;&#123;% if theme.galmenu.enable %&#125;    &lt;div class=&quot;GalMenu GalDropDown&quot;&gt;        &lt;div class=&quot;circle&quot; id=&quot;gal&quot;&gt;            &lt;div class=&quot;ring&quot;&gt;                &lt;a href=&quot;/&quot; class=&quot;menuItem&quot;&gt;首页&lt;/a&gt;                &lt;a href=&quot;javascript:history.go(1);&quot; class=&quot;menuItem&quot;&gt;前进&lt;/a&gt;                &lt;a href=&quot;javascript:$(&#x27;html,body&#x27;).animate(&#123;scrollTop:0&#125;,500);&quot; class=&quot;menuItem&quot;&gt;顶部&lt;/a&gt;                &lt;a href=&quot;javascript:location.reload();&quot; class=&quot;menuItem&quot;&gt;刷新&lt;/a&gt;                &lt;a href=&quot;/about/&quot; class=&quot;menuItem&quot;&gt;留言&lt;/a&gt;                &lt;a href=&quot;javascript:history.go(-1);&quot; class=&quot;menuItem&quot;&gt;后退&lt;/a&gt;            &lt;/div&gt;            &#123;% if theme.galmenu.audio %&#125;                &lt;audio id=&quot;audio&quot; src=&quot;../js/galmenu/audio/sao-menu.wav&quot;&gt;&lt;/audio&gt;            &#123;% endif %&#125;        &lt;/div&gt;    &lt;/div&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        var items = document.querySelectorAll(&#x27;.menuItem&#x27;);        for (var i = 0, l = items.length; i &lt; l; i++) &#123;            items[i].style.left = (50 - 35 * Math.cos(- 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + &quot;%&quot;;            items[i].style.top = (50 + 35 * Math.sin(- 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + &quot;%&quot;        &#125;    &lt;/script&gt;    &lt;script&gt;        window.jQuery || document.write(&#x27;&lt;script src=&quot;../js/galmenu/js/jquery.min.js&quot;&gt;&lt;\\/script&gt;&#x27;)    &lt;/script&gt;    &lt;script src=&quot;../js/galmenu/js/GalMenu.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        $(document).ready(function () &#123;            $(&#x27;body&#x27;).GalMenu(&#123;&#x27;menu&#x27;: &#x27;GalDropDown&#x27;&#125;)        &#125;);    &lt;/script&gt;&#123;% endif %&#125;\n\n\n在 source/_data/head.njk 文件内添加 CSS 引用.\n [注] 在这个 CSS 文件中可以修改菜单图片的文件名, 建议不要修改路径. 修改名称后记得一定要在 source/js/galmenu/img 文件夹中放入自定义的图片资源.\n\n\n&lt;!--动漫菜单--&gt;&#123;% if theme.galmenu.enable %&#125;    &lt;link rel=&quot;stylesheet&quot; href=&quot;../js/galmenu/css/GalMenu.css&quot;&gt;&#123;% endif %&#125;\n\n至此大功告成!\n鼠标单击之心形图案特效在 source/js 下创建 love.js 文件, 内容具体见我的另一篇博客: Hexo + NexT 主题美化 (NexT v7.2.0) 这里不再赘述!\n之后在 source/_data/body-end.njk 中添加:\n&lt;!--心形图案效果--&gt;&#123;% if theme.love %&#125;  &lt;script type=&quot;text/javascript&quot; src=&quot;/js/love.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125;\n\n最后在 主题配置文件 中写入 love: true.\n鼠标单击之烟花爆炸特效\n下载 fireworks.js 文件到 source/js 文件夹下\n\n在 source/_data/body-end.njk 中添加:\n\n\n&lt;!--烟花爆炸特效--&gt;&#123;% if theme.fireworks %&#125;    &lt;canvas class=&quot;fireworks&quot; style=&quot;position:fixed;left:0;top:0;z-index:99999999;pointer-events:none;&quot;&gt;&lt;/canvas&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;/js/fireworks.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125;\n\n\n在 主题配置文件 中写入 fireworks: true.\n\n下载地址: fireworks.7z, 解压密码是本网站首页地址\n[注] 都读到这里了, 我想你肯定早就知道了, 想要获取文章中提到的所有资源文件, 只要 F12 就可以了! 😂 当然我还是提供了下载地址的...\n页面标题欺诈在 source/js 下创建 crash_cheat.js 文件, 内容具体见我的另一篇博客: Hexo + NexT 主题美化 (NexT v7.2.0) 这里不再赘述!\n之后在 source/_data/body-end.njk 中添加:\n&lt;!--崩溃欺骗--&gt;&#123;% if theme.crashcheat %&#125;  &lt;script type=&quot;text/javascript&quot; src=&quot;/js/crash_cheat.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125;\n\n最后在 主题配置文件 中写入 crashcheat: true.\n球形标签云球形标签云其实就是用这个插件 TagCanvas 实现的, 点击进入官网.\n进入官网后下载 tagcanvas.js 文件, 也可以直接在左面我给出的链接那里 &quot;右键 &#x3D;&gt; 链接另存为&quot;, 保存到: source\\js 目录下. 需要的就是这一个 tagcanvas.js 文件!\n打开 source/js 文件夹中再新建一个 tagcloud.js 文件, 写入以下内容:\nwindow.onload = function () &#123;    try &#123;        TagCanvas.Start(&#x27;my3DTags&#x27;, &#x27;tags&#x27;,            &#123;                textFont: &#x27;Georgia,Optima&#x27;,                textColour: null,                outlineColour: &#x27;black&#x27;,                weight: true,                reverse: true,                depth: 0.8,                maxSpeed: 0.05,                bgRadius: 1,                freezeDecel: true            &#125;);    &#125;    catch (e) &#123;        document            .getElementById(&#x27;myTags&#x27;)            .style            .display = &#x27;none&#x27;;    &#125;&#125;;\n\n[题外话] 新版的 NexT 推荐用户不要再修改主题目录中的任何文件, 虽然我是一个前端纯小白, 但是我也在尽力去遵守这条约定, 但是我发现如果我想要实现这个标签云, 就必须修改主题目录中的文件! 如果有人知道可以不修改主题目录中的文件便可以实现相同的效果, 请务必告知, 十分感谢!\n打开文件 node_modules\\hexo-theme-next\\layout\\page.njk, 在这个 &lt;div class=&quot;tag-cloud-tags&quot;&gt; 的前面加上如下代码:\n&#123;# 球形云标签 #&#125;&lt;div class=&quot;tags&quot; id=&quot;myTags&quot;&gt;  &lt;canvas width=&quot;720&quot; height=&quot;720&quot; id=&quot;my3DTags&quot;&gt;  &lt;/canvas&gt;&lt;/div&gt;&lt;div class=&quot;tags&quot; id=&quot;tags&quot;&gt;  &lt;ul style=&quot;display: none&quot;&gt;    &#123;&#123; tagcloud(&#123;        min_font   : 16,        max_font   : 35,        amount     : 999,        color      : true,        start_color: &#x27;black&#x27;,        end_color  : &#x27;green&#x27;      &#125;)    &#125;&#125;  &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/tagcanvas.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/tagcloud.js&quot;&gt;&lt;/script&gt;&#123;# 普通云标签 #&#125;\n\n最后在 主题配置文件 中写入 crashcheat: true.tagcanvas: true.\n\n[注] 球形标签云也可以使用 Hexo 的插件 hexo-tag-cloud 来实现, 其实最终都是依赖于 tagcanvas.js 文件的, 而且我尝试  hexo-tag-cloud 后发现我不会改效果...😂 所以还是用了之前的老方法!\n另外, 执行上面的操作后, 球形标签云和普通标签云是同时存在的, 如果只想要显示球形标签云, 把后面那个 普通云标签 的 div 标签注释掉就行了. 就像这样:\n\n&#123;# 普通云标签 #&#125;&#123;# &lt;div class=&quot;tag-cloud-tags&quot;&gt;    &#123;&#123; tagcloud(&#123;      min_font: theme.tagcloud.min,      max_font: theme.tagcloud.max,      amount  : theme.tagcloud.amount,      orderby : theme.tagcloud.orderby,      order   : theme.tagcloud.order,      class   : &#x27;tag-cloud&#x27;      &#125;)    &#125;&#125;  &lt;/div&gt; #&#125;\n\n[注] 如果使用的是 NexT 8.2.2 版本是找不到 node_modules\\hexo-theme-next\\layout\\page.njk 文件的, 而是需要修改 node_modules\\hexo-theme-next\\layout\\_partials\\page\\tags.njk 文件, 将此文件中的内容全部修改为:\n&lt;div class=&quot;tag-cloud&quot;&gt;  &lt;div class=&quot;tag-cloud-title&quot;&gt;    &#123;&#123; _p(&#x27;counter.tag_cloud&#x27;, site.tags.length) &#125;&#125;  &lt;/div&gt;  &#123;# 球形云标签 #&#125;  &lt;div class=&quot;tags&quot; id=&quot;myTags&quot;&gt;    &lt;canvas width=&quot;720&quot; height=&quot;720&quot; id=&quot;my3DTags&quot; style=&quot;display: block;margin: 0 auto;&quot;&gt;    &lt;/canvas&gt;  &lt;/div&gt;  &lt;div class=&quot;tags&quot; id=&quot;tags&quot;&gt;    &lt;ul style=&quot;display: none&quot;&gt;      &#123;&#123; tagcloud(&#123;          min_font   : 16,          max_font   : 35,          amount     : 999,          color      : true,          start_color: &#x27;black&#x27;,          end_color  : &#x27;green&#x27;        &#125;)      &#125;&#125;    &lt;/ul&gt;  &lt;/div&gt;  &lt;script type=&quot;text/javascript&quot; src=&quot;/js/tagcanvas.js&quot;&gt;&lt;/script&gt;  &lt;script type=&quot;text/javascript&quot; src=&quot;/js/tagcloud.js&quot;&gt;&lt;/script&gt;  &#123;# 球形云标签 #&#125;  &lt;div class=&quot;tag-cloud-tags&quot;&gt;    &#123;&#123; tagcloud(&#123;      min_font: theme.tagcloud.min,      max_font: theme.tagcloud.max,      amount  : theme.tagcloud.amount,      orderby : theme.tagcloud.orderby,      order   : theme.tagcloud.order,      class   : &#x27;tag-cloud&#x27;      &#125;)    &#125;&#125;  &lt;/div&gt;&lt;/div&gt;\n\n粒子时钟下载文件 clock.js, 可以直接在链接上 &quot;右键 &#x3D;&gt; 链接另存为&quot;, 放到 source/js/ 路径下.\n之后在 source/_data/sidebar.njk 中添加:\n&#123;# 粒子时钟 #&#125;&#123;% if theme.clock %&#125;    &lt;div&gt;        &lt;canvas id=&quot;canvasDiyBlock&quot; style=&quot;width:60%;&quot;&gt;您的浏览器不支持 Canvas, 请更换浏览器!&lt;/canvas&gt;        &lt;script type=&quot;text/javascript&quot; src=&quot;/js/clock.js&quot;&gt;&lt;/script&gt;    &lt;/div&gt;&#123;% endif %&#125;\n\n最后在 主题配置文件 中写入 clock: true.\n站点运行时间下载文件 website_runtime.js, 可以直接在链接上 &quot;右键 &#x3D;&gt; 链接另存为&quot;, 放到 source/js/ 路径下.\n之后在 source/_data/footer.njk 中添加:\n&#123;# 站点已运行时间 #&#125;&#123;% if theme.websiteruntime %&#125;    &lt;div id=&quot;days&quot;&gt;&lt;/div&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;/js/website_runtime.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125;\n\n最后在 主题配置文件 中写入 websiteruntime: true.\n萌萌的看板娘\n第一种: hexo-helper-live2d 优点: 有声音, 缺点: 无法换装, 无法换模型, 响应事件少.\n\n使用方法见官方网址: hexo-helper-live2d\n\n第二种: live2d-widget 优点: 能换装, 能切换模型, 响应事件多, 缺点: 无声音, 配置较复杂. (现在可能已经有声音了)\n\n使用方法见官方网址: live2d-widget\n\n第三种: live2d_demo 优点: 能换装, 能切换模型, 响应事件多, 缺点: 无声音, 配置较复杂. (现在可能已经有声音了)\n\n使用方法见官方网址: live2d_demo\n我是用的是第 3 种 live2d_demo\n\n下载 live2d_demo: live2d_demo, 解压密码是本网站首页地址\n\n解压之后放到 source/js/ 目录下, 完成这一步之后, 在 source/js/live2d_demo/ 目录下应该有 9 个文件.\n\n在 source/_data/body-end.njk 文件的最后添加:\n\n\n  &lt;!--萌萌看板娘--&gt;&#123;% if theme.live2d_demo %&#125;    &lt;script type=&quot;text/javascript&quot; src=&quot;/js/live2d_demo/jquery-ui.js&quot;&gt;&lt;/script&gt;&lt;!-- 实现拖动效果，需引入 JQuery UI --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;/js/live2d_demo/autoload.js&quot;&gt;&lt;/script&gt;&lt;!-- 使用 autoload.js 自动引入看板娘 --&gt;&#123;% endif %&#125;\n\n\n最后在 主题配置文件 中写入 live2d_demo: true, 启用看板娘!\n\n[注]\n\n要定制自己的看板娘, 可以修改 autoload.js 中的参数配置, 还可以在 waifu-tips.json 中修改对话, 这两处的配置足够定制自己独特的看板娘了!\n\n经过以上操作如果还是不能达到效果, 请检查 autoload.js 中的路径设置是否正确! (虽然我已经配置好了, 可以直接拿来用, 不过既然出问题了, 就自己检查一下吧!)\n\n\naplayer 音乐效果展示\n\n\n\n\nconst aplayer_update = new APlayer(\n{\n  container: document.getElementById('aplayer_update'),\n  //fixed: true, // 吸底模式\n  //mini: false, // 迷你模式\n  autoplay: false, //自动播放\n  theme: 'red', //主题色\n  loop: 'all', //循环模式: all one none\n  order: 'list', //循环顺序: list random\n  preload: 'none', //预加载: auto none metadata\n  volume: 0.7, //音量设置 会导致用户设置的自定义音量失效\n  //customAudioType: mysudio, //自定义音乐类型\n  mutex: true, //播放器之间互斥 当一个在播放时 暂停其他所有播放器\n  //lrcType: 3, //歌词类型\n  listFolded: false, //false: 列表默认展开 true: 列表默认折叠\n  listMaxHeight: 90, //列表最大数目\n  audio:\n  [\n    {\n      name: '绯色之空', //歌曲名\n      artist: '川田真美', //演唱者\n      url: 'https://od.lk/s/NzNfMjUyMzcyNzVf/%E7%B7%8B%E8%89%B2%E3%81%AE%E7%A9%BA.mp3', //音乐文件\n      cover: 'https://od.lk/s/NzNfMjUyMzcyODFf/%E7%B7%8B%E8%89%B2%E3%81%AE%E7%A9%BA.jpg', //音乐封面\n    },\n    {\n      name: '光るなら', //歌曲名\n      artist: 'Goose house', //演唱者\n      url: 'https://od.lk/s/NzNfMjUyMzcyNzdf/%E5%85%89%E3%82%8B%E3%81%AA%E3%82%89.mp3', //音乐文件\n      cover: 'https://od.lk/s/NzNfMjUyMzcyNzhf/%E5%85%89%E3%82%8B%E3%81%AA%E3%82%89.jpg', //音乐封面\n    },\n  ]\n});\n\n\ndplayer 视频效果展示\n\n\n\nconst dp_update = new DPlayer({\n    container: document.getElementById('dplayer'),\n    screenshot: true,\n    video:\n    {\n        url: '/video/hexo_update.mp4',\n        pic: '/video/hexo_update.jpg',\n        //thumbnails: 'thumbnails.jpg',\n    },\n    // 外挂字幕\n    // subtitle: {\n    //     url: 'webvtt.vtt',\n    // },\n    // 弹幕\n    // danmaku: {\n    //     id: 'demo',\n    //     api: 'https://api.prprpr.me/dplayer/',\n    // },\n});\n\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"Hexo + NexT 主题美化 (NexT v7.2.0)","url":"/hexo/next_theme_beautify.html","content":"\n博主的金玉良言: 关于博客的样式, 自己感觉差不多就行了, 这真的是一个无底洞! 尤其是当你像我一样有强迫症的时候, 这也想要, 那也想要, 哇, 那滋味, 别提多酸爽了!\n\n\n\n更换主题说实话, 默认的 Hexo 主题我认为不好看, 所以我就上网搜索 Hexo 好看的主题, 最后发现, 最受欢迎的, 也是用的人最多的就是 NexT 主题了. 但是我想了一下, 既然用的人最多, 那么撞车的几率不就很高吗, 那样就没有 独一无二 的感觉了, 所以我坚决不用! ~~真香! ~~\n其实用 NexT 主题是有很大的一个优势的, 因为用户多, 所以教程资料好找啊, 一找一大片, 不像我之前用的 Shana 和 Gal 主题, 教程? 不存在的!\n在 NexT 项目地址 2018 处可以找到 NexT 主题. hexo-theme-next 就是主题项目, 其他的是 NexT 主题的插件项目. 进入 hexo-theme-next 项目, 里面详细说明了如何安装, 启用主题, 这里不再赘述.\nNexT 项目地址\n2014-2017 https://github.com/iissnan/hexo-theme-next\n\n2018-2019 https://github.com/theme-next/hexo-theme-next\n\n2020-NOW https://github.com/next-theme/hexo-theme-next\n\n\n\n注 我在使用 NexT 主题之前, 也使用过几个其他的主题, 在这里也和小伙伴们说一下, 都是比较偏二次元风的, 毕竟我的网站名就是 &quot;二次元游宅客&quot; 嘛, 不过最后还是觉得太花里胡哨不好, 眼睛疼!\n\n萌娘 Gal\n灼眼的夏娜 Shana\n埃罗芒阿老师 Sagiri\n\n\n知识预备Hexo 博客的配置文件有两个, 站点配置文件 和 主题配置文件, 站点配置文件在博客根目录中\nF:\\WorkSpace\\HexoBlog\\_config.yml\n主题配置文件在相应的主题文件夹中\nF:\\WorkSpace\\HexoBlog\\themes\\next\\_config.yml\n自定义站点配置文件我们之前创建的本地博客只有一个空的模板, 还没有进行自定义, 下面我们来设置一下我们博客的标题, 副标题, 描述等等.\n打开本地博客根目录下的 _config.yml 文件, 这个文件就是网站的配置文件.\n下面是基础设置的介绍:\n\n\n\n属性\n含义\n本人设置\n\n\n\nTitle\n网站标题\n二次元游宅客\n\n\nSubtitle\n网站副标题\nSword Art Online\n\n\nDescription\n网站描述\n一个热爱二次元和游戏开发的宅极客!\n\n\nAuthor\n您的昵称\nKuroha\n\n\nLanguage\n网站语言\nzh-CN\n\n\nTimezone\n网站时区\n\n\n\n\nTimezone: 留空的话, Hexo 会使用本地电脑的时区和时区列表.\nDescription: 用于 SEO（搜索引擎优化）, 告诉搜索引擎一个关于你博客的简单描述, 通常建议在其中包含网站的关键词.\nAuthor: 显示博客中文章的作者.\n含义部分是常见的解释, 不同的博客主题或许会有不同的用法, 具体见你使用的网页主题的简介.\n\n根据自己的情况修改上面的设置即可.\n修改 theme的值为: next, 即可启用 NexT 主题. 前提是你已经安装了. ~~这不废话吗! ~~\n自定义主题配置文件其实默认的 NexT 主题就已经很漂亮了, 不过呢, 为了实现更好的效果, 下面我们就开始 NexT 主题的美化.\n开启自定义 swig 文件功能将 custom_file_path: 属性下面的值全部取消注释, 并且在网站根目录下的 source 文件夹中新建 _data 文件夹, 注意不是在主题根目录下的 source 文件夹中新建. 之后在 _data 文件夹中将对应的所有文件全部手动创建好(因为不会自动创建). 之后如果要自定义样式, 直接修改这些文件就行了.\n开启 RSS 订阅首先安装依赖: npm install --save hexo-generator-feed\n在主题配置文件中搜索 rss 设置为: rss: /atom.xml\n设置地址栏的 Favicon 图标在主题配置文件中, 搜索: favicon 属性, 修改为自定义值, 下面是我的设置:\nfavicon:  small: /images/sao-16x16.png  medium: /images/sao-32x32.png\n\n之后根据你的设置, 在主题的 Source&#x2F;images 文件夹中添加相应的文件即可.\n[注] 文件名和后缀要和配置文件中的保持一致\n博客网站页脚设置找到 footer 属性, 修改为自定义值, 下面是我的设置:\nfooter:  since: 2019  icon:    # 效果: 一颗跳动的小红心    name: heart    animated: true    color: &quot;#ff0000&quot;  copyright:    # 效果: 由 Hexo 强力驱动  powered:    enable: true    version: true  theme:    # 效果: 主题-NexT    enable: true    version: true  beian:    # 效果: 显示备案    enable: false    icp:\n\n在文章末尾添加创作协议在主题的配置文件中, 搜索: creative_commons, 修改为自定义值, 强烈建议修改前阅读: 知识共享许可 , 下面是我的配置, 建议使用 by-nc-sa\ncreative_commons:  license: by-nc-sa  sidebar: false  post: true  language:\n\n添加 Github 快捷关注在主题的配置文件中, 搜索: github_banner, 修改为自定义值, 如下:\ngithub_banner:  enable: true  permalink: https://github.com/KurohaKirito  title: Follow me on GitHub\n\n添加社交链接在主题的配置文件中, 搜索: social, 修改为自定义值, 如下:\nsocial:  Telegram: https://t.me/****** || telegram  Steam: https://steamcommunity.com/profiles/******/ || steam  E-Mail: mailto:******@***.com || envelope  GitHub: https://github.com/****** || githubsocial_icons:  enable: true # 是否显示社交链接的图标  icons_only: false # 是否仅显示图标  transition: false\n\n**transition: false 说实话, 这个设置我也不知道有什么用! 有知道的请务必告知, 感谢! **\n添加友情链接在主题配置文件中搜索: links_icon, 修改为自定义值, 如下:\nlinks_icon: linklinks_title: 友情链接links_layout: inlinelinks:  ShyArcher: https://shyarcher.github.io/  Noah: https://noahapps.github.io/\n\n注: 这个地方也可以作为 &quot;推荐阅读&quot; 功能使用.\n网站头像设置在主题配置文件中, 搜索: avatar, 修改为自定义值, 如下:\navatar:  url: /images/sao-avatar.png # 头像路径  rounded: false # 头像是否显示为圆形  rotated: true # 鼠标经过头像时, 头像是否旋转\n\n给文章添加目录在主题配置文件中搜索: toc, 修改为自定义值, 如下:\ntoc:  enable: true  number: true # 是否自动编号  wrap: true # 标题过长时, 是否换行, 建议开启, 不换行的话有些字就看不见了  expand_all: true # 标题是否完全展开  max_depth: 10 # 标题最大级数\n\n注: wrap 属性还是要解释一下, wrap 设置为 true, 那么当标题过长时, 在目录那里会进行自动换行, 但是如果设置为 false, 那么过长的部分就会用 ... 省略掉! 所以还是设置为 true 吧.\n侧边栏属性设置在主题配置文件中搜索: sidebar, 修改为自定义值, 如下:\nsidebar:  position: left # 侧边栏显示在左边还是右边  width: 280 # 侧边栏宽度  display: post # 侧边栏显示模式, 只有在&quot;Muse&quot;和&quot;Mist&quot;风格下有效  offset: 10 # 侧边栏和文章页面之间的间隙, 只有在&quot;Pisces&quot;和&quot;Gemini&quot;风格下有效  onmobile: true # 是否在手机页面上显示, 只有在&quot;Muse&quot;和&quot;Mist&quot;风格下有效\n\n阅读进度百分比显示在主题配置文件中搜索: back2top, 修改为自定义值, 如下:\nback2top:  enable: true  sidebar: true # true: 将按钮显示在侧边栏, false: 将按钮显示在左下角或者右下角, 取决于侧边栏的位置  scrollpercent: true # 是否显示百分比\n\n添加预计阅读时间功能NexT 主题默认没有安装这个功能所需的依赖, 所以我们要先安装依赖: hexo-symbols-count-time\n安装方法 Github 上已经说得很明白了, 这里不再赘述.\n在主题配置文件中搜索: symbols_count_time 修改为自定义值, 如下:\nsymbols_count_time:  separated_meta: true  item_text_post: true  item_text_total: false  awl: 4  wpm: 275  suffix: mins.\n\n文章底部标签前添加图标在主题的配置文件中搜索: tag_icon 设置为 true\ntag_icon: true\n~~话说, 之前版本总是没有这个设置好吧, 每次都要自己添加, 哼! ~~ 这个版本终于有了!\n在文章底部添加打赏在主题的配置文件中搜索: reward_settings 修改为自定义值, 如下:\nreward_settings:  enable: true  animation: false # 关闭抖动动画  comment: 您的支持将鼓励我继续创作!reward:  alipay: /images/alipay.png\n\n添加最受欢迎文章功能也可以作为 推荐阅读 功能使用.\nNexT 主题默认没有安装这个功能所需的依赖, 所以我们要先安装依赖: hexo-related-popular-posts\n安装方法 Github 上已经说得很明白了, 这里不再赘述.\n在主题的配置文件中搜索: related_posts 修改为自定义值, 如下:\nrelated_posts:  enable: true  title: 推荐阅读  display_in_home: false # 是否在首页摘要处显示  params:    maxCount: 5    PPMixingRate: 0.0    isDate: false # 是否显示日期    isImage: false # 是否显示图片    isExcerpt: false # 是否显示摘要\n\n代码高亮风格设置第一步: 在站点配置文件中搜索: highlight, 将 auto_detect 设置为 true, 如下:\nhighlight:  enable: true # 开启高亮  line_number: true # 开启标注行号  auto_detect: true # 开启自动检测  tab_replace:\n\n第二步: 在主题配置文件中搜索: codeblock 修改为自定义值, 如下:\ncodeblock:  highlight_theme: night eighties # 代码高亮风格  copy_button:    enable: true # 是否显示 &quot;复制&quot; 按钮    show_result: true # 是否显示 &quot;复制成功&quot;    style: mac # 代码框风格\n\n第三方服务设置NexT 主题支持很多第三方服务, 但是默认都没有安装相应的依赖, 所以大部分设置都要先安装相应的依赖才行.\n添加图片浏览功能NexT 主题默认没有安装这个功能所需的依赖, 所以我们要先安装依赖: theme-next-fancybox3\n在主题的配置文件中搜索: fancybox 修改为 true, 如下:\nfancybox: true\n下面是测试图片, 鼠标点击图片就会进入图片浏览模式.\n\n\n添加 lazyload (懒加载)Lazyload 能够让网页只加载在电脑屏幕显示范围内的图片, 让范围外的图片暂时不加载, 来加快网页加载速度.\nNexT 主题默认没有安装这个功能所需的依赖, 所以我们要先安装依赖: theme-next-lazyload\n在主题的配置文件中搜索: lazyload 修改为 true, 如下:\nlazyload: true\n添加阅读进度条还是老步骤, 安装依赖: theme-next-reading-progress\n在主题配置文件中搜索: reading_progress, 修改为自定义值, 如下:\nreading_progress:  enable: true  color: &quot;#37c6c0&quot; # 进度条颜色  height: 5px # 进度条宽度\n\n注 如果你部署后发现没有效果, 可以试试将宽度调整为 50px, 你就能看到效果了, 之后记得再将宽度改回去.\n添加评论系统NexT 支持很多第三方评论系统: Disqus, 畅言, Valine, LiveRe (来必力), Gitalk.\n\nDisqus: 不采用, 因为不支持 Markdown 啊喂! 这让人怎么优雅地发评论啊!\n\n\n畅言: 不采用, 因为需要 备案 啊喂! 我一个 &quot;个人博客网站&quot; 备啥案啊! 而且还要手机号验证! 喂! 我就不能匿名评论吗? 话说, 你怎么也不支持 Markdown 啊喂!\n\n\nLiveRe: 同样需要登陆啊喂! 我就不能匿名评论吗? 话说, 你好像也不支持 Markdown 啊喂!\n\n\nGitalk: 使用 issue 来实现评论功能, 话说我不推荐这种方式! 虽然它支持 Markdown.\n\n\nValine: **支持 Markdown ! ** **支持 Markdown ! ** **支持 Markdown ! ** **支持匿名! ** **支持匿名! ** **支持匿名! ** 也支持图片评论.\n\n所以我采用 Valine 作为我的评论系统.\nQ: Valine 支持图片? 我怎么没找到发图片的按钮? 博客主, 你这不骗人嘛!A: 大哥! Valine 不是支持 Markdown 嘛, 那你告诉我它不支持图片? 你就不能使用 Markdown 语法来显示图片吗? !\n\n想详细了解 Valine 的朋友们可以点击这里: Valine 中文官方文档 !\n在主题配置文件中搜索: valine 修改为自定义值, 如下:\nvaline:  enable: true  appid: ******  appkey: ******  notify: true # 谁得到新回复时, 谁就会有邮件提醒, 建议开启, 对博客主和来访者都有好处.  verify: true # 评论前是否有验证码验证.  placeholder: ヾﾉ≧∀≦)o来啊, 快活啊! # 评论框提示语句.  avatar: retro # 匿名评论者的用户头像.  guest_info: nick,mail,link # 用户选填信息: 昵称, 邮箱(要填写 Gravater 的账号邮箱地址), 个人网站地址.  pageSize: 10  language: zh-cn  visitor: false # 文章阅读数统计, 建议不要使用, 后面会使用不蒜子统计来实现文章阅读数统计功能.  comment_count: true # 评论数统计.\n\n\n获取上面代码所需的 appid 和 appkey\n\nValine 的评论数据其实是保存在 LeanCloud 上面的, 这里所需要的 appid 和 appkey 其实都是 LeanCloud 网站上的, 所以我们要先注册一个 LeanCloud 账号, 点击这里: LeanCloud 官网, 不过呢, 从 2019-07-15 开始就需要实名认证了, 这个比较烦, 不过没办法, 忍忍吧, 10 分钟左右就认证好了, 当然如果你脸黑 · · · 呃 · · · 就当我什么也没说!\nQ: 话说回来, 你怎么不早说需要实名认证啊!A: 如果我提前说了, 那你还会用 Valine 吗?\n\n完成实名认证之后, 就可以新建应用了, 名字呢无所谓, 也支持中文, 起一个你喜欢的名字吧!\n创建完应用之后, 点击应用右上角的 齿轮 标记, 进入设置页面, 再次点击左下角的 &quot;设置&quot;, 之后点击 &quot;应用 Key&quot;, 就会出现 App ID 和 App Key 了.\n然后填写到主题配置文件的相应位置就可以了, 是不是很简单? !\n\n2019-12-20 更新:\n\n所以我采用 Valine 作为我的评论系统.\n\nすみません, ほんどにすみません!\n今天我发现 Leancloud 的使用现在要绑定域名, 而绑定域名需要备案......(可是我真的不想备案啊~ 因为在我的心中网络世界是不同于现实世界的另一个新世界, 那里充满幻想, 充满热爱, 可以以自己最喜欢的样子去生活, 所以为什么我还要继续使用现实世界的身份啊? ) 所以经过综合考虑, 我换用了 Gitalk !\n\n使用 Gitalk 评论系统简介: Gitalk 是使用 Github 中的 Issues 功能实现的评论系统, 我之前之所以说不推荐使用这种方式, 是因为这种方式有滥用 Github 的嫌疑, 不过有人问过 Github 官方, 官方也回应了说这样不算违反用户协议, 就是说这样用官方也是默许的.\n\n首先去自己的 Github 上新建一个 Repository, 并开放 Issues 功能. (其实这个是默认开放的) 名字写一个自己比较容易记住的名字即可. 我起的名字是: MyBlogCommentSystem (感觉好中二)\n\n之后新建一个 Application, URL 就填写你的域名即可, 应用名称, 描述什么的按喜好填写.\n\n填写 Next 的主题配置文件, 下面是我的配置:\n\n\ngitalk:  enable: true  github_id: Github 用户 ID (注意大小写)  repo: 仓库名称 (注意大小写)  client_id: 之前创建的 Application Client ID  client_secret: 之前创建的 Application Client Secret  admin_user: Github 用户 ID (注意大小写)  distraction_free_mode: true  language:\n\n\n最后去每篇博客的评论区部分, 登录自己的 Github 账号来初始化 Issues 即可使用 Gitalk 评论系统.\n\n去掉侧边栏的虚线说到这个, 就得提到博客的 &quot;即时聊天功能&quot; 了, 我知道的有: DaoVoice, Tidio, Chatra 这三个. 点击即可进入官网.\n这三个我都用过, 不过就用了几天, &quot;高级版免费试用&quot; 还是有剩余时长的. 有一点点副作用, 就是博客加载时间会变长, 有卡顿感, 说到卡顿, 不得不说的就是这个项目了: live2d_demo (一个会说话, 会换装, 能拖动的看板娘). 由于我没有服务器哈, 没办法自己搭建 API 服务器, 就使用的原作者的 API 服务器, 但是你想嘛, 肯定有很多很多人都在用原作者的 API 服务器啊, 所以速度上嘛 · · · 唉, 别提了, **太慢了! ! ** 不过我还能接受, 因为 ~~~ 开源啊! ! ! 免费啊! ! ! 对吧? !\n我: 哎! 哎! 别打我! 我错了我错了!看板娘: 谁让你说我主人坏话的! 哼😕!\n\n咱们作为使用者(白嫖者), 要有良心的对吧? 感谢 fghrsh 大佬🙏!\n\n拓展: 和 看板娘 类似的还有一个, 叫做 伪春菜, 有兴趣的小伙伴可以自行搜索了解.\n\n哎, 刚才说到哪了? 因为这四者 (DaoVoice, Tidio, Chatra, live2d) 都会让博客的加载时间变长, 而且前三者是 **收费的! 收费的! 收费的! ** (我指的是高级版本, 基础版本都是免费的) 所以到底用还是不用, 就要看各位自己的判断了, 我推荐呢, 各位试用一下, 过过瘾就行了🤣! 感觉即时聊天还不如在简介或者关于页面挂上自己的 QQ, 微信, Telegram 来得实在.\n所以呢我并没有使用这个即时聊天功能, 侧边栏的聊天图标我也关闭显示了, 又因为我使用的是 Gemini 风格, 这就导致侧边栏处出现了 **一道虚线, 一道虚线! , 一道虚线! ! ** (终于说到重点了, 之前的废话全是说明这一条虚线出现的原因, 哈哈) 之所以我要强调, 是因为我可是连一丁点前端基础都没有啊! 这个东西折磨了我好久好久, 还好我也是一只程序猿, 耐心什么的, 还不跟玩似的!\n\n有想要添加  即时聊天功能 的小伙伴可以从目录那里找到相关部分说明的位置坐标, 精准定位.\n\n经过好长好长一段时间的折腾, 其实就是一个 F12 (原谅我真的一点前端知识都没有), 终于被我找到了解决办法:\n在 themes\\next\\source\\css\\_schemes\\Pisces\\_sidebar.styl 文件中, 搜索: feed-link, 可以找到如下代码:\n.feed-link, .chat &#123;  border-top: 1px dotted $grey-light;  border-bottom: 1px dotted $grey-light;  text-align: center;  ······  省略  ······\n\n其中的 border-top 和 border-bottom 就是虚线了, 将 1px 修改为 0px 就可以了, 这样虚线就消失了!\n随便建议大家把这个也改了:, 找到 themes\\next\\source\\css\\_common\\components\\sidebar\\sidebar-author-links.styl 搜索: links-of-author, 将 margin-top 修改为 0px 这样侧边栏社交链接上面的空隙就消失了!\n文章分享功能NexT 主题集成的分享有3种: Add-this, Likely, NeedMoreShare2\n\n\nadd-this: 不知道为什么, 在 NexT 7.2.0 版本中, 无论我怎么设置, 就是无效, 没有任何效果, F12 控制台也没有报任何错误! 很烦! 而且还要注册账号!\nLikely: 推荐使用, 因为可以分享 Telegram, 哈哈, 必须用啊! 不用注册账号!\nNeedMoreShare2: 不推荐, 它的样式我也不怎么喜欢, 弃用.\n\n\n在主题配置文件中搜索: likely 修改为自定义值, 如下:\nlikely:  enable: true  look: big  networks:    twitter: Tweeter    facebook: Facebook    linkedin: LinkedIn    telegram: Telegram    whatsapp: WhatApp\n\n搜索引擎收录先要判断一下自己的博客是否已经被百度谷歌等搜索引擎收录, 在搜索栏中按下面的格式输入: site:域名 比如我检测的时候就是这样写: site:kuroha.vip 如果能搜索到自己的博客网站, 就说明已经收录了, 相反就是没有收录. 话说, 一个新站, 一上来就被搜索引擎收录, 这可能吗?\n百度搜索大概 1 年前, 就是 2018 年, 那时候将网站提交到百度是不用注册一个叫做 &quot;熊掌ID&quot; 的东西的, 但是现在不行了, 百度强制用户只有绑定了 &quot;熊掌ID&quot; 之后, 才能开始使用站长之家, 否则什么功能也用不了, 你没看错, 什么也做不了! 所以我就去注册个 &quot;熊掌ID&quot; 试试, 然后我看到了这个: 🤔\n\n\n于是我默默地将鼠标移动到了浏览器的标签页上, 按下了鼠标中键! 拜拜了您嘞!\n如果有小伙伴就是想让百度收录自己的博客, 请参考: 栾铸显的博客\n谷歌搜索让谷歌搜索收录自己的博客就简单多了. 前提: 你能用 Google Search\n进入 Google 站点服务平台 , 注册登录, 点击 &quot;添加资源&quot;, 选择 &quot;网址前缀&quot;, 默认的验证方法是 &quot;HTML 文件&quot;, 这个方法不适用于解析网址. 比如我的域名 &quot;kuroha.vip&quot; 就是解析到 Github Pages 上的, 所以这个方法不适用, 而且我也不推荐用这个方法. 点击 &quot;HTML文件&quot; 这四个字的位置, 你会发现刚才的页面折叠起来了.  ~~因为我之前弄的时候就卡在这里了, 死活找不到其他方法在哪里. 笨, 没办法. ~~ 选择 &quot;HTML 标记&quot; 这个方法, 复制 content 后面的内容, 不要复制 引号. 之后打开主题配置文件, 搜索: google_site_verification, 将你刚才复制的一串字符粘贴上就可以了.\ngoogle_site_verification: xxxxxx99uVjXfXzFHr0M_2lKQ1z_jDOlFl4-6xxxxxx\n\n文章底部打分功能在主题配置文件中, 搜索: rating, 修改为自定义值, 如下:\nrating:  enable: true  id: *****  color: fc6423\n\n\n去这个网站注册账号, 填写网站信息, 获取 id.\n颜色可以自定义修改.\n个人建议这个功能可以弃用了, 因为访客想要给文章评分的话, 也是要注册账号并登陆的, 试想一下, 有哪个访客会为了打一个没有什么意义的评分而去注册账号呢?\n\n不蒜子统计在主题配置文件中, 搜索: busuanzi_count, 修改为自定义值, 如下:\nbusuanzi_count:  enable: true  total_visitors: true # 站点总访问人数  total_visitors_icon: user  total_views: true # 站点总浏览次数  total_views_icon: eye  post_views: true # 单篇博客浏览次数  post_views_icon: eye\n\n本地搜索功能本地搜索功能需要安装依赖: 这里! \n在主题配置文件中, 搜索: local_search, 修改为自定义值, 如下:\nlocal_search:  enable: true  trigger: auto  top_n_per_article: 1  unescape: false\n\n即时聊天功能Next 主题配置文件中直接支持的有 Chatra 和 Tidio, 两者的使用方法基本相同, 先到官网注册账号, 他们的官网分别是 Chatra 和 Tidio, 之后在他们的网站上填写上自己的网站信息, 聊天窗口的外观也可以自己定义.\n准备工作准备好了之后, 在账号设置中获取 id 和 Key, Chatra 中使用的标识码就做 id, Tidio 使用的标识码叫做 Key, 填写到主题配置文件中, 并将 enable 设置为 true 即可.\n博客背景动画效果在主题配置文件中, 搜索: canvas_nest, 修改为自定义值即可.\nNext 中自带三种背景动画, 下面是效果预览:\n\n\n\n下面是我的设置:\ncanvas_nest:  enable: false  onmobile: true  color: &quot;0,0,255&quot;  opacity: 0.5  zIndex: -1  count: 99three:  enable: false  delay: false  three_waves: true  canvas_lines: true  canvas_sphere: truecanvas_ribbon:  enable: true  size: 300  alpha: 0.6  zIndex: -1\n\n博客加载进度条在主题配置文件中, 搜索: pace, 修改为自定义值即可. 如果要用的话个人推荐 loading-bar 主题, 但是个人建议不要使用, 因为这样会给用户一种博客加载时间特别长, 博客很卡的感觉.\n这是我的配置: (很显然, 我已经禁用了)\npace:  enable: false  theme: loading-bar\n\n博客在加载的时候, 一般是先加载文章, 之后加载附加功能, 像: Live2D, 音乐播放器, 即时聊天服务等. 所以不使用进度条的话, 在加载完文章后, 访客就可以开始浏览文章了, 这时后台再继续默默加载附加功能. 但是进度条是在博客完全加载完成后才会消失的, 所以, 如果使用了进度条功能, 访客就要继续等待, 直到附加功能也完全加载完毕才能开始浏览博客......我想如果我是访客, 我直接就切换标签页, 去逛别人的博客去了.\n手动添加华丽效果看板娘 Live2D第一种: hexo-helper-live2d 优点: 有声音, 缺点: 无法换装, 无法换模型, 响应事件少.\n使用方法见官方网址: hexo-helper-live2d\n第二种: live2d-widget 优点: 能换装, 能切换模型, 响应事件多, 缺点: 无声音, 配置较复杂.  (现在可能已经有声音了)\n使用方法见官方网址: live2d-widget\n第三种: live2d_demo 优点: 能换装, 能切换模型, 响应事件多, 缺点: 无声音, 配置较复杂.  (现在可能已经有声音了)\n使用方法见官方网址: live2d_demo\n音乐播放器 Aplayer\nAplayer 源码地址: APlayer\n\n首先, 在 next/source/lib 目录下新建 aplayer 文件夹, 之后下载项目源码并解压, 将 APlayer.min.js 和 APlayer.min.css 文件复制到 next/source/lib/aplayer 中.\n再之后, 继续在当前目录下新建一个 music.js 文件, 输入以下代码:\nconst ap = new APlayer(&#123;    container: document.getElementById(&#x27;aplayer&#x27;),    fixed: true,    autoplay: false,    audio: [      &#123;        name: &#x27;歌曲的名字&#x27;,        artist: &#x27;歌手&#x27;,        url: &#x27;音乐文件的地址&#x27;,        cover: &#x27;封面图片的地址&#x27;,      &#125;    ]&#125;);\n\n之后修改 themes/next/layout/_layout.swing 在文件最后添加:\n&lt;!--Aplayer 音乐播放功能--&gt;&#123;% if theme.aplayer %&#125;  &lt;link rel=&quot;stylesheet&quot; href=&quot;/lib/aplayer/APlayer.min.css&quot;&gt;  &lt;div id=&quot;aplayer&quot;&gt;&lt;/div&gt;  &lt;script type=&quot;text/javascript&quot; src=&quot;/lib/aplayer/APlayer.min.js&quot;&gt;&lt;/script&gt;  &lt;script type=&quot;text/javascript&quot; src=&quot;/lib/aplayer/music.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125;\n\n最后在 主题配置文件 中, 找一个自己喜欢的位置, 写入 aplayer: true. 什么时候想要关闭这个功能了, 直接设置为 false 即可.\n鼠标红心效果在 themes/next/source/js/src 下创建 love.js 文件, 粘贴以下内容:\n!function (e, t, a)&#123;    function n()    &#123;        c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;), o(), r()    &#125;    function r()    &#123;        for (var e = 0; e &lt; d.length; e++)            d[e].alpha &lt;= 0 ? (t.body.removeChild(d[e].el), d.splice(e, 1)) : (d[e].y-- , d[e].scale += .004, d[e].alpha -= .013, d[e].el.style.cssText = &quot;left:&quot; + d[e].x + &quot;px;top:&quot; + d[e].y + &quot;px;opacity:&quot; + d[e].alpha + &quot;;transform:scale(&quot; + d[e].scale + &quot;,&quot; + d[e].scale + &quot;) rotate(45deg);background:&quot; + d[e].color + &quot;;z-index:99999&quot;);        requestAnimationFrame(r)    &#125;    function o()    &#123;        var t = &quot;function&quot; == typeof e.onclick &amp;&amp; e.onclick;        e.onclick = function (e)        &#123;            t &amp;&amp; t(), i(e)        &#125;    &#125;    function i(e)    &#123;        var a = t.createElement(&quot;div&quot;);        a.className = &quot;heart&quot;, d.push(&#123; el: a, x: e.clientX - 5, y: e.clientY - 5, scale: 1, alpha: 1, color: s() &#125;), t.body.appendChild(a)    &#125;    function c(e)    &#123;        var a = t.createElement(&quot;style&quot;);        a.type = &quot;text/css&quot;;        try        &#123;            a.appendChild(t.createTextNode(e))        &#125;        catch (t)        &#123;            a.styleSheet.cssText = e        &#125;        t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)    &#125;    function s()    &#123;        return &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot;    &#125;    var d = [];    e.requestAnimationFrame = function ()    &#123;        return e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || e.oRequestAnimationFrame || e.msRequestAnimationFrame || function (e) &#123; setTimeout(e, 1e3 / 60) &#125;    &#125;(), n()&#125;(window, document);\n\n之后修改 themes/next/layout/_layout.swing 在文件最后添加:\n&lt;!--页面点击小桃心--&gt;&#123;% if theme.love %&#125;  &lt;script type=&quot;text/javascript&quot; src=&quot;/js/love.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125;\n\n最后在 主题配置文件 中, 找一个自己喜欢的位置, 写入 love: true. 什么时候想要关闭这个功能了, 直接设置为 false 即可.\n页面标题欺诈在 themes/next/source/js/ 下创建 crash_cheat.js 文件, 粘贴以下内容:\n&lt;!--崩溃欺骗--&gt;var OriginTitle = document.title;var titleTime;document.addEventListener(&#x27;visibilitychange&#x27;, function () &#123;    if (document.hidden) &#123;        $(&#x27;[rel=&quot;shortcut icon&quot;]&#x27;).attr(&#x27;href&#x27;, &quot;/images/sao-16x16.png&quot;);        document.title = &#x27;😰 w(ﾟДﾟ)w 页面崩溃啦!  &#x27;;        clearTimeout(titleTime);    &#125;    else &#123;        $(&#x27;[rel=&quot;shortcut icon&quot;]&#x27;).attr(&#x27;href&#x27;, &quot;/images/sao-16x16.png&quot;);        document.title = &#x27;😏 ♪(^∇^*) 噫? 又好了! &#x27;;        titleTime = setTimeout(function () &#123;            document.title = &#x27;🤔 啊来来! 原标题是啥来着?  &#x27;;        &#125;, 2000);\t\t\t\ttitleTime = setTimeout(function () &#123;            document.title = &#x27;😮哦~! 想起来了!  &#x27;;        &#125;, 4000);\t\t\t\ttitleTime = setTimeout(function () &#123;            document.title = OriginTitle;        &#125;, 6000);    &#125;&#125;);\n\n之后修改 themes/next/layout/_layout.swing 在文件最后添加:\n&lt;!--崩溃欺骗--&gt;&#123;% if theme.crashcheat %&#125;  &lt;script type=&quot;text/javascript&quot; src=&quot;/js/crash_cheat.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125;\n\n最后在 主题配置文件 中, 找一个自己喜欢的位置, 写入 crashcheat: true. 什么时候想要关闭这个功能了, 直接设置为 false 即可.\n球形标签云球形标签云其实就是用这个插件 TagCanvas 实现的, 点击进入官网.\n进入官网后下载 tagcanvas.js 文件, 也可以直接在左面我给出的链接那里 &quot;右键-&gt;链接另存为&quot;, 保存到: themes\\next\\source\\js 目录下.\n打开 themes\\next\\layout\\page.swig 文件, 如果你已经开启了 &quot;自定义 swig 功能&quot;,  其实开不开也无所谓啦 , 进入博客网站根目录下的 source 文件夹, 打开 _data 文件夹, 没有的话就新建一个, 叫做 _data , 在 _data 文件夹中再新建一个 tagcanvas.swig 文件, 打开这个文件, 粘贴以下内容:\n&lt;div class=&quot;tags&quot; id=&quot;myTags&quot;&gt;  &lt;canvas width=&quot;350&quot; height=&quot;350&quot; id=&quot;my3DTags&quot;&gt;    &lt;p&gt; Anything in here will be replaced on browsers that support the canvas element &lt;/p&gt;  &lt;/canvas&gt;&lt;/div&gt;&lt;div class=&quot;tags&quot; id=&quot;tags&quot;&gt;  &lt;ul style=&quot;display: none&quot;&gt;    &#123;&#123; tagcloud(&#123;      min_font: 16,      max_font: 35,      amount: 999,      color: true,      start_color: &#x27;black&#x27;,      end_color: &#x27;green&#x27;,    &#125;) &#125;&#125;  &lt;/ul&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/tagcanvas.js&quot;&gt; &lt;/script&gt;&lt;script type=&quot;text/javascript&quot; &gt;  window.onload = function()  &#123;    try    &#123;      TagCanvas.Start(&#x27;my3DTags&#x27;,&#x27;tags&#x27;,      &#123;        textFont: &#x27;Georgia,Optima&#x27;,        textColour: null,        outlineColour: &#x27;black&#x27;,        weight: true,        reverse: true,        depth: 0.8,        maxSpeed: 0.05,        bgRadius: 1,        freezeDecel: true      &#125;);    &#125;    catch (e)    &#123;      document.getElementById(&#x27;myTags&#x27;).style.display = &#x27;none&#x27;;    &#125;  &#125;;&lt;/script&gt;\n\n之后打开 themes\\next\\layout\\page.swig 文件, 找到 43, 44 行之间的位置, 没有行数标记的话, 就搜索 tag-cloud-tags , 它所在的位置就是第 44 行. 在这一行的上面添加如下内容:\n&#123;# 球形云标签 #&#125;&#123;% if theme.tagcanvas %&#125;&#123;% include &#x27;../../../source/_data/tagcanvas.swig&#x27; %&#125;&#123;% endif %&#125;&#123;# 普通云标签 #&#125;\n\n最后在 主题配置文件 中, 找一个自己喜欢的位置, 写入 tagcanvas: true 即可.\n\n注 球形标签云也可以使用 hexo-tag-cloud 插件来实现, 不过我没用这种方法, 有时间的话我再试试吧. 执行我上面的操作后, 球形标签云和普通标签云是同时存在的, 如果你只想要显示球形标签云, 还是在 page.swig 文件中, 把后面那个 普通云标签 的 div 标签注释掉就行了. 就像这样:\n\n&#123;# 球形云标签 #&#125;&#123;% if theme.tagcanvas %&#125;&#123;% include &#x27;../../../source/_data/tagcanvas.swig&#x27; %&#125;&#123;% endif %&#125;&#123;# 普通云标签 #&#125;&#123;# &lt;div class=&quot;tag-cloud-tags&quot;&gt;  &#123;% if not theme.tagcloud %&#125;    &#123;&#123; tagcloud(&#123;min_font: 12, max_font: 30, amount: 200, color: true, start_color: &#x27;#ccc&#x27;, end_color: &#x27;#111&#x27;&#125;) &#125;&#125;  &#123;% else %&#125;    &#123;&#123; tagcloud(&#123;min_font: theme.tagcloud.min, max_font: theme.tagcloud.max, amount: theme.tagcloud.amount, color: true, start_color: theme.tagcloud.start, end_color: theme.tagcloud.end&#125;) &#125;&#125;  &#123;% endif %&#125;&lt;/div&gt; #&#125;\n\n文章写作部分Hexo 博客的属性设置title: //文章标题date: //博客的建立日期, 如果自己手动添加, 请按固定格式添加categories: //分类, 支持多级tags: //标签, 多个: [标签1,标签2,标签3]description: //文章的描述, 在每篇文章标题下方显示, 并且作为网页的 description 元数据. 如果不写, 则自动取 &lt;!-- more --&gt; 之前的文字作为网页的 description 元数据. 建议每篇文章都务必加上!keywords: //关键字, 并且作为网页的 keywords 元数据. 如果不写, 则自动取 tags 里的项作为网页的 keywords 元数据comments: true | false //是否开启评论layout: //页面布局, 默认值是 post, 默认值可以在站点配置文件中修改 default_layout\n\nMarkdown 支持部分 html 标签\n&lt;kbd&gt; 标签\n &lt;kbd&gt; 标签可以将其中的文字渲染成一个按键, 虽然目前 &lt;kbd&gt; 已经被标记为了 &quot;过时的&quot; 标签, 但是还是可以使用其来实现简单的效果.\n 代码: 复制的快捷键是: &lt;kbd&gt;Ctrl&lt;/kbd&gt; &lt;kbd&gt;C&lt;/kbd&gt;\n 效果: 复制的快捷键是: Ctrl C\n\n&lt;font&gt; 标签\n 利用 font 标签可以简单修改文字的颜色, 加粗斜体这些可以直接使用 Markdown 的语法.\n 代码: &lt;font color=&#39;red&#39;&gt; *这是红色斜体* &lt;/font&gt; &lt;font color=&#39;green&#39;&gt; **这是绿色粗体** &lt;/font&gt;\n 效果:  这是红色斜体   这是绿色粗体 \n\n\nMarkdown 支持自定义标签如何定义标签?\n[tag1]: tag1Name\n\n如何使用标签?\n[text1][tag1]\n\nMarkdown 支持自定义锚点如何使用标题锚进行跳转?\n[text1][#标题名称]\n\n[注]\n\n无论是几级标题, 都只写一个井号\n标题中所有的标签符号全部会被无视\n标题中所有的空格会全部转化为横线 (-)\n如 What is LaTex? &#x3D;&gt; #what-is-latex\n如 Ready, set, Go! &#x3D;&gt; #ready-set-go\n\nGitpages 支持使用 Markdown 实现任务列表语法格式:\n- [x] item 1    * [x] item A    * [ ] item B        more text        + [x] item a        + [ ] item b        + [x] item c    * [x] item C- [ ] item 2- [ ] item 3\n\n效果:\n\n item 1\n item A\n item B  more text\n item a\n item b\n item c\n\n\n item C\n\n\n item 2\n item 3\n\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"正则表达式 断言","url":"/program/regular_assert.html","content":"先放断言的手册链接 : https://www.regular-expressions.info/lookaround.html\n正则表达式的断言全称是: Lookahead and Lookbehind Zero-Length Assertions, 分为前瞻和后瞻, 符号是 ?= 和 ?&lt;=, 同时它们都有其对应的反匹配, 就像数字的正反一样, 把 = 换成 ! 就行了, 分别为 ?! 和 ?&lt;!\n🍒 断言直接统一说明断言, 断言也是一种零宽匹配, 就像 ^ 和 $ 一样, 返回的是位置\n为了方便理解, 以编辑器为例, 一般正则都是返回匹配到的字符, 而断言返回的是光标, 不是字符, 注意看下面举例图片中光标的位置\n^ 返回的是行首\n\n$ 返回的是行尾\n\n(?=) 前瞻返回的是匹配到的字符串的头, 比如 (?=￥) 返回的是\n\n(?&lt;=) 后瞻返回的是匹配到的字符串的尾, 比如 (?&lt;=￥) 返回的是\n\n前后瞻无非返回的位置一前一后, 其他的都一致, 这就是断言了, 但是理解了这个不代表会用, 我们还要学习一些它们的用法, 阅读后面的示例是请先自己独立思考, 之后再看答案\n🌰 断言的使用实现前缀判断比如现在想要匹配到前缀是 # 的 1 个数字, 怎么用断言实现呢?\n答案是 (?&lt;=#)(\\d)\n?&lt;=# 返回的就是 # 字符后面的位置, 然后从这个位置 匹配后面的 一个数字, 就实现了前缀是 # 的效果\n总结: 将 后瞻 写在 前面 实现前缀判断\n实现后缀判断匹配到后缀是 # 的 1 个数字, 怎么用断言实现呢?\n答案是 (\\d)(?=#)\n?=# 返回的就是 # 字符前面的位置, 然后从这个位置开始 匹配前面的 匹配一个数字, 就实现了后缀是 # 的效果\n总结: 将 前瞻 写在 后面 实现后缀判断\n🌰 断言的阅读(?!\\d)(.+)上面表达式的含义是 ? 对于以下文本, 匹配的结果是什么 ?\n1123jkh123123coll%iderqweasdfzxv1244collider5567%ertdfkjhkj123klcolliderhlazcvg123123jhk%j123klcolltyughjider5567asdf123123col23jkhfgcollidercol2%3jkh\n\n答案是 匹配一行中不以数字开头的部分, 结果为\njkh123123coll%iderqweasdfzxvcollider5567%ertdfkjhkj123klcolliderhlazcvgjhk%j123klcolltyughjider5567asdfcol23jkhfgcollidercol2%3jkh\n\n(?!\\d) 返回的是非数字的前面的位置, 然后从这个位置开始匹配任意串, 所以实现的是 提取一行中不以数字开头的部分, 这个也可以使用 ([^\\d])+(.+) 实现\n^((?!collider)(.))+$上方表达式的含义是 ? 对于以下文本, 匹配的结果是什么 ?\n1123jkh123123colliderqweasdfzxv1244collider5567%ertdfkjhkj123klcolliderhlazcvg123123jhk%j123klcolltyughjider5567asdf123123col23jkhfgcollidercol2%3jkh\n\n答案是 匹配不包含单词 collider 的整行串, 结果为\n123123jhk%j123klcolltyughjider5567asdf123123col23jkhfg\n\n使用 ^((.)(?&lt;!collider))+$ 也可以实现同样的效果\n(.) 是匹配任意字符, 之后是一个放在前面的前瞻断言, 含义是 后面不是collider的位置, 结合起来便是 不是以collider开头的字符, 不是以collider开头的字符 ? ? ? 不是以collider这个单词开头的字符 ? ? ? 不是以单词开头的字符 ? ? ? 这是什么鬼 ? ? ? 什么叫以单词开头的字符 ? ? ?\n翻译一下, 就是 不是紧跟着ollider的字符c的任意字符, 也就是从任意字符中把一个 以ollider结尾的字符c 排除了, 其他的 c 可以, 以 ollider 结尾的 c 不行\n最后在外面使用 ^()+$ 包起来, 表示只使用这样的字符构成一整行, 就是上面解析的, 使用 不是紧跟着ollider的字符c的任意字符 构成整行, 就实现了 不包含单词 collider 的行 的效果\n","categories":["Program"],"tags":["Program"]},{"title":"Perfetto 之内存优化","url":"/optimization/android_perfetto.html","content":"\n\n🥦 Perfetto 工具的来源想详细了解 Perfetto 的话, 可以跳转 谷歌开发者文档 查阅, 这里只是简单引用几句话说明一下\n\nThe System tracing utility is an Android tool that saves device activity to a trace file. On a device running Android 10 (API level 29) or higher, trace files are saved in Perfetto format, as shown later in this document. On a device running an earlier version of Android, trace files are saved in the Systrace format.\n\n从上面一段的描述可以看出, Android 系统是内置跟踪程序的, 此程序可以将设备的活动保存至跟踪文件中, 在 Android 10 及以上版本中, 跟踪文件会以 Perfetto 格式保存, 在 Android  9 及以下版本中, 跟踪文件会以 Systrace 格式保存\n\nSystrace is a legacy platform-provided command-line tool that records device activity over a short period of time in a compressed text file. The tool produces a report that combines data from the Android kernel, such as the CPU scheduler, disk activity, and app threads. Systrace works on all Android platform versions, but we recommend Perfetto for devices running Android 10 and higher.\n\n\nPerfetto is the platform-wide tracing tool introduced in Android 10. It is a sophisticated open source tracing project for Android, Linux, and Chrome. It offers a superset of data sources compared to Systrace and lets you record arbitrarily long traces in a protocol buffer binary stream. You can open these traces in the Perfetto UI.\n\n从上面两段的描述可以看出, Perfetto 本质就是 Systrace 的上位替代品, 是谷歌新推出的一款跟踪工具, 已于 Android 系统中 内置\n🥝 Perfetto 的组成Perfetto 是一套开源的多平台性能分析工具集, 它可以跟踪多种性能数据, 可以看下面的截图, 以 CPU GPU Memory 为例, 当然远不止这些\n\n\n\n这里我们就专注于看内存分析中的 Native Heap Profiling 部分\n👻 内存基础知识先来补充一下基础知识, 对基础很了解的可以直接跳到这里: 堆内存分析的原理\n🦄 内存分类内存可以按照 堆内存 (Heap) 和 栈内存 (Stack) 的方式分类, 栈内存不会有内存泄漏问题, 而且通常不纳入分析, 因此我们之后分析的都是堆内存\n而堆内存又分为 托管内存 (managed memory) 和 原生内存 (native memory), 原生内存也叫做非托管内存, 下文都称为 非托管内存\n🐔 非托管 (堆) 内存在学校学习时期编写的 C 语言控制台程序就是纯粹的非托管内存程序, 那时候无论申请还是释放堆内存, 都要自己手动调用 malloc &#x2F; calloc &#x2F; realloc &#x2F; free\n用一句话总结的话, 完全由开发者手动申请手动释放的堆内存就是非托管内存\n🐤 托管 (堆) 内存那么什么是托管内存呢 ? 要说明托管内存, 就要先说明一下 &quot;托管运行时&quot;, 在开发 C&#x2F;C++ 程序时, 有下面一些问题:\n\n由 指针 引发的内存安全问题, 为了避免 野指针, 内存越界 等内存安全问题, 需要一个统一的管理层\n\n&quot;跨平台&quot; 问题, 如何做到只编写一份代码就可以在各个平台上正确运行, 也需要一个统一的管理层\n\n系统安全问题, 使用 C&#x2F;C++ 可以做内存病毒, 因为是直接在操作系统上裸跑, 所以为了限制程序访问敏感资源, 防止损坏系统, 也需要一个统一的管理层\n\n\n基于上面种种问题, &quot;托管运行时&quot; 被提出, 一个 负责执行程序代码, 并统一管理内存, 类型安全, 线程, 异常, GC 等功能的中间层, 由 &quot;托管运行时&quot; 帮我们申请的内存, 就是由这个 &quot;托管运行时&quot; 来管理的, 它会帮我们管理, 帮我们释放, 不过释放时有卡顿风险\n这样我们的程序和最初的 C&#x2F;C++ 程序相比, 可以简单理解为, 不再直接和操作系统打交道, 而是交给一个托管商, 这个托管商帮助我们管理资源, 调度执行, 处理异常, 回收垃圾内存等, 这部分被托管商管理的内存就是托管内存啦\n🎄 内存的组成虽说托管运行时接管了部分内存的申请和释放, 但托管运行时并没有硬性限制我们只能用托管内存, 我们也可以跳过托管, 直接向系统申请非托管内存, 不要想当然地理解成有了托管运行时后, 所有内存就都走托管了, 所以现代软件中, 几乎全部程序的堆内存都是由 非托管内存 和 托管内存 共同组成的\n举一个例子, 比如 Android NDK, 全称是 Android Native Development Kit, 允许 Android 应用直接编写 C&#x2F;C++ 代码, 既然都可以写 C&#x2F;C++ 代码了, 自然就可以直接申请非托管堆内存, 以及调用底层系统 API\n再举一个例子, 我们都知道, Java 程序运行在 JVM 上, JVM 的全称是 Java Virtual Machine, 翻译过来就是 Java 虚拟机, 但是也不要想当然认为 Java 代码申请的内存就全是托管内存, 比如 JNI, 全称是 Java Native Interface, 其中像 ByteBuffer.allocateDirect() 这样的 API 就可以实现在 JVM 堆外申请内存, 这种内存是不归 JVM 管的, 也是非托管内存\n所以再次说明, 现代应用程序的堆内存是由 非托管内存 和 托管内存 共同组成的\n🦴 常见的托管运行时下面是一些常见的托管运行时, 看看有没有你所熟知的\n\n\n\n托管运行时\n主要编程语言\n代表平台 &#x2F; 应用\n\n\n\n.NET CLR &#x2F; CoreCLR &#x2F; Mono &#x2F; IL2CPP\nC#, F#, VB.NET\nWindows 应用, Unity 游戏的 C# 层, Xamarin\n\n\nJVM (Java Virtual Machine)\nJava, Kotlin, Scala, Groovy\nAndroid 应用, 企业服务器端\n\n\nV8 &#x2F; SpiderMonkey &#x2F; JavaScriptCore\nJavaScript, TypeScript\nChrome &#x2F; Node.js &#x2F; Safari &#x2F; Web 前端\n\n\nPython Interpreter (CPython, PyPy)\nPython\nAI 脚本, 数据分析, 自动化\n\n\nRuby MRI &#x2F; YARV\nRuby\nWeb 开发 (Rails)\n\n\nBEAM VM\nErlang, Elixir\n电信系统, 高并发后台\n\n\nLua VM\nLua\n游戏脚本, 嵌入式脚本系统\n\n\n⏳ Perfetto 堆内存分析的原理基础知识说明完毕, 接下来开始说明如何使用 Perfetto 进行堆内存分析, Perfetto 提供了两种互补的技术来专项负责调试上述两种内存\n第一种 : heap profiling for native code\n非托管代码 的堆内存分析, 基于 malloc&#x2F;free 时点, 对调用堆栈进行采样 (此次的研究内容)\n像 C&#x2F;C++&#x2F;Rust 这样的 Native Languages, 通常使用 libc 系列的 malloc &#x2F; free 函数在底层分配和释放内存\nPerfetto 分析这部分非托管内存的工作原理是拦截对这些函数的调用, 并注入代码来跟踪已分配但未释放的内存的调用栈, 还可以实现追踪每次分配的代码来源\n\n注意:\n使用 Perfetto 进行非托管堆内存分析仅适用于 Android 和 Linux, 因为 Perfetto 所开发的拦截 malloc &#x2F; free 的技术, 仅适用于这些操作系统\n另外此堆分析不具有追溯力, 它只能报告跟踪开始后发生的分配, 无法提供任何有关跟踪开始前的信息\n如果需要分析进程启动时的内存使用情况, 则必须在进程启动前便开始跟踪\n\n第二种 : heap dumps for Java&#x2F;managed code\n托管代码 的堆内存转储, 以创建堆保留图的形式, 来显示对象之间的保留依赖关系 (目前不做研究)\n🍖 Perfetto 之 UI 模式Perfetto 有两种使用方式, 第一种使用谷歌所提供的 Perfetto UI 网站来使用 Perfetto\n分析准备\n目标设备必须是 Android 10 及以上\n应用程序是 可分析 或 可调试 包\n找到待分析的进程名称\n安装 android-tools, 即 ADB\n\n\n在 adb 中执行 adb shell ps -A 可以打印出进程信息, 通过筛选缩小数量, 最后一列就是需要填写的内容\nWindows 操作系统可以使用 Select-String 进行筛选, Linux 则是使用 grep : adb shell ps -A | Select-String funny\n\n连接设备\n打开 Perfetto UI 网站 https://ui.perfetto.dev/\n选择 Record new trace\n选择 Target device\n选择 Android\n选择 WebUSB (FireFox 不支持 WebUSB, 请使用 Chrome 或 Edge)\n点击 Connect new device\n\n成功连接设备后如下图\n\n配置跟踪\n选择左侧 Probes 中的 Memory\n开启 Native heap profiling\n填写 进程名称, 转储延时, 连续转储间隔 等\n选择左侧 Record settings 中的 Buffers and duration, 设置时长和大小限制\n\n跟踪内存\n选择 Target device\n点击最下方的 Start tracing\n\n🍉 Perfetto 之 CLI 模式前面说了 Perfetto 的第一种使用方式, 直接使用 Web UI, 但是这种方式无法对堆栈信息进行符号化, 而 CLI 模式可以, 所以我们选择 CLI 模式, CLI 模式也有两种使用方式\n第一种 : 直接使用 perfetto 命令\n使用 perfetto 命令, 这种使用方式灵活, 通过不同的配置文件可以进行不同的数据跟踪, 指定堆内存分析配置, 就可以进行堆内存分析了, 指定 CPU 分析配置, 就可以跟踪 CPU 数据, 但是使用难度很高, 而且进行非托管内存跟踪时无法自动符号化, 关于此命令的详细说明, 请参考 注解1\n第二种 : 使用官方的 heap_profile 脚本\n这个脚本是专门用于堆内存分析的, 只会跟踪堆内存数据, 无法进行其他的数据跟踪, 但对我们而言, 已经足够了, 另外 heap_profile 脚本支持自动符号化, 还能直接将跟踪数据从手机导出到 Linux 中, 不再需要手动 pull, 因此后续会讲解 heap_profile 脚本进行非托管内存分析\n现在可以先将这个脚本下载下来, 后面会用: https://raw.githubusercontent.com/google/perfetto/main/tools/heap_profile\n🍑 WSL 的说明是不是觉得很奇怪, 前面不是在讲 CLI 模式嘛, 怎么只讲了一点概述就跳转到 WSL 了 ? WSL 又是什么 ?\n先说一下什么是 WSL, WSL 全称 Windows Subsystem for Linux, 是一个可以让开发人员在 Windows 计算机上同时访问 Windows 和 Linux 的强大功能, 通过 WSL, 我们就可以直接安装各种 Linux 发行版, 例如 Ubuntu, Debian, Arch Linux 等, 并直接在 Windows 上使用 Linux 程序和 Bash 命令行工具, 而不用进行任何修改, 也无需运行虚拟机或配置双启动, 是不是很方便呢 ?\n那么为什么要提到 Linux 呢 ? 前面有提到 &quot;堆栈信息符号化&quot;, 目前这个功能只能在 Linux 或者 MacOS 上实现, 虽然其他的功能 Windows 都能实现, 但对于堆内存分析而言, &quot;堆栈信息符号化&quot; 是必须的一环, 不能跳过, 否则跟踪出来的数据就是一堆垃圾, 毫无用处, 所以接下来我们要在 Linux 上使用 Perfetto, 不过在这之前, 先说明一下如何使用 WSL\n🍒 开启 WSLWSL 是 Windows 操作系统内置的, 不需要手动安装, 但是默认是关闭的, 想要启用 WSL, 需要开启以下设置\n\n启用 CPU 虚拟化, 这个需要在主板设置中开启, 不同主板的设置方法不用, 请自行搜索\n开启 虚拟机平台 功能, 在 &quot;启用或关闭 Windows 功能&quot; 中开启\n开启 适用于 Linux 的 Windows 子系统 功能, 在 &quot;启用或关闭 Windows 功能&quot; 中开启\n\n\n设置完毕后, 记得重启计算机, 这样 WSL 就成功启用了\n如果担心自己电脑上的 WSL 不是最新版, 可以通过 wsl --update --web-download 更新 WSL\n如果通过命令更新失败, 也可以直接去 github 下载 .msixbundle 文件, 手动进行更新 (https://github.com/microsoft/WSL/releases)\n可以通过 wsl --version 查看当前已安装 WSL 的版本信息\n\nWSL 版本: 2.6.1.0\n内核版本: 6.6.87.2-1\nWSLg 版本: 1.0.66\nMSRDC 版本: 1.2.6353\nDirect3D 版本: 1.611.1-81528511\nDXCore 版本: 10.0.26100.1-240331-1435.ge-release\nWindows: 10.0.19045.6216\n\n🍅 安装 Linux : Ubuntuwsl --list --online : 列出当前可安装的 Linux 发行版本\nwsl --list --verbose : 列出当前已安装的 Linux 发行版本\nwsl --install &lt;name&gt; : 例如 Ubuntu-24.04, 安装 Ubuntu-24.04 子系统\nwsl --unregister &lt;name&gt; : 例如 Ubuntu, 删除已安装的 Ubuntu 子系统\n先通过 list 命令得到想要安装的发行版名称, 再使用 install 命令安装即可, 我安装的是 Ubuntu 发行版, 所以下面说明一下 Ubuntu 的一些命令\n🍐 更新 Ubuntu上一步安装完 Linux 之后, 开始菜单中就可以看到 Ubuntu 了, 可以直接启动, 启动后就是一个控制台, 是的, 就只是一个控制台, 因为我们并没有安装桌面系统, 所以这里的 Ubuntu 是没有桌面的, 当然你可以自己安装一个桌面系统, 就可以使用带桌面的 Linux 了, 不过我们这里并不需要, 因为我们之后使用 Perfetto 也是以命令行的方式使用\ncat /etc/os-release\n通过此命令可以查看系统信息, 其中 &quot;cat&quot; 全称 &quot;concatenate&quot;\nsudo apt update\napt 就是 Ubuntu 系列的包管理器命令, 不同的 Linux 系列使用不同的包管理器命令\n\nDebian 系列, 使用 apt, dpkg\nRed Hat 系列, 使用 rpm, yum, dnf\nArch Linux 系列, 使用 pacman, yay, paru\n\n使用此命令可以更新本地的软件包索引, 以熟悉的 git 对比的话, 这就是 &quot;fetch&quot; 命令, 执行后通常会提示有多少包需要更新\nsudo apt upgrade\n前面查询出需要更新的包, 现在就可以使用此命令执行更新, 可以使用 &quot;-y&quot; 来取消交互, 一路自动 &quot;yes&quot;\n🍎 在 Linux 上安装 Perfetto 所需的环境sudo apt install adb\n我们的目标是跟踪 Android 程序, 因此必须安装 ADB\nsudo apt install llvm\n这里的 llvm 是什么呢 ? 我们为什么要安装它呢 ?\nllvm 的全称是 Low Level Virtual Machine, 但是现代的 llvm 早已不再是虚拟机, 而是一整套编译器基础设施, 包含一系列模块化的编译器组件和工具链, 主要用于开发编译器以及优化编译, 而我们想要让堆栈信息符号化, 就必须安装其中的 llvm-symbolizer, 这是 llvm 工具集的一部分, 所以我们直接安装 llvm 即可\n安装完成后, 可以使用 llvm-symbolizer --version 验证是否安装成功\n🍊 Windows 与 Linux 共享数据总线这是什么意思呢 ? 虽然 WSL 实现了 Windows 和 Linux 几乎一体化的操作体验, 但是它们俩本质还是两个操作系统\n我们的安卓手机通过数据线只能连接到 Windows, 而无法连接到 Linux, 所以接下来我们要想办法让 Linux 可以连接我们的安卓手机\n那么怎么做到呢 ? 就是标题了 : Windows 与 Linux 共享数据总线\n\n安装 USBIPD, 去 usbipd 这里下载 usbipd-win_5.2.0_x64.msi 并安装\n\n执行 adb kill-server : 目的是让 Windows 端停止 ADB 服务, 防止 ADB 占用总线, 导致无法共享\n\n执行 usbipd list : 列出连接到 Windows 的所有 USB 设备, 找到要共享到 WSL 的总线 ID, 我的是 2-8\n\n执行 usbipd bind --busid 2-8 --force : 共享总线, 之后可以通过执行 usbipd list 验证是否正确开启共享\n\n执行 usbipd attach --wsl --busid 2-8 : 将总线附加到 WSL 中, 这样 WSL 就可以访问这条数据总线了\n\n\n🍈 Linux 通过 ADB 连接 Android 设备切换到 Linux 这边, 也不是说现在就可以连接 Android 了, 还需要先安装一个工具\n\n执行 sudo apt install usbutils 安装 USB 助手: usbutils\n\n执行 lsusb 查看连接的 USB 设备, 此时应该就可以看到安卓手机了 (MTP + ADB)\n\n执行 adb devices 就可以进行 USB 调试了\n\n\n🌈 Perfetto 之 CLI 模式做完前面的步骤, 我们的 Linux 就准备好了, 接下来正式讲解 Perfetto 命令行模式的使用步骤\n分析前提先来看下分析的前提\n\n目标设备必须是 Android 10 及以上\n应用程序是 可分析 或 可调试 包\n找到待分析的进程名称\nlinux 安装 android-tools, 即 ADB\nlinux 安装 llvm-symbolizer\nlinux 安装 python3\n\n前面的步骤中, 我们已经安装好了 adb 以及 llvm-symbolizer, 看要求还要安装 python3 ? 为什么要用 python3 呢 ? 因为前面 这里 不是说了要用 heap_profile 脚本嘛, 而这个脚本就是一个 python 脚本 😂 哈哈哈\n那为什么安装 Linux 那里没有让你安装呢, 是因为 Ubuntu 中已经自带了 python3, 所以不需要再次安装, 可以使用 python3 --version 命令查看当前版本\n连接手机adb devices\n使用命令检查手机, 确保 Linux 已通过 ADB 连接手机\n\nList of devices attached\n9dcb88d1        device\n\n将准备文件放置到 Linux在 Windows 文件管理器中输入 \\\\wsl$ 即可访问安装的 Linux 发行版\n将之前下载好的 heap_profile 文件, 以及需要解析的符号表 (*.so) 放置到 home/kuroha/Documents 文件夹中\n其中 kuroha 是我设置的 Linux 用户名, Documents 需要自己新建\n符号表文件解压后直接放进文件夹即可, 后面我们会设置为 index 模式, 此模式下会自动递归搜索文件夹, 所以不需要什么特殊路径配置\n\n给予 heap_profile 脚本执行权限chmod +x ~/Documents/heap_profile\n这里的 ~ 就是用户文件夹, 即: home/kuroha\n给予 heap_profile 脚本执行权限, 这样 heap_profile 就可以在命令行中执行了, 权限设置好之后, 我们开始使用 heap_profile 命令进行堆内存跟踪\n关于这个脚本的具体使用方法可以执行 Documents/heap_profile -h 进行查看, 也可以在 cli 文档中查看帮助信息\n捕获非托管内存快照如果直接使用 heap_profile -n &lt;name&gt; 命令, 可以执行默认配置的内存捕获\n但是我们一般都是使用参数来进行自定义的内存捕获, 下面是常用的参数, 具体请参考 注解2\n-n 用于指定需要跟踪的进程的名称\n-c 可以设置数据保存的间隔\n-d 可以设置总的跟踪时长\n命令示例 : Documents/heap_profile -n com.Kuroha.SwordRequiem -c 5000 -d 60000\n符号化通过环境变量 PERFETTO_SYMBOLIZER_MODE 和 PERFETTO_BINARY_PATH 可以指定符号文件的位置\n将 PERFETTO_SYMBOLIZER_MODE 设置为 index 就可以递归搜索文件夹, 寻找符号表文件, 这样就不需要关注路径问题了\nPERFETTO_BINARY_PATH 的值就是符号表文件所在的根目录, 下面是最终的完整命令\nPERFETTO_SYMBOLIZER_MODE=&quot;index&quot; PERFETTO_BINARY_PATH=&quot;/home/kuroha/Documents/symbols_sword/&quot; Documents/heap_profile -n com.Kuroha.SwordRequiem -c 5000 -d 60000\n\n执行此命令后, 会立即进行一次数据保存, 并且接下来的 1 分钟内, 每过 5 秒会再进行一次数据保存, 并生成跟踪文件, 此时生成的文件在 Android 手机中\n1 分钟结束后, 会自动拉取跟踪数据到本机, 即从 Android 手机拉取到 Linux 上, 并自动进行符号化\n最终生成 13 个 .pb.gz 跟踪数据文件, raw-trace 文件, symbolized-trace 文件, symbols 文件\n此时打开 Perfetto UI 网站, 点击 Open trace file, 选择 symbolized-trace 文件即可查看最终数据\n\n🍀 参考以下是一些参考资料\n⚡ 注解1Perfetto 命令的使用\nadb shell perfetto -hUsage: perfetto  --background     -d      : Exits immediately and continues tracing in background  --config         -c      : /path/to/trace/config/file or - for stdin  --out            -o      : /path/to/out/trace/file or - for stdout  --upload                 : Upload field trace                             (Android only)  --dropbox        TAG     : DEPRECATED: Use --upload instead TAG should always be set to &#x27;perfetto&#x27;  --no-guardrails          : Ignore guardrails triggered when using --dropbox                             (for testing).  --txt                    : Parse config as pbtxt. Not for production use. Not a stable API.  --reset-guardrails       : Resets the state of the guardails and exits all_heaps                             (for testing).  --query                  : Queries the service state and prints it as human-readable text.  --query-raw              : Like --query, but prints raw proto-encoded bytes of tracing_service_state.proto.  --help           -hlight configuration flags: (only when NOT using -c/--config)  --time           -t      : Trace duration N[s,m,h] (default: 10s)  --buffer         -b      : Ring buffer size N[mb,gb] (default: 32mb)  --size           -s      : Max file size N[mb,gb] (default: in-memory ring-buffer only)  ATRACE_CAT               : Record ATRACE_CAT (e.g. wm)  FTRACE_GROUP/FTRACE_NAME : Record ftrace event (e.g. sched/sched_switch)  FTRACE_GROUP/*           : Record all events in group (e.g. sched/*)statsd-specific flags:  --alert-id           : ID of the alert that triggered this trace.  --config-id          : ID of the triggering config.  --config-uid         : UID of app which registered the config.  --subscription-id    : ID of the subscription that triggered this trace.Detach mode. DISCOURAGED, read https://docs.perfetto.dev/#/detached-mode :  --detach=key          : Detach from the tracing session with the given key.  --attach=key [--stop] : Re-attach to the session (optionally stop tracing once reattached).  --is_detached=key     : Check if the session can be re-attached (0:Yes, 2:No, 1:Error).\n\n⚡ 注解2Heap_Profile 脚本的使用\n/home/kuroha/Documents/heap_profile -husage: heap_profile [-h] [-i INTERVAL] [-d DURATION] [--no-start] [-p PIDS] [-n NAMES] [-c CONTINUOUS_DUMP]                    [--heaps HEAPS] [--all-heaps] [--no-android-tree-symbolization] [--disable-selinux]                    [--no-versions] [--no-running] [--no-startup] [--shmem-size SHMEM_SIZE] [--block-client]                    [--block-client-timeout BLOCK_CLIENT_TIMEOUT] [--no-block-client] [--idle-allocations]                    [--dump-at-max] [--disable-fork-teardown] [--simpleperf] [--traceconv-binary TRACECONV_BINARY]                    [--no-annotations] [--print-config] [-o DIRECTORY]Collect a heap profile  The PERFETTO_PROGUARD_MAP=packagename=map_filename.txt[:packagename=map_filename.txt...] environment variable can be used to pass proguard deobfuscation maps for different packagesoptions:  -h, --help                        show this help message and exit  -i, --interval                    Sampling interval. Default 4096 (4KiB)  -d, --duration                    Duration of profile (ms). 0 to run until interrupted. Default: until interrupted by user.  --no-start                        Do not start heapprofd.  -p, --pid                         Comma-separated list of PIDs to profile.  -n, --name                        Comma-separated list of process names to profile.  -c, --continuous-dump             Dump interval in ms. 0 to disable continuous dump.  --heaps                           Comma-separated list of heaps to collect, e.g: libc.malloc,com.android.art. Requires Android 12.  --all-heaps                       Collect allocations from all heaps registered by target.  --no-android-tree-symbolization   Do not symbolize using currently lunched target in the Android tree.  --disable-selinux                 Disable SELinux enforcement for duration of profile.  --no-versions                     Do not get version information about APKs.  --no-running                      Do not target already running processes. Requires Android 11.  --no-startup                      Do not target processes that start during the profile. Requires Android 11.  --shmem-size                      Size of buffer between client and heapprofd. Default 8MiB. Needs to be a power of two multiple of 4096, at least 8192.  --block-client                    When buffer is full, block the client to wait for buffer space. Use with caution as this can significantly slow down the client. This is the default  --block-client-timeout            If --block-client is given, do not block any allocation for longer than this timeout (us).  --no-block-client                 When buffer is full, stop the profile early.  --idle-allocations                Keep track of how many bytes were unused since the last dump, per callstack  --dump-at-max                     Dump the maximum memory usage rather than at the time of the dump.  --disable-fork-teardown           Do not tear down client in forks. This can be useful for programs that use vfork. Android 11+ only.  --simpleperf                      Get simpleperf profile of heapprofd. This is only for heapprofd development.  --traceconv-binary                Path to local trace to text. For debugging.  --no-annotations                  Do not suffix the pprof function names with Android ART mode annotations such as [jit].  --print-config                    Print config instead of running. For debugging.  -o, --output                      Output directory.\n\n🔥 参考链接download heap_profile : https://raw.githubusercontent.com/google/perfetto/main/tools/heap_profile\ndownload record_android_trace : https://raw.githubusercontent.com/google/perfetto/master/tools/record_android_trace\n使用 Perfetto 调试内存 其中的 &quot;Analyzing the Native Heap&quot; 段\n关于 Heap profiler 的更多信息\nPerfetto Trace 的抓取\n🔥 如何判断安卓设备架构adb shell getprop ro.product.cpu.abi\n这将输出设备的主 CPU 架构类型\narm64-v8a : 表示 64-bit ARM 架构, 通常是 arm64\narmeabi-v7a : 表示 32-bit ARM 架构, 通常是 armv7\nx86_64 : 表示 64-bit x86 架构\nx86 : 表示 32-bit x86 架构\n🔥 命令示例PERFETTO_SYMBOLIZER_MODE=&quot;index&quot; PERFETTO_BINARY_PATH=&quot;/home/kuroha/Documents/symbols_sword/&quot; Documents/heap_profile -n com.Kuroha.SwordRequiem -c 5000 -d 60000PERFETTO_SYMBOLIZER_MODE=&quot;index&quot; PERFETTO_BINARY_PATH=&quot;/home/kuroha/Documents/symbols_test/&quot; Documents/heap_profile -n com.DefaultCompany.Perfetto -c 5000 -d 60000PERFETTO_SYMBOLIZER_MODE=&quot;index&quot; PERFETTO_BINARY_PATH=&quot;/home/kuroha/Documents/symbols_funny/&quot; Documents/heap_profile -n com.sofunny.Sausage -c 5000 -d 60000\n\n🌴 Perfetto SQLstack_profile_mappingstack_profile_mapping 表存储调用堆栈的进程地址空间映射信息 (a mapping (binary &#x2F; library) in a process), 是由堆栈分析器 heapprofd 和 traced_perf 生成的\nselect id, build_id, exact_offset, start_offset, start, end, load_bias, name from stack_profile_mapping\n\n\nid: 唯一标识符\nbuild_id: 符号表文件 *.so 的 Build ID\nstart: 映射在进程地址空间中的开始位置\nend: 映射在进程地址空间中的结束位置\nname: 符号表文件 *.so 的名字\n\nstack_profile_framestack_profile_frame 表存储的是调用堆栈的帧信息 (a frame on the callstack), 也是由堆栈分析器 heapprofd 和 traced_perf 生成的\nselect id, name, mapping, rel_pc, symbol_set_id, deobfuscated_name from stack_profile_frame\n\n\nid: 唯一标识符\nname: 此位置所在的函数的名称\nmapping: 此位置所在的映射\nrel_pc: 相对于映射开始的程序计数器\nsymbol_set_id: 此帧的离线符号信息\ndeobfuscated_name: 此位置所在的函数的去混淆名称\n\nstack_profile_callsitestack_profile_callsite 表存储的是堆栈上的帧列表 (a callsite, callsite is a list of frames that were on the stack), 也是由堆栈分析器 heapprofd 和 traced_perf 生成的\nselect id, depth, parent_id, frame_id from stack_profile_callsite\n\nheap_profile_allocationheap_profile_allocation 表存储的是一个 callsite 上发生的分配, 这是由 heapprofd 生成的\nselect id, ts, upid, heap_name, callsite_id, count, size from heap_profile_allocation\n\nstack_profile_symbolstack_profile_symbol 表存储帧的符号化数据\nselect id, symbol_set_id, name, source_file, line_number from stack_profile_symbol\n\n示例 SQLselect heap.callsite_id, frame.name, frame.symbol_set_id, mapping.name as mapping_namefrom heap_profile_allocation heapjoin stack_profile_callsite callsite on (heap.callsite_id = callsite.id)join stack_profile_frame frame on (callsite.frame_id = frame.id)join stack_profile_mapping mapping on (frame.mapping = mapping.id)where \n","categories":["Unity"],"tags":["Unity"]},{"title":"使用正则表达式捕获分组并使用分组","url":"/program/regular_common.html","content":"捕获符号 以及 捕获后的使用最常使用的场景是: 需要使用正则表达式进行替换, 但是同时需要使用到正则表达式所匹配到的内容, 这时候就需要用到分组了, 举个非常简单的栗子🌰, 将下面的代码段一替换为代码段二\n代码段一\nvar tempTool001 = new RefCleanerController();var tempTool002 = new TextureAnalysis();var tempTool003 = new MeshAnalysis();var tempTool004 = new ProfilerTool();var tempTool005 = new AnimeClipCompress();var tempTool006 = new BrokenAssetChecker();var tempTool007 = new RefCleanerMat();var tempTool008 = new PreCombineMesh();var tempTool009 = new MeshUVViewer();var tempTool010 = new PreStaticBatches();var tempTool011 = new GuidFinder();var tempTool012 = new AssetOperateTool();var tempTool013 = new AssetRenameTool();var tempTool014 = new SoCreator();var tempTool015 = new LODBatchTool();var tempTool016 = new MissingChecker();var tempTool017 = new RemoveRepeatCharacter();var tempTool018 = new About();\n\n代码段二\nAddTool&lt;RefCleanerController&gt;();AddTool&lt;TextureAnalysis&gt;();AddTool&lt;MeshAnalysis&gt;();AddTool&lt;ProfilerTool&gt;();AddTool&lt;AnimeClipCompress&gt;();AddTool&lt;BrokenAssetChecker&gt;();AddTool&lt;RefCleanerMat&gt;();AddTool&lt;PreCombineMesh&gt;();AddTool&lt;MeshUVViewer&gt;();AddTool&lt;PreStaticBatches&gt;();AddTool&lt;GuidFinder&gt;();AddTool&lt;AssetOperateTool&gt;();AddTool&lt;AssetRenameTool&gt;();AddTool&lt;SoCreator&gt;();AddTool&lt;LODBatchTool&gt;();AddTool&lt;MissingChecker&gt;();AddTool&lt;RemoveRepeatCharacter&gt;();AddTool&lt;About&gt;();\n\n在不使用多行编辑的情况下, 想一步将代码段一替换为代码段二还是很麻烦的, 基本都是花费好几步才能完成, 但是使用捕获就不一样了\n搜索栏填写 : .*new (\\w+).*\n替换栏填写 : AddTool&lt;$1&gt;();\n其中使用 $数字 来引用正则中匹配到的内容, 在第几个 () 中就是第几组, 序号从 1 开始\n使用捕获来实现字符大小写转换\n\\l 首字母变小写, \\u 首字母变大写\n\\L 字符串变小写, \\U 字符串变大写\n\n还是以上面的字符串举例, 搜索栏依旧填写: ^var .*new (\\w+).*, 替换栏中输入: \\U$1, 最终的结果便是:\nREFCLEANERCONTROLLERTEXTUREANALYSISMESHANALYSISPROFILERTOOLANIMECLIPCOMPRESSBROKENASSETCHECKERREFCLEANERMATPRECOMBINEMESHMESHUVVIEWERPRESTATICBATCHESGUIDFINDERASSETOPERATETOOLASSETRENAMETOOLSOCREATORLODBATCHTOOLMISSINGCHECKERREMOVEREPEATCHARACTERABOUT\n\n一些常用的表达式不能包含某些字符\n整行中不包含汉字\n  ^[^\\u4e00-\\u9fa5]+$\n\n整行中不包含数字\n  ^[^\\d]+$\n\n整行中不包含字母\n  ^[^a-zA-Z]+$\n\n\n整行中不能包含某些词汇\n不包含 &quot;包含&quot;\n  ^(.(?!包含))*$\n\n不包含 &quot;Collider&quot;\n  ^(.(?!Collider))*$\n\n不包含 &quot;00&quot;\n  ^(.(?!00))*$\n\n\n整行只由某些字符构成\n纯汉字\n  ^[\\u4e00-\\u9fa5]+$\n\n纯字母\n  ^[a-zA-Z]+$\n\n纯数字\n  ^[\\d]+$\n\n\n整行只由某些词汇构成\n只有 Android, iOS, PC\n  ^((Android)|(iOS)|(PC))+$\n\n\n","categories":["Program"],"tags":["Program"]},{"title":"初学正则表达式","url":"/program/regular_expression.html","content":"正则表达式?\n正则表达式是一种被用于从文本中检索符合某些特定模式的文本, 英文为 &quot;Regular Expression&quot;, 缩写 &quot;regex&quot; 或者 &quot;regexp&quot;.\n\n\n正则表达式可以很简单的实现比较复杂的字符串匹配逻辑, 来快速地对用户输入施加限制条件.\n\n在日常的文本编辑中, 正则表达式还可以快速的实现复杂的替换操作, 使得文本编辑省时省力.\n\n正则表达式依赖于所处的环境, JavaScript, C#, Java, C++ 等不同的开发语言中以及 VSCode 等不同的文本编辑器下, 正则表达式的匹配规则会有一些细微的差别.\n\n元字符不能写在字符集合 [ ] 的里面. [ ] 中的元字符全部会变为普通字符.\n\n\n普通元字符\n\n\n元字符\n描述\n\n\n\n.\n表示一个除换行符以外的任意字符\n\n\n()\n字符组, 占位长度和字符串长度一致, 匹配其中的字符串或者逻辑\n\n\n[ ]\n字符集合, 默认占位长度为 1, 匹配集合中的任意一个字符, 可以使用范围符 - 来表示范围, 如: 0-9, a-z, A-Z 等\n\n\n[^ ]\n否定字符集合, 默认占位长度为 1, 匹配集合中的所有字符以外的任意一个字符\n\n\n|\n逻辑或\n\n\n\\\n转义符\n\n\n字符集[注意] 字符集名称(大小写敏感), \\w 和 \\W 的含义完全相反.\n\n\n\n转义符\n描述\n\n\n\n\\f\n匹配一个换页符\n\n\n\\n\n匹配一个换行符\n\n\n\\r\n匹配一个回车符\n\n\n\\t\n匹配一个制表符\n\n\n\\v\n匹配一个垂直制表符\n\n\n\\w\n匹配所有字母和数字的字符, 某些环境下也会匹配汉字\n\n\n\\W\n匹配非字母和数字的字符, 某些环境下汉字也会排除\n\n\n\\d\n匹配数字: [0-9]\n\n\n\\D\n匹配非数字: [^ 0-9]\n\n\n\\s\n匹配任何空白字符, 包括空格, 制表符, 换页符等\n\n\n\\S\n匹配非空格符\n\n\n次数限定符写在一个特定的字符或者字符组 () 的后面, 控制字符或者字符组的出现次数.\n\n\n\n次数限定符\n描述\n\n\n\n*\n匹配前面的子表达式 0 次或多次\n\n\n+\n匹配前面的子表达式 1 次或多次\n\n\n?\n匹配前面的子表达式 0 次或 1 次, 或指明一个非贪婪限定符\n\n\n{n}\n花括号, 匹配前面字符或字符组 n 次\n\n\n{n,}\n花括号, 匹配前面字符或字符组至少 n 次\n\n\n{n,m}\n花括号, 匹配前面字符或字符组至少 n 次, 但是不超过 m 次\n\n\n定位符定位符表示字符所处的位置.\n\n\n\n定位符\n描述\n\n\n\n^\n表示行的开始\n\n\n$\n表示行的结束\n\n\n\\b\n匹配一个单词边界\n\n\n\\B\n非单词边界匹配\n\n\n前后缀逻辑 (断言)Q1: 匹配字符串中以全角美元符开头的 &#39;12000.00&#39;\n12000.00 ￥12000.00 ＄12000.00\nQ2: 匹配字符串中以全角美元符结尾的 &#39;12000.00&#39;\n12000.00 12000.00￥ 12000.00＄\n上面的两个问题, 就可以通过在正则表达式中添加前后缀逻辑来解决. &#39;前后缀逻辑&#39; 是我自己起的名字, 方便自己记忆, 但是有的文章中叫作 &quot;断言&quot;, 有的文章中叫 &quot;预匹配&quot;, 我都感觉好别扭啊!\n[注] 前后缀逻辑必须写在字符组 () 里面, 如: (?&lt;=K).\n前后缀逻辑组件[注] 下面是前后缀逻辑实现时用到的字符, 不能直接使用, 这样拆开写只是为了容易理解! 切记不可直接使用!\n\n\n\n符号\n描述\n\n\n\n?&lt;\n前缀描述符, 必须写在 &quot;被描述字符或字符组&quot; 的 前面\n\n\n?\n后缀描述符, 必须写在 &quot;被描述字符或字符组&quot; 的 后面\n\n\n&#x3D;\n是\n\n\n!\n不是\n\n\n前缀逻辑 (前行断言)\n\n\n\n符号\n描述\n\n\n\n(?&lt;&#x3D;)\n前缀为 描述符\n\n\n(?&lt;!)\n前缀不为 描述符\n\n\n[注] 前缀描述符必须写在 &quot;被描述字符或字符组&quot; 的 前面 ! 切记 !\n示例:\n(?&lt;=K)[0-9]&#123;11&#125;: 匹配以 &#39;K&#39; 为前缀的 11 位数字.\n(?&lt;!K)[0-9]&#123;11&#125;: 匹配不以 &#39;K&#39; 为前缀的 11 位数字.\n后缀逻辑 (后行断言)\n\n\n\n符号\n描述\n\n\n\n(?&#x3D;)\n后缀为 描述符\n\n\n(?!)\n后缀不为 描述符\n\n\n[注] 后缀描述符必须写在 &quot;被描述字符或字符组&quot; 的 后面 ! 切记 !\n示例:\n[\\d]&#123;11&#125;(?=K): 匹配以 &#39;K&#39; 为后缀的 11 位数字.\n[\\d]&#123;11&#125;(?!K): 匹配不以 &#39;K&#39; 为后缀的 11 位数字.\n答案A1: (?&lt;=＄)[\\d.]+ 答案不唯一\nA2: [\\d.]+(?=＄) 答案不唯一\n修饰符会修改正则表达式的匹配模式, 可以以任意顺序或组合使用, 先将要修饰的整个正则表达式前后加一个 / 字符, 然后在后面的 / 字符后面加修饰符.\n\n\n\n标记\n描述\n\n\n\ni\n不区分大小写: 将匹配设置为不区分大小写.\n\n\ng\n全局搜索: 搜索整个输入字符串中的所有匹配.\n\n\nm\n多行匹配: 会匹配输入字符串每一行.\n\n\n示例:\n\n/(T|t)he/gi : 全局搜索, 不区分大小写, 正则: (T|t)he\n\n/.(at)/g : 全局搜索, 正则: .(at)\n\n/at(.)?$/gm :全局搜索, 多行匹配, 正则: at(.)?$\n\n\nC# 中的正则表达式\n全部匹配\n\nusing System.Text.RegularExpressions;string content = &quot;content&quot;;Regex regex = new Regex(@&quot;[0-9]&#123;8&#125;&quot;);MatchCollection matchs = regex.Matches(content);foreach (Match match in matchs)&#123;    if (!string.IsNullOrEmpty(match.Value))    &#123;        //TODO...    &#125;&#125;\n\n\n匹配第一项\n\nusing System.Text.RegularExpressions;string content = &quot;content&quot;;Regex regex = new Regex(@&quot;[0-9]&#123;8&#125;&quot;);Match match = regex.Match(content);if (!string.IsNullOrEmpty(match.Value))&#123;    //TODO...&#125;\n","categories":["Program"],"tags":["Program"]},{"title":"UnityEditor 中制作和 Console 窗口一样可拖动的 Splitter 控件","url":"/unity_editor/unity_editor_console_splitter.html","content":"\n\n前言分享一个大佬写的 Splitter 控件, 主要是实现了和 Unity 原生 Console 窗口一样的效果, 有一条可以拖动的分割线, 用于将一个窗口分割成两部分.\n这就是最终实现的效果, 看一下是否满足你的需要, 如果正好满足, 那你就可以继续往下看了.\n\n代码结构主要由一个公共基类和一个自定义的窗口类构成.\n基类: Splitter基类主要负责的是控制分割条的拖动, 以及重新计算拖动分割条之后主区域和子区域的尺寸.\n下面是源码, 本质就只是一个 OnGUI 方法.\nusing UnityEngine;using UnityEditor;using System;namespace Kuroha.GUI.Editor.Splitter&#123;    [Serializable]    public abstract class Splitter    &#123;        internal enum SplitMode        &#123;            Horizontal,            Vertical        &#125;        // 不允许子类访问的字段        private EditorWindow editorWindow;        private MouseCursor mouseCursor;        private SplitMode splitMode;        private float lockSize;        private bool isResizing;        private bool isFreeze;        // 需要子类访问的字段        protected float barSize;        protected float mainAreaSize;        /// &lt;summary&gt;        /// 可触发鼠标变化的区域, 即分割条的全部有效区域        /// &lt;/summary&gt;        private Rect mouseCursorRect;        /// &lt;summary&gt;        /// 主区域占整个窗口的比例        /// &lt;/summary&gt;        private float mainAreaRatio = 0.5f;        /// &lt;summary&gt;        /// 专业版: 分割条的颜色        /// &lt;/summary&gt;        private static readonly Color splitterColorPro = Color.black;        /// &lt;summary&gt;        /// 免费版: 分割条的颜色        /// &lt;/summary&gt;        private static readonly Color splitterColorFree = Color.gray;        /// &lt;summary&gt;        /// 构造函数        /// &lt;/summary&gt;        /// &lt;param name=&quot;window&quot;&gt;使用当前布局的窗口&lt;/param&gt;        /// &lt;param name=&quot;splitMode&quot;&gt;分割方式, 分为上下切分和左右切分&lt;/param&gt;        /// &lt;param name=&quot;mainAreaSize&quot;&gt;主区域的默认大小, 上下切分时为默认高度, 左右切分时为默认宽度&lt;/param&gt;        /// &lt;param name=&quot;minSize&quot;&gt;主区域的最小大小, 上下切分时为最小高度, 左右切分时为最小宽度&lt;/param&gt;        /// &lt;param name=&quot;barSize&quot;&gt;分割条的有效大小, 即鼠标放置时会变化的区域, 上下切分时为有效高度, 左右切分时为有效宽度&lt;/param&gt;        /// &lt;param name=&quot;isFreeze&quot;&gt;是否冻结分割线 (不允许滑动调整范围)&lt;/param&gt;        internal Splitter(EditorWindow window, SplitMode splitMode, float mainAreaSize, float minSize, float barSize, bool isFreeze)        &#123;            editorWindow = window;            this.mainAreaSize = mainAreaSize;            this.splitMode = splitMode;            lockSize = minSize;            this.barSize = barSize;            this.isFreeze = isFreeze;            mouseCursor = this.splitMode == SplitMode.Vertical                ? MouseCursor.ResizeHorizontal                : MouseCursor.ResizeVertical;        &#125;        /// &lt;summary&gt;        /// 主窗口        /// &lt;/summary&gt;        /// &lt;param name=&quot;rect&quot;&gt;区域矩形&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        protected abstract Rect MainRect(Rect rect);        /// &lt;summary&gt;        /// 子窗口        /// &lt;/summary&gt;        /// &lt;param name=&quot;rect&quot;&gt;区域矩形&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        protected abstract Rect SubRect(Rect rect);        /// &lt;summary&gt;        /// 分割条的全部区域        /// &lt;/summary&gt;        /// &lt;param name=&quot;rect&quot;&gt;区域矩形&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        protected abstract Rect BarRect(Rect rect);        /// &lt;summary&gt;        /// 分割条的无色区域        /// 默认分割条为 16 像素, 这里设置顶部 7 像素和 底部 8 像素都不显示, 仅显示中间的 1 个像素.        /// 但是整个厚度为 16 像素的区域都可以触发鼠标变化, 可以触发拖拽.        /// &lt;/summary&gt;        protected abstract RectOffset BarRectOffset();        /// &lt;summary&gt;        /// 绘制界面        /// &lt;/summary&gt;        /// &lt;param name=&quot;windowRect&quot;&gt;&lt;/param&gt;        /// &lt;param name=&quot;mainGUI&quot;&gt;&lt;/param&gt;        /// &lt;param name=&quot;subGUI&quot;&gt;&lt;/param&gt;        public void OnGUI(Rect windowRect, Action&lt;Rect&gt; mainGUI, Action&lt;Rect&gt; subGUI)        &#123;            var current = Event.current;            // 绘制主区域内容            mainGUI(MainRect(windowRect));            // 绘制子区域内容            subGUI(SubRect(windowRect));            // 分割条全部有效区域 (可触发鼠标变化的整个区域, 外观上部分不显示)            mouseCursorRect = BarRect(windowRect);            EditorGUIUtility.AddCursorRect(mouseCursorRect, mouseCursor);                        if (isFreeze == false)            &#123;                // 单个区域的最大大小                var clampMax = splitMode == SplitMode.Vertical ? windowRect.width - lockSize : windowRect.height - lockSize;                                // 整个区域的最大大小 (两个区域之和, 即整个显示区域的大小)                var targetSplitterValue = splitMode == SplitMode.Vertical ? windowRect.width : windowRect.height;                                // 主区域占整个区域的比例                mainAreaRatio = splitMode == SplitMode.Vertical ? mainAreaSize / windowRect.width : mainAreaSize / windowRect.height;                                // 鼠标点击了分割条                if (current.type == EventType.MouseDown)                &#123;                    if (mouseCursorRect.Contains(current.mousePosition))                    &#123;                        isResizing = true;                    &#125;                &#125;                // 鼠标松开                if (current.type == EventType.MouseUp)                &#123;                    isResizing = false;                &#125;                // 鼠标按住分割条并滑动                if (isResizing)                &#123;                    if (current.type == EventType.MouseDrag)                    &#123;                        var targetValue = splitMode == SplitMode.Vertical ? current.mousePosition.x : current.mousePosition.y;                        var diffValue = splitMode == SplitMode.Vertical ? windowRect.width : windowRect.height;                        mainAreaRatio = targetValue / diffValue;                    &#125;                &#125;                else if (current.type != EventType.Layout &amp;&amp; current.type != EventType.Used)                &#123;                    mainAreaRatio = targetSplitterValue * mainAreaRatio / targetSplitterValue;                &#125;                                // 计算主区域大小                mainAreaSize = Mathf.Clamp(targetSplitterValue * mainAreaRatio, lockSize, clampMax);            &#125;                        // 绘制分割条            var color = EditorGUIUtility.isProSkin ? splitterColorPro : splitterColorFree;                        // API: RectOffset.Remove(rect) =&gt; 从指定的 rect 中移除 RectOffset 偏移            EditorGUI.DrawRect(BarRectOffset().Remove(mouseCursorRect), color);            // 即时刷新            if (isResizing)            &#123;                editorWindow.Repaint();            &#125;        &#125;    &#125;&#125;\n\n自定义窗口类自定义窗口类就是我们实际构建的窗口, 它需要继承自基类 Splitter, 并且重写基类中的 4 个区域方法: MainRect, SubRect, BarRect, BarRectOffset.\n下面是动图中横向分割窗口的源码:\nusing UnityEditor;using UnityEngine;using System;namespace Kuroha.GUI.Editor.Splitter&#123;    [Serializable]    public class HorizontalSplitter : Splitter    &#123;        /// &lt;summary&gt;        /// 分割条的无色区域        /// 默认分割条为 16 像素, 这里设置顶部 7 像素和 底部 8 像素都不显示, 仅显示中间的 1 个像素.        /// 但是整个厚度为 16 像素的区域都可以触发鼠标变化, 可以触发拖拽.        /// &lt;/summary&gt;        private static RectOffset barRectOffset;        /// &lt;summary&gt;        /// 分割条大小        /// &lt;/summary&gt;        private const int BAR_SIZE = 16;                /// &lt;summary&gt;        /// 构造函数        /// &lt;/summary&gt;        /// &lt;param name=&quot;window&quot;&gt;使用当前布局的窗口&lt;/param&gt;        /// &lt;param name=&quot;mainSize&quot;&gt;主区域的默认大小, 上下切分时为默认高度, 左右切分时为默认宽度&lt;/param&gt;        /// &lt;param name=&quot;minSize&quot;&gt;主区域的最小大小, 上下切分时为最小高度, 左右切分时为最小宽度&lt;/param&gt;        /// &lt;param name=&quot;isFreeze&quot;&gt;是否冻结分割线 (不允许滑动调整范围)&lt;/param&gt;        public HorizontalSplitter(EditorWindow window, float mainSize, float minSize, bool isFreeze)            : base(window, SplitMode.Horizontal, mainSize, minSize, BAR_SIZE, isFreeze) &#123; &#125;        /// &lt;summary&gt;        /// 分割条的无色区域        /// &lt;/summary&gt;        /// &lt;returns&gt;&lt;/returns&gt;        protected override RectOffset BarRectOffset()        &#123;            return barRectOffset ??= new RectOffset(0, 0, 7, 8);        &#125;        /// &lt;summary&gt;        /// 主区域        /// &lt;/summary&gt;        /// &lt;param name=&quot;rect&quot;&gt;&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        protected override Rect MainRect(Rect rect)        &#123;            return new Rect(rect)            &#123;                x = 0,                y = 0,                height = mainAreaSize            &#125;;        &#125;        /// &lt;summary&gt;        /// 子区域        /// &lt;/summary&gt;        /// &lt;param name=&quot;rect&quot;&gt;&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        protected override Rect SubRect(Rect rect)        &#123;            return new Rect(rect)            &#123;                x = 0,                y = mainAreaSize + 5,                height = rect.height - mainAreaSize - 15            &#125;;        &#125;        /// &lt;summary&gt;        /// 分割条        /// &lt;/summary&gt;        /// &lt;param name=&quot;rect&quot;&gt;&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        protected override Rect BarRect(Rect rect)        &#123;            return new Rect(rect)            &#123;                x = 0,                y = mainAreaSize - barSize / 2,                height = barSize            &#125;;        &#125;    &#125;&#125;\n\n下面是动图中纵向分割窗口的源码:\nusing System;using UnityEditor;using UnityEngine;namespace Kuroha.GUI.Editor.Splitter&#123;    [Serializable]    public class VerticalSplitter : Splitter    &#123;        /// &lt;summary&gt;        /// 分割条的无色区域        /// 默认分割条为 16 像素, 这里设置顶部 7 像素和 底部 8 像素都不显示, 仅显示中间的 1 个像素.        /// 但是整个厚度为 16 像素的区域都可以触发鼠标变化, 可以触发拖拽.        /// &lt;/summary&gt;        private static RectOffset barRectOffset;                /// &lt;summary&gt;        /// 分割条大小        /// &lt;/summary&gt;        private const int BAR_SIZE = 16;        /// &lt;summary&gt;        /// 构造函数        /// &lt;/summary&gt;        /// &lt;param name=&quot;window&quot;&gt;使用当前布局的窗口&lt;/param&gt;        /// &lt;param name=&quot;mainSize&quot;&gt;主区域的默认大小, 上下切分时为默认高度, 左右切分时为默认宽度&lt;/param&gt;        /// &lt;param name=&quot;minSize&quot;&gt;主区域的最小大小, 上下切分时为最小高度, 左右切分时为最小宽度&lt;/param&gt;        /// &lt;param name=&quot;isFreeze&quot;&gt;是否冻结分割线 (不允许滑动调整范围)&lt;/param&gt;        public VerticalSplitter(EditorWindow window, float mainSize, float minSize, bool isFreeze)            : base(window, SplitMode.Vertical, mainSize, minSize, BAR_SIZE, isFreeze) &#123; &#125;        /// &lt;summary&gt;        /// 分割条的无色区域        /// &lt;/summary&gt;        /// &lt;returns&gt;&lt;/returns&gt;        protected override RectOffset BarRectOffset()        &#123;            return barRectOffset ??= new RectOffset(7, 8, 0, 0);        &#125;        /// &lt;summary&gt;        /// 主区域        /// &lt;/summary&gt;        /// &lt;param name=&quot;rect&quot;&gt;&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        protected override Rect MainRect(Rect rect)        &#123;            return new Rect(rect)            &#123;                x = 0,                y = 0,                width = mainAreaSize            &#125;;        &#125;        /// &lt;summary&gt;        /// 子区域        /// &lt;/summary&gt;        /// &lt;param name=&quot;rect&quot;&gt;&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        protected override Rect SubRect(Rect rect)        &#123;            return new Rect(rect)            &#123;                x = mainAreaSize + 5,                y = 0,                width = rect.width - mainAreaSize - 15            &#125;;        &#125;        /// &lt;summary&gt;        /// 分割条        /// &lt;/summary&gt;        /// &lt;param name=&quot;rect&quot;&gt;&lt;/param&gt;        /// &lt;returns&gt;&lt;/returns&gt;        protected override Rect BarRect(Rect rect)        &#123;            return new Rect(rect)            &#123;                x = mainAreaSize - barSize / 2,                y = 0,                width = barSize            &#125;;        &#125;    &#125;&#125;\n\n应用最后再分享一个我实际项目中的应用:\n\n参考链接Console Window で利用されているような Splitter を作る\n","categories":["UnityEditor"],"tags":["UnityEditor","Splitter"]},{"title":"Unity Plugins Odin","url":"/unity_editor/unity_editor_odin.html","content":"\n\n Odin\n立即刷新\n  Sirenix.Utilities.Editor.GUIHelper.RequestRepaint();\n\n取一个随机的 [0, 1) 值 [正弦函数]\n  Mathf.Abs(Mathf.Sin((float)EditorApplication.timeSinceStartup))\n\nOdin 中一些需要引用变量值或者需要引用方法的地方都可以使用美元符号来引用\n  Required(&quot;$变量名&quot;) Required(&quot;$方法名&quot;)\n\nOdin 中也可以使用 @ 字符来直接引用方法体内容, 在方法体很短很短的时候可以用一下\n\nEditorGUI.BeginChangeCheck() 和 if (EditorGUI.EndChangeCheck()) 可以实现监控 GUI 变更\n\nEditorGUIUtility.isProSkin 判断是否是黑色主题\n\n得到 Android 平台当前导入设置的尺寸和压缩格式\n  return textureImporter.GetPlatformTextureSettings(&quot;Android&quot;, out var maxSize, out var format);\n\n其中平台名称可选 &quot;Standalone&quot;, &quot;Web&quot;, &quot;iPhone&quot;, &quot;Android&quot;, &quot;WebGL&quot;, &quot;Windows Store Apps&quot;, &quot;PS4&quot;, &quot;XboxOne&quot;, &quot;Nintendo Switch&quot;, &quot;tvOS&quot;.\n\n\n得到默认的导入设置 textureImporter.GetDefaultPlatformTextureSettings()\n\n修改 Mesh 的压缩等级\n  MeshUtility.SetMeshCompression(Mesh mesh, ModelImporterMeshCompression level);\n\n\nAssetsOnly修饰一个字段, 这个字段只能使用 Project 面板中资源赋值\nSceneObjectsOnly修饰一个字段, 这个字段只能使用 Scene 中的物体赋值\nCustomValueDrawer使用自定义方法来绘制字段的 Inspector\n// 用特性修饰字段, 并且引用自定义的界面绘制方法[CustomValueDrawer(nameof(MyCustomDrawer))]public float CustomDrawerStatic;// 界面绘制方法private static float MyCustomDrawer(float value, GUIContent label) &#123; return EditorGUILayout.Slider(label, value, 0f, 10f); &#125;\n\nDelayed  DelayedProperty分别修饰字段和属性, 让用户的修改不再实时生效, 而是当用户按下 Enter 时或者控件丢失焦点时生效\nDetailedInfoBox修饰一个字段, 在其上方展示一个消息框\n可以使用 InfoMessageType 来控制消息框中显示什么样的图标, None 为不显示图标, 默认为 Info\n可以使用 VisibleIf(nameof(function)) 来控制消息框的显示与隐藏\nShowInInspector可以修饰字段与属性, 将值显示在面板中\n但是此特性仅仅实现了对值的显示, 无法保存修改\n对于仅有 get 器的属性, 显示在面板中的时候是灰色的\nEnableGUI当仅有 get 器的属性使用 ShowInInspector 修饰后显示在面板中的时候是灰色的, 此时再使用此特性修饰, 显示的属性将不再是灰色的\nGUIColor以指定的颜色来绘制 GUI\n可以直接串 3 ~ 4 个数字来控制颜色, 也可以传一个返回值为 Color 的方法名称, 使用 nameof 关键字\nHideLabel可以隐藏界面上的变量名, 只显示变量值\n[PropertyOrder(-1)]用来控制属性在界面上的显示顺序, 数字小的先显示, 允许负数\n[PropertySpace(SpaceBefore = 30, SpaceAfter = 30)]控制一个的属性或者字段的上下空白间距\nReadOnly和 EnableGUI 正好相反, 此特性修饰后, 显示将变为灰色, 当仅显示数值而不允许修改的时候使用\nRequired当修饰的值为 null 的时候会提示错误信息\n可以使用 Required(&quot;自定义错误提示信息&quot;) 来自定义提示的信息\n另外需要显示动态提示的时候可以使用 Required(&quot;$变量名&quot;) Required(&quot;$方法名&quot;) 来实现, 但是这里不能使用 nameof, 只能使用名称字符串\nSearchable通过添加特性为字段其添加一个搜索框, 可用于搜索对应的类或其子类的成员, 但目前不可用于字典类型\n\n也可以直接修饰 MonoBehavior 类, 此时会在界面顶部显示一个搜索框\n\n还可以通过实现 ISearchFilterable 接口来自定义搜索规则\n  Searchable(FilterOptions = SearchFilterOptions.ISearchFilterableInterface)\n\n但是目前此属性在搜索数字 0 1 2 的时候会有 Bug, 再加上这个界面上很少使用搜索, 因此默认禁用\n\n\nTitle在字段上方显示标题\n可以显示主标题 + 副标题, 默认主标题为加粗 + 分割线\n可以使用 bold 参数控制是否是粗体\n可以使用 horizontalLine 参数控制是否显示分割线\n可以使用 TitleAlignments 参数控制主标题和副标题的对齐方式\nTypeFilter此特性的应用场景是显示的字段是基类型, 并且它还有好几个子类型, 于是编辑器就不知道该序列化哪个了\n所以就有了这个筛选类型的特性, 来决定这个字段按照什么类型来序列化\n由于筛选函数是自定义的, 因此也可以指定只能选择特定的类型\npublic IEnumerable&lt;Type&gt; GetFilteredTypeList()&#123;    var types = typeof(BaseClass).Assembly.GetTypes()        // 非抽象类 (这里 BaseClass 是 abstract 类)        .Where(type =&gt; !type.IsAbstract)        // 非泛型类        .Where(type =&gt; !type.IsGenericTypeDefinition)        // 是 BaseClass 的派生类        .Where(type =&gt; typeof(BaseClass).IsAssignableFrom(type));    // 按照需求添加指定的类型    types = types.AppendWith(typeof(C1&lt;&gt;).MakeGenericType(typeof(GameObject)));    types = types.AppendWith(typeof(C1&lt;&gt;).MakeGenericType(typeof(AnimationCurve)));    types = types.AppendWith(typeof(C1&lt;&gt;).MakeGenericType(typeof(List&lt;float&gt;)));    return types;&#125;\n\nTypeInfoBox用来修饰 MonoBehavior 以及 ScriptableObject, 可以在类型的最上方显示一条信息\nValidateInput变量输入值验证\n\n传入方法名以及消息内容 [ValidateInput(nameof(IsRight), &quot;输入值不正确!&quot;)]\n可以通过 InfoMessageType 来控制显示的图标类型\n\nValueDropdown用来实现一个下拉框\n下拉框所需要的数据 [ MemberName ] 有两种传参方式\n\n传递 数组 或者 链表 int[] Vector3[] List&lt;GameObject&gt; 数组及链表的内容会同时作为下拉框选项的显示文本和选项的实际值\n传递 下拉列表 ValueDropdownList&lt;T&gt; 这个类型是一个键值对链表, Key 为 string 类型, Value 为自定义泛型 T, 这种情况下, Key 会作为下拉框的显示文本, Value 则会作为选项的实际值, 一般常用 &lt;string, string&gt; 和 &lt;string, int&gt;\n\n\n\n\n参数名\n参数类型\n参数默认值\n参数说明\n\n\n\nSortDropdownItems\nbool\nfalse\n参数设置为 true 的时候, Key 的显示会按照字母升序来进行排序, false 时不进行排序\n\n\nDropdownTitle\nstring\nnull\n给下拉框设置一个标题\n\n\nDropdownHeight\nint\n自适应\n固定下拉框的高度\n\n\nDropdownWidth\nint\n自适应\n固定下拉框的宽度\n\n\nFlattenTreeView\nbool\nfalse\n是否平铺树形视图, 默认为 false 使用树形视图, 如果设置为 true, 则会使用平铺视图;树形数据使用 &#x2F; 来分割层级\n\n\nDoubleClickToConfirm\nbool\nfalse\ntrue: 双击选中选项一般当数据源为树形结构时使用\n\n\nHideChildProperties\nbool\nfalse\ntrue: 会隐藏掉属性自身的面板绘制比如 Vector3 类型就没有的自身的 x y z 三个输入框绘制, 只保留一个 (x, y, z) 的下拉框\n\n\nAppendNextDrawer\nbool\nfalse\ntrue: 使用一个子菜单 ︙ 来代替下拉框此时字段显示的数值为下拉框的值, 而不是显示文本\n\n\nDisableGUIInAppendedDrawer\nbool\nfalse\n配合 AppendNextDrawer 使用AppendNextDrawer 会导致字段显示的是下拉框的值, 而不是显示文本, 所以可以对值进行修改DisableGUIInAppendedDrawer 设置为 true 时, 字段显示的值将会是灰色的, 无法修改\n\n\nExpandAllMenuItems\nbool\nfalse\n设置为 true 之后, 则会默认展开整个树形结构, 否则默认折叠整个树形结构\n\n\nIsUniqueList\nbool\nfalse\n是否是多选列表设置为 true 时将可以选择多个选项添加到列表, 选择完成后点击 √\n\n\nExcludeExistingValuesInList\nbool\nfalse\n是否排除已存在的值, false 表示可以重复添加, true 则不允许添加重复值\n\n\nDisableListAddButtonBehaviour\nbool\nfalse\n禁用下拉列表, 以弹窗的形式弹出\n\n\nDrawDropdownForListElements\nbool\nfalse\n是否为列表元素绘制下拉框, 默认绘制\n\n\nNumberOfItemsBeforeEnablingSearch\nint\n10\n当下拉框的选项个数超出指定个数后, 绘制搜索框\n\n\nAssetList用于生成一个资源列表, 这个列表用来给修饰的字段赋值, 资源列表的资源来源是 Project 面板中的资源, 并不是 Hierarchy 中的游戏物体\n因此这里的字段大多是 Texture, Sprite 等资源类型, 即使是 GameObject 指代的也是预制体而不是场景物体\n可以修饰 UnityEngine.Object 类型的 单个字段 或者 数组字段 或者 列表字段\n参数1: Path 用于指定资源列表的来源, 不传 Path 则默认为 Assets 目录下的全部资源\n参数2: AutoPopulate 是否自动将符合条件的资源添加到修饰的字段中\n参数3: CustomFilterMethod 自定义筛选方法, 方法的参数为字段的元素类型\n比如字段为 GameObject, 那么筛选方法的参数就是 GameObject 类型 private bool Filter(GameObject obj)\n比如字段为 List, 那么筛选方法的参数就是 Sprite 类型 private bool Filter(Sprite sprite)\n参数4: LayerNames 根据 Layer 来筛选预制体资源, 由于只有预制体有标签, 所以只能修饰 GameObject 类型\n参数5: Tags 根据 Tag 来筛选预制体资源, 可以使用 , 分割多个标签 Tags = &quot;TagA,TagB&quot;\n参数6: AssetNamePrefix 根据名称的前缀来筛选资源\nAssetSelector修饰单个字段, 会在字段前显示一个 ︙ 符号, 产生一个资源选择框\n修饰列表字段, 会在最右侧产生一个 + 号, 用于选择资源\nFlattenTreeView 参数: 控制是否将树形结构平铺, 默认为 false 不平铺\nPaths 参数: 限定资源选择的路径, 默认为 Assets 目录下的全部资源\nFilter 参数: 筛选器, 字符串类型参数, 字符串规则就是 Unity 的搜索规则 name t:Model l:Water\nDropdownTitle 参数: 定义选择框标题\nExpandAllMenuItems 参数: 是否强制展开树形结构\nIsUniqueList 参数: 是否可以一次添加多个 false: 一次只能添加一个资源到列表\nExcludeExistingValuesInList 参数: 是否排除已存在列表中的资源 (即使显示已存在的资源, 也不允许选择同一个资源两次)\nDrawDropdownForListElements: 是否给列表中的元素绘制下拉框\nDisableListAddButtonBehaviour: 以弹窗的方式取代下拉框\nChildGameObjectsOnly用于限制字段的值只能是子物体或自身上的组件\nColorPalette修饰一个 Color 字段以及数组列表, 会产生一个调色板选择器, 可以选择不用的调色板, 之后再选择调色板上具有的颜色给 Color 字段赋值\n\nPaletteName: 指定调色板名称\n  指定名称时, 除了直接写明调色板的名称, 也可以引用变量值\n  [ColorPalette(&quot;$字符串变量名&quot;)]\n  还可以使用运算表达式, 比如下方将会引用 &quot;调色板_1&quot;, &quot;调色板_2&quot;, &quot;调色板_3&quot; 之类的\n  [ColorPalette(&quot;@&quot;调色板_&quot; + 数字变量&quot;)]\n\nShowAlpha: 颜色值显示时是否在下方显示 Alpha 通道状态\n\n\nDisplayAsString用于任何属性, 对应的值在检查器中以文本形式显示字符串.\n如果属性的值要在检查器中显示字符串, 但不允许进行任何编辑, 则推荐使用此特性\nHideLabel用于任何属性, 隐藏其属性名称, 仅显示属性的值\nFilePath FolderPath用于字符串属性以及字符串的数组和列表, 会显示一个文件夹图标, 用于选择文件给字符串赋值为选择文件的相对路径\nParentFolder: 自定义相对文件夹, 默认为相对 Assets 文件夹\n[仅 FilePath]  Extensions &#x3D; &quot;cs, lua&quot;: 限定文件的后缀\nAbsolutePath: 赋值的时候为绝对路径, 默认是 false, 此时使用的是相对路径\nRequireExistingPath: 要求路径必须存在, 不存在时显示错误信息\nUseBackslashes: 默认为 false, 此时使用 &#x2F; 分割目录, 设置为 true, 则使用 \\ 分割目录\nToggle修饰含有 bool 类型变量的结构体或者类\n需要一个必填参数: 类或者结构体中 bool 类型的变量的名称\n[Toggle(nameof(MyToggleable.enabled))]public MyToggleable toggler = new MyToggleable();[Serializable]public class MyToggleable&#123;    public bool enabled;    public int myValue;&#125;\n\n","categories":["Unity"],"tags":["Odin"]},{"title":"Unity 自定义编辑器","url":"/unity_editor/unity_editor.html","content":"\n\n如何添加嵌套资源AssetDatabase.AddObjectToAsset(asset, prefab);\n\n如何完整地拷贝一个组件UnityEditorInternal.ComponentUtility.CopyComponent(collider);UnityEditorInternal.ComponentUtility.PasteComponentAsNew(colliderObject);\n\n如何获取全部特定类型的物体// ResourcesResources.FindObjectsOfTypeAll&lt;Transform&gt;();// ObjectOfUnityEngine.Object.FindObjectOfType&lt;FunnyToolController&gt;(true);// ObjectByUnityEngine.Object.FindObjectsByType&lt;Transform&gt;(FindObjectsInactive.Include, FindObjectsSortMode.None);\n\n如何改变反射出来的值的类型memoryProfilerWindow = Convert.ChangeType(window, memoryProfilerWindowClass);\n\n相对路径和绝对路径的转换selectedMatCapPath = FileUtil.GetProjectRelativePath(selectedMatCapPath);\n\nUnity Selection 类先说一下 Unity.Selection 类, 这个类可以获取我们在编辑器模式下的输入, 因为编辑器模式下各种方法逻辑的触发更多的是使用按钮的方法, 所以获取输入是排在第一位的.\nSelection.activeTransform仅在 Hierarchy 面板中生效;\n这个静态字段会返回在 Hierarchy 面板中选中的游戏物体;\n如果选择多个则只返回第一个; 如果没有选择, 则返回 null; null 可以直接在 if 中进行判断, 相等于 false.\nSelection.activeGameObject在 Hierarchy 面板和 Project 面板中都有效;\n在 Hierarchy 面板中返回的是当前选中的游戏物体(任意物体);\n在 Project 面板中返回的是当前选中的预制体(Prefab);\n如果选择多个则只返回第一个; 如果没有选择或者选择的目标不符合上述条件的都会返回 null.\nSelection.activeObject在 Hierarchy 面板和 Project 面板中都有效;\n在 Hierarchy 面板中返回的是当前选中的游戏物体(任意物体);\n在 Project 面板中返回的是当前选中的任意资源;\n如果选择多个则只返回第一个; 如果没有选择或者选择的目标不符合上述条件的都会返回 null.\nSelection.transformsSelection.activeTransform 方法的复数版本, 返回一个数组, 包含所有符合 Selection.activeTransform 条件的物体.\nSelection.gameObjectsSelection.activeGameObject 方法的复数版本, 返回一个数组, 包含所有符合 Selection.activeGameObject 条件的物体.\nSelection.objectsSelection.activeObject 方法的复数版本, 返回一个数组, 包含所有符合 Selection.activeObject 条件的物体.\nSelection.selectionChanged一个委托, 当选择的东西发生变化的时候会自动调用. 可以用来监测选择的游戏物体是否发生了改变.\nC# 特性 [MenuItem(&quot;A&#x2F;B&quot;, true, 15)]MenuItem 特性用于向主菜单 (Unity 标题栏下的一行菜单) 和检视面板上下文菜单 (也就是 Inspector 的设置菜单 CONTEXT 菜单) 添加菜单项.\n能够将任何静态函数转变为菜单命令, 仅静态函数可使用 MenuItem 特性, 另外 Unity 还支持创建带有热键的菜单项哦.\n\n\n\n代码示例\n效果\n\n\n\n%\nCtrl\n\n\n#\nShift\n\n\n&amp;\nAlt\n\n\nLEFT, RIGHT, UP, DOWN\nLEFT, RIGHT, UP, DOWN\n\n\nF1 .. F12\nF1 .. F12\n\n\nHOME, END, PGUP, PGDN\nHOME, END, PGUP, PGDN\n\n\nMyMenu&#x2F;Do Something #&amp;g\nShift + Alt + g\n\n\nMyMenu&#x2F;Do Something _g\ng\n\n\nMenuItem 的第一个参数为菜单项的路径和名称.\n如果要扩展 Project 面板的右键菜单, 则路径必须以 Assets 开头.\n如果要扩展 Hierarchy 面板的右键菜单, 则路径必须以 GameObject 开头.\n以其他名称开头时, 创建的菜单会显示在主菜单上.\n\nMenuItem 的第二个参数标记方法是否为同名菜单项的验证方法.\n当被修饰方法返回值不是 bool 类型时, 始终应设置为 false.\n当被修饰方法返回值是 bool 类型时:\ntrue: 当被修饰方法返回 false 时, 同名的菜单项会隐藏; 当被修饰方法返回 true 时, 同名的菜单项才会显示出来.\nfalse: 标记此方法不是同名菜单项的验证方法. (当然此时的 bool 返回值也就没有了意义)\n\n\n\n因此这个参数的使用场景为:\n当某个菜单项只能在某些特定条件下才能显示的时候使用, 创建两个同名的 MenuItem(), 其中一个设置第二个参数为 true, 逻辑就是菜单项显示条件, 而另一个则是真正的菜单项方法.\nMenuItem 的第三个参数是显示优先级.\n优先级打开主菜单查看当前有多少菜单项, 依次向后排序即可.\n如果想要让菜单项在 Hierarchy 面板的右键菜单中也显示出来的话, 推荐将优先级设置为大于等于 11 的数值, 因为 0 - 10 优先级会导致自定义的菜单项穿插在 Unity 原生菜单项中间, 具体每个优先级的位置可以参照下面的图片.\n\nMenuItem 的优先级排序\n\n结论:\n\n负优先级 和 0 ~ 49, 会同时显示在顶部菜单和右键菜单中.\n顶层菜单项之间相差 11 及以上会产生分割线, 相差 10 不行.\n顶部菜单项的子菜单项之间相差 11 也会产生分割线, 但是右键菜单的子菜单项之间即使相差 100 也不会产生分割线.\n即使是相同优先级, 只要菜单项名称不同则都会显示.\n具有子菜单项的菜单, 他的优先级和优先级最高的子菜单项保持一致.\n从优先级 11 开始, 自定义菜单项就会全部显示在 Unity 原生菜单项的下方.\n如果有一个菜单项的名称刚好和一些子菜单项的顶层菜单名称一致了, 那么这个菜单项会丢失, 仅剩下子菜单项的顶层菜单, 仅作为菜单项的文件夹, 无任何作用.\n\n扩展 Project 视图扩展 Project 视图的右键菜单\n定义静态行为类: 无继承关系, 放到 Editor 文件夹下.\n定义菜单项: [MenuItem(&quot;Menu Item Path&quot;, false, 1)].\n扩展 Project 视图时, 菜单项的路径必须以 Assets&#x2F; 开头, 原因是 Project 视图的右键菜单就是标题栏中的 Assets 菜单.\n如果以标题栏中没有的名称作为路径开头, 则标题栏中会出现一个新的对应名称的菜单.\n定义菜单行为方法: 菜单行为方法推荐是 private static void FunctionName() 类型.\n\n扩展 Project 布局扩展 Project 布局的原理就是 Unity 会监听 EditorApplication.projectWindowItemOnGUI 渲染回调, 因此脚本代码的思路就是写一个方法用来对委托 EditorApplication.projectWindowItemOnGUI 进行注册. 并且这个方法必须在 C# 代码编译完成后立即自动执行.\nUnity 中提供了实现这个效果的属性, 使用 [InitializeOnLoadMethod] 属性可以让被修饰的方法在代码编译完成后自动执行.\n有了自动执行的方法了, 那么我们就可以在这个方法中, 对 EditorApplication.projectWindowItemOnGUI 委托进行注册. 注册的内容就是我们想要实现的操作.\n/// &lt;summary&gt;/// 扩展 Project 布局/// &lt;/summary&gt;// 由于扩展布局的方法无法进行手动调用, 所以使用这个属性进行自动调用[InitializeOnLoadMethod]private static void InitializeOnLoadMethod()&#123;    // 对 projectWindowItemOnGUI 进行注册    EditorApplication.projectWindowItemOnGUI += (guid, selectionRect) =&gt;    &#123;        // 前提是必须选中预制体 Prefab        if (!Selection.activeGameObject)        &#123;            return;        &#125;        if (guid != AssetDatabase.AssetPathToGUID(AssetDatabase.GetAssetPath(Selection.activeGameObject)))        &#123;            return;        &#125;        // 定义绘制按钮时需要用到的矩形, selectionRect 原本是当前选中时 Unity 中的蓝色的高亮矩形框.        const float WIDTH = 50f;        Rect projectRect = new Rect(            selectionRect.x += selectionRect.width - WIDTH,            selectionRect.y,            WIDTH,            selectionRect.height);        // 设置接下来绘制按钮时要使用的颜色        GUI.color = Color.red;        // 绘制按钮, 显示文本: click        if (GUI.Button(projectRect, &quot;click&quot;))        &#123;            // 定义按钮点击后的行为            Debug.Log($&quot;click: &#123;Selection.activeObject.name&#125;&quot;);        &#125;        // 绘制完成后将颜色重置        GUI.color = Color.white;    &#125;;&#125;\n\n扩展 Hierarchy 视图扩展 Hierarchy 视图的右键菜单[注] 扩展 Project 视图的脚本和扩展 Hierarchy 视图的脚本不能是一个, 必须分开.\n\n扩展 Hierarchy 视图和扩展 Project 视图的操作相同, 只是菜单项的路径必须以 GameObject&#x2F; 开头, 原因是 Hierarchy 视图的右键菜单就是标题栏中的 GameObject 菜单.\n\nHierarchy 视图的右键菜单的顺序扩展 Hierarchy 布局\n扩展 Hierarchy 布局和扩展 Project 布局是一样的原理, 只不过监听的是另一个委托: EditorApplication.hierarchyWindowItemOnGUI.\n\n[InitializeOnLoadMethod]private static void InitOnLoad() &#123;    EditorApplication.hierarchyWindowItemOnGUI += (instanceID, selectionRect) =&gt; &#123;        if (!Selection.activeObject) return;        if (instanceID != Selection.activeObject.GetInstanceID()) return;        const string PREFAB_PATH = &quot;Assets/1.prefab&quot;;        const string TEXTURE_PATH = &quot;Assets/unity.png&quot;;        const float WIDTH = 32f;        const float HEIGHT = 16f;        var hierarchyRect = new Rect(            selectionRect.width - WIDTH, selectionRect.y,            WIDTH, HEIGHT);        // 加载资源: AssetDatabase.LoadAssetAtPath        var texture = AssetDatabase.LoadAssetAtPath&lt;Texture&gt;(TEXTURE_PATH);        if (!GUI.Button(hierarchyRect, texture)) return;        // 更新或者创建 Prefab        PrefabUtility.SaveAsPrefabAssetAndConnect(Selection.activeGameObject, PREFAB_PATH, InteractionMode.AutomatedAction);        AssetDatabase.Refresh();    &#125;;&#125;\n\n扩展 Inspector 视图扩展 Inspector 视图就和上面两种完全不一样了. Inspector 视图是用来显示类 (组件本质就是一个类) 中的信息的, 由于类中会有各种各样的千奇百怪的数据类型, 因此 Unity 提供了大量的控件来帮助开发者自定义 Inspector 视图.\n重写 Inspector 面板需要做的事情:\n\n继承 UnityEditor.Editor 类.\n使用特性 CustomEditor(typeof()) 关联要显示的类.\n重写 OnInspectorGUI() 方法.\n绘制各种组件.\n\n扩展原生类组件扩展原生类组件的 Inspector 面板就是重写 OnInspectorGUI() 方法, 这个方法就是用来绘制 Inspector 面板的.\n如果需要显示原本组件的的 Inspector 面板信息, 可以调用父类的方法: base.OnInspectorGUI();.\n[CustomEditor(typeof(Camera))]public class ExpendInspector : Editor &#123;    public override void OnInspectorGUI() &#123;        if (GUILayout.Button(&quot;扩展按钮&quot;)) &#123;            Debug.Log(&quot;测试按钮&quot;);        &#125;                base.OnInspectorGUI();    &#125;&#125;\n\n扩展继承类组件对于我们重写界面而言, 继承类组件与原生类组件的不同之处就是不能调用 base.OnInspectorGUI(); 方法, 或者调用 base.OnInspectorGUI(); 时不会出现组件原本的显示效果, 显示效果会变得很糟糕. 因此我们需要使用反射机制来实现调用真正的 OnInspectorGUI() 方法.\n[CustomEditor(typeof(Transform))]public class ExpendInspector : Editor &#123;    private Editor editor;    private void OnEnable() &#123;        editor = Editor.CreateEditor(target,            Assembly.GetAssembly(typeof(Editor)).GetType(&quot;UnityEditor.TransformInspector&quot;, true));    &#125;    public override void OnInspectorGUI() &#123;        if (GUILayout.Button(&quot;扩展按钮&quot;)) &#123;            Debug.Log(&quot;测试按钮&quot;);        &#125;        editor.OnInspectorGUI();    &#125;&#125;\n\n设置 Inspector 面板为只读设置 Inspector 面板为只读可以让某些设置不被任意修改, 尤其是多人合作开发项目的时候尤其有用.\n绘制 Inspector 面板时设置只读设置自定义 Inspector 面板为只读, 只需要在绘制 Inspector 面板的时候设置 GUI.enabled 为 false 即可将特定的区域设置为只读.\n[CustomEditor(typeof(Transform))]public class ExpendInspector : Editor &#123;    private Editor editor;    private void OnEnable() &#123;        editor = Editor.CreateEditor(target,            Assembly.GetAssembly(typeof(Editor)).GetType(&quot;UnityEditor.TransformInspector&quot;, true));    &#125;    public override void OnInspectorGUI() &#123;        if (GUILayout.Button(&quot;扩展按钮&quot;)) &#123;            Debug.Log(&quot;测试按钮&quot;);        &#125;        GUI.enabled = false;        editor.OnInspectorGUI();        GUI.enabled = true;    &#125;&#125;\n\n通过脚本设置只读即使不直接修改 Inspector 面板, 也可以设置其为只读, 只要设置物体的 hideFlags 属性即可.\nusing System.Reflection;using UnityEditor;using UnityEngine;public class ExpendInspector &#123;    private const string MENU_LUCK = &quot;GameObject/3D Object/Lock/Lock&quot;;    private const string MENU_UNLUCK = &quot;GameObject/3D Object/Lock/Unlock&quot;;    [MenuItem(MENU_LUCK, false, 0)]    private static void GameObjectLock() &#123;        if (Selection.objects != null) &#123;            foreach (var item in Selection.objects) &#123;                item.hideFlags = HideFlags.NotEditable;            &#125;        &#125;    &#125;    [MenuItem(MENU_UNLUCK, false, 0)]    private static void GameObjectUnlock() &#123;        if (Selection.objects != null) &#123;            foreach (Object item in Selection.objects) &#123;                item.hideFlags = HideFlags.None;            &#125;        &#125;    &#125;&#125;\n\n扩展 Inspector 面板的设置菜单Inspector 的设置菜单位于 CONTEXT 层级下, 因此路径必须以这个开头. 另外, 这个菜单在扩展时的方法必须有一个 MenuCommand 类型的参数, 里面包含了挂载当前组件的游戏物体的信息.\nusing System.Reflection;using UnityEditor;using UnityEngine;public class ExpendInspector &#123;    private const string MENU_1 = &quot;CONTEXT/Transform/PrintName&quot;;    private const string MENU_2 = &quot;CONTEXT/Camera/PrintName&quot;;    [MenuItem(MENU_1, false, 0)]    private static void Menu1(MenuCommand command) &#123;        Debug.Log(command.context.name);    &#125;    [MenuItem(MENU_2, false, 0)]    private static void Menu2(MenuCommand command) &#123;        Debug.Log(command.context.name);    &#125;&#125;\n\n扩展 Scene 视图Scene 视图是开发者搭建游戏场景的视图, 搭建场景的时候可以利用一些辅助元素来更加规范地快捷地搭建游戏场景. 扩展 Scene 视图的时候有两种, 一种是仅作为辅助元素来方便开发者搭建场景, 这一类元素是无法进行交互的, 类似于辅助线的功能, 当时辅助元素不仅仅只有线. 另一种就是绘制可交互的辅助 UI.\n不可交互的辅助元素 GizmosUnity 中有一个 Gimos 类, 这个类中的 API 就是用来给 Scene 视图绘制辅助元素的. Gizmos 类元素是在 On 类事件中绘制的, 这一类 On 事件的触发需要继承 MonoBehavior, 之后会在编辑器模式下每一帧调用. 也正是因为这个机制导致 Gizmos 绘制脚本不能放到 Editor 文件夹下.\n事件方法:\nOnDrawGizmosSelected() : 依赖特定的物体, 因此需要将脚本挂载在特定的游戏物体上, 当选中这个游戏物体时, 这个事件会被触发.\nOnDrawGizmos() : 不依赖任何游戏物体, 事件会在编辑器模式下的每一帧触发.\n绘制方法:\nGizmos.color : 设置绘制元素时画笔的颜色.\nGizmos.DrawLine, Gizmos.DrawCube, Gizmos.DrawSphere 等方法可以用来绘制线段, 长方体, 球体等.\n可交互的辅助元素 Handles GUI第一类是只在特定的物体上让脚本生效, 比如当选择摄像机的时候, Scene 面板中出现几个按钮, 用来打印摄像机的信息.\n第二类是全局修改 Scene 窗口, 即任何时候 Scene 窗口上都会显示自定义的内容.\n特定物体的 Scene 窗口自定义这一类的扩展代码编写方法和扩展 Inspector 面板时是一样的.\n需要使用特性 CustomEditor(typeof()) 来修饰类, 同时继承 Editor 来绘制 UI.\n绘制 UI 的时候, 绘制用的代码放在 OnSceneGUI() 中, 并且必须放在 Handles.BeginGUI() 和 Handles.EndGUI() 之间.\nHandles.color 可以修改绘制 UI 时的颜色.\n绘制 UI 时使用的 API 依旧是: GUI, GUILayout, EditorGUI, EditorGUILayout 等.\n全局的 Scene 窗口自定义常驻 UI 的绘制方法和依赖物体的 Scene UI 是一样的, 只是这个显示 UI 的方法的调用方式不一样了, 之前的是使用 OnSceneGUI() 方法, 而全部的 UI 是使用 [InitializeOnLoadMethod] 特性来调用自定义方法实现.\n创建自定义窗口 (EditorWindow)定义窗口继承自 EditorWindow 的类便是窗口本身.\n打开窗口使用继承自 EditorWindow 类中的 GetWindow&lt;MyEditorWindowType&gt;(); 方法便可以打开特定的窗口, 返回打开后的窗口引用.\n设置窗口的基本信息在使用 GetWindow&lt;&gt;(); 之后获得的返回值中有一个 titleContent 可以设置窗口的名称, 图标, 气泡提示.\nmyWindow.titleContent = new GUIContent(&quot;标题名称&quot;, textureICON(Texture), &quot;气泡提示内容&quot;);\n改变风格的两种方式使用全局 GUI 风格// 粗体GUI.skin.label.fontStyle = FontStyle.Bold;// 24 号GUI.skin.label.fontSize = 24;// 居中GUI.skin.label.alignment = TextAnchor.MiddleCenter;\n\n使用局部 GUI 风格Unity 规定只能在 OnEnable() 方法中新建局部 GUI 风格.\nGUIStyle guiStyleTitle = new GUIStyle&#123;    // 粗体    fontStyle = FontStyle.Bold,    // 24 号    fontSize = 24,    // 居中    alignment = TextAnchor.MiddleCenter&#125;;\n\n之后将这个新建的风格作为参数, 绘制控件的时候传入即可.\n绘制控件这里可以绘制控件的 API 有: GUI, GUILayout, EditorGUI, EditorGUILayout, 可用于绘制 Inspector 面板, EditorWindow 窗口等.\n布局类\nSpace: 空白, 空行, 空格\n EditorGUILayout.Space(10);\n\nFlexibleSpace: 自适应空格, 自动填充所处布局的全部剩余空间. 自适应空格大多和布局一起使用, 在水平布局中, 假设按照: A, FlexibleSpace, B 的顺序安排控件, 那么效果是: A 靠左, B 靠右, 中间空白会随着水平布局的变宽而变宽.\n  GUILayout.FlexibleSpace();\n\nBeginVertical, EndVertical: 垂直布局, 可以通过输入参数 &quot;box&quot; 让布局有一个灰色的背景.\n  EditorGUILayout.BeginVertical(&quot;box&quot;);`// ...EditorGUILayout.EndVertical();`\n\nBeginHorizontal, EndHorizontal: 水平布局, 可以通过输入参数 &quot;box&quot; 让布局有一个灰色的背景.\n  GUILayout.BeginHorizontal(&quot;box&quot;);`// ...GUILayout.EndHorizontal();`\n\nBeginArea, EndArea: 自动布局区域\n  GUILayout.BeginArea(new Rect(100, 300, 300, 100));// ...GUILayout.EndArea();\n\nFoldout: 折叠区域, 第一个参数为 bool 类型的参数, 表示是否折叠, 第三个参数是表示点击标题时是否可以展开, 默认是 false\n  foldoutTitle = new GUIContent(&quot;测试折叠菜单&quot;, &quot;气泡提示, 好无聊~&quot;);if (foldout = EditorGUILayout.Foldout(foldout, foldoutTitle, true))&#123;    // ...&#125;\n\nScrollView: 附带滑动条的固定显示区域. 第一个参数是滑动条的位置, 是对滑动条滑动量的一个描述, 是一个 Vector2 类型, 分别表示横向和纵向两个滑动条, 每个轴保存的是滑动条的位置, 并不是百分比, 比如滑动区域的总高度为1000, 当纵向滑动条处于中间时, Vector2 的 Y 周值便是 500, 第二, 三个参数是布局选项, 设置滑动区域的显示大小. 滑动区域的实际大小由内容决定.\n  scrollPos = EditorGUILayout.BeginScrollView(scrollPos, GUILayout.Width(100), GUILayout.Height(100));\n\n提示用标签类\nLabelField, 文字提示, 不可交互, 不可选中, 不可复制\n  EditorGUILayout.LabelField(&quot;第一个编辑器窗口&quot;, guiStyleTitle);\n\nSelectableLabel, 可选择的标签, 右键可复制\n  EditorGUILayout.SelectableLabel(&quot;可选择的标签&quot;);\n\n\n输入框类\nTextField 文本输入框, 可输入少量文本\n  accountName = EditorGUILayout.TextField(&quot;账号:&quot;, accountName);\n\nTextArea, 文字区域, 可输入大量文本\n  description = EditorGUILayout.TextArea(description, GUILayout.MaxHeight(75));\n\nPasswordField, 密码输入框, 可输入密码\n  password = EditorGUILayout.PasswordField(&quot;密码:&quot;, password);\n\nIntField, 整型数字输入框, 只允许输入整数\n  intField = EditorGUILayout.IntField(&quot;输入框名称&quot;, intField);\n\nFloatField, 浮点数输入框, 只允许输入小数\n  floatField = EditorGUILayout.FloatField(&quot;输入框名称&quot;, floatField);\n\n\n滑动条类 (Slider)\nSlider, 普通(浮点数)滑动条, 滑动时的数值为小数\n  sliderValue = EditorGUILayout.Slider(&quot;滑动条名称&quot;, sliderValue, 0.3f, 30.3f);\n\nIntSlider, 整数滑动条, 滑动时的数值为整数\n  intSliderValue = EditorGUILayout.IntSlider(&quot;整形滑动条名称&quot;, intSliderValue, 1, 25);\n\nMinMaxSlider, 范围滑动条, 滑动条上左右两侧均可滑动, 数字为小数\n  EditorGUILayout.MinMaxSlider(ref sliderMinValue, ref sliderMaxValue, sliderMinLimit, sliderMaxLimit);\n\n\n弹出菜单选择类\nPopup, 普通弹出菜单, selectedNameIndex 默认的选择项和当前的选择项, 从 0 开始计数. playerNames 则是一维的字符串数组, 作为选择菜单项的来源数据.\n  selectedNameIndex = EditorGUILayout.Popup(&quot;弹出菜单的名称: &quot;, selectedNameIndex, playerNames);\n\nIntPopup, 整型数字选择菜单, 与 Popup 的区别是索引为自定义的整型数字, 不再是固定的 从 0 开始. 因此需要两个数组, selectedAgeIndex 是默认的选择项和当前的选择项, playerAgesInfo 则是一维的字符串数组, 作为选择菜单项的来源数据, playerAges 则是自定义的索引数组, 其长度必须和前面的数据数组保持一致.\n  selectedAgeIndex = EditorGUILayout.IntPopup(&quot;整型数字弹出菜单&quot;, selectedAgeIndex, playerAgesInfo, playerAges);\n\nEnumPopup, 枚举式弹出菜单, 与 Popup 的区别是不再使用索引, 而是使用枚举作为选择的标志. 前面强制类型转换的 PlayerType 就是枚举类型. 后面的 playerType 则是默认的选择项和当前的选择项, 当然这就是 PlayerType 类型的变量.\n  playerType = (PlayerType)EditorGUILayout.EnumPopup(&quot;枚举式弹出菜单&quot;, playerType);\n\n\n资源选择框\nObjectField, 预制件选择框, 可选择资源中的预制件, go 是默认值以及当前的选择值.\n  go = EditorGUILayout.ObjectField(&quot;物体名&quot;, go, typeof(GameObject), false) as GameObject;\n\n\n交互按钮\nGUILayout.Button, 点击后返回 true\n  if (GUILayout.Button(&quot;保存数据&quot;, GUILayout.MaxWidth(80)))&#123;    Debug.Log(&quot;保存数据成功!&quot;);&#125;\n\n勾选框\nToggle, 第一个参数是显示的提示文本, 第二个选项时默认的勾选状态以及当前的勾选状态\n  if (toggleValue = EditorGUILayout.Toggle(&quot;多选控件显示的文本, 勾选后进行三维向量检测&quot;, toggleValue))&#123;    myv3value = EditorGUILayout.Vector3Field(&quot;请输入一个三维向量&quot;, myv3value);&#125;\n\n文件选择\nEditorUtility.OpenFilePanel(), 第一个参数为弹出窗口的标题, 第二个为默认路径, 第三个为文件类型条件\n  if (GUILayout.Button(&quot;Select File&quot;, GUILayout.Height(25), GUILayout.Width(120))) &#123;    filePath = EditorUtility.OpenFilePanel(&quot;Select File&quot;, filePath, &quot;&quot;);    if (!string.IsNullOrEmpty(filePath)) &#123;        // 具体的行为        filePath = null;    &#125;&#125;\n\n目录选择\nEditorUtility.OpenFolderPanel(), 第一个参数为弹出窗口的标题, 第二个为默认路径, 第三个为默认文件夹名称\n  if (GUILayout.Button(&quot;Select Folder&quot;, GUILayout.Height(25), GUILayout.Width(120))) &#123;    folderPath = EditorUtility.OpenFolderPanel(&quot;Select Folder&quot;, folderPath, &quot;&quot;);    if (!string.IsNullOrEmpty(folderPath)) &#123;        // 具体的行为        folderPath = null;    &#125;&#125;\n\n目录选择进度条进度条有两种, 第一种是附带了一个 &quot;取消&quot; 按钮的进度条, 这个是可以中途取消的, 另外一种就是没有取消按钮的进度条.\n可中途取消的进度条\n使用下方的 DisplayCancelableProgressBar 方法便可以生成一个带有取消按钮的进度条, 返回值为 bool 类型. 当点击 &quot;取消&quot; 按钮时, 返回值为 false, 否则返回值始终为 true, 即使第三个参数的数值已经超过了 1 (进度条数值溢出, 外观上不会溢出) 返回值也是 true. 需要注意的是: 取消按钮并不能删除当前显示的进度条, 这个按钮只能让 DisplayCancelableProgressBar() 方法返回 false, 需要取消进度条必须使用 EditorUtility.ClearProgressBar(); 方法.\nEditorUtility.DisplayCancelableProgressBar(&quot;进度条窗口的标题&quot;, &quot;进度条下方的描述&quot;, 浮点型的进度条百分比(0-1))\n因此大多数在循环中展示进度条, 在一个将要处理大量数据的循环中加一个进度条, 这样每次循环的时候, 外部都会有一个进度值实时告诉用户进度, 用户就不容易以为设备卡住了.\n不可中途取消的进度条\n这个就更简单了, 使用 DisplayProgressBar() 方法便可以生成不可中途取消的进度条, 方法的返回值为 void, 因此不需要过多的处理.\nEditorUtility.DisplayProgressBar(&quot;进度条窗口的标题&quot;, &quot;进度条下方的描述&quot;, 浮点型的进度条百分比(0-1))\n[注] 这两种进度条都必须使用 EditorUtility.ClearProgressBar(); 方法才能取消进度条的显示.\n自定义进度条Unity 的进度条有一个不好的地方就是必须自己去 Clear 进度条, 经常会出现忘记 Clear 导致 Unity 卡住的情况, 所以就自己写了一个可以自动 Clear 的进度条.\nusing UnityEditor;namespace KurohaUtility &#123;    public static class CommonProgressBar &#123;        public static void ProgressBar(string title, string info, float progress) &#123;            if (progress &gt;= 1) &#123;                EditorUtility.ClearProgressBar();            &#125; else &#123;                EditorUtility.DisplayProgressBar(title, info, progress);            &#125;        &#125;        public static bool ProgressBarCancel(string title, string info, float progress) &#123;            var result = false;            if (progress &gt;= 1) &#123;                EditorUtility.ClearProgressBar();            &#125; else &#123;                result = EditorUtility.DisplayCancelableProgressBar(title, info, progress);                if (result) &#123;                    EditorUtility.ClearProgressBar();                &#125;            &#125;            return result;        &#125;    &#125;&#125;\n\n附录常用 APIEditorSceneManager.SaveCurrentModifiedScenesIfUserWantsTo();如果用户当前修改了场景, 并且还没有对场景进行保存, 则会询问用户是否保存场景; 如果当前场景没有被修改, 则无事发生.\n\n路径开头总结\n\n\n路径内容\n开头\n原因\n\n\n\nAssetDatabase 访问资源路径\nAssets\nUnity 中资源的顶级目录为: Assets\n\n\nResources 动态加载资源路径\n无\nResources.Load() 方法中参数是相对路径的文件名, 所以不能加任何开头\n\n\nProject 面板菜单\nAssets\nProject 面板菜单就是标题栏中的 Assets 菜单\n\n\nHierarchy 面板菜单\nGameObject\nHierarchy 面板菜单就是标题栏中的 GameObject 菜单\n\n\nInspector 面板中单个组件的设置菜单\nCONTEXT\nInspector 面板中的组件设置菜单就是在 CONTEXT 目录下\n\n\nInspector 面板中所有组件的设置菜单\nCONTEXT&#x2F;Component\n设置特定组件就在 CONTEXT 后加特定组件, 如果要设置全部组件, 就加 Component\n\n\n如何高亮选中物体Hierarchy 面板// 搜索物体GameObject go = GameObject.Find(&quot;Main Camera&quot;);// 高亮物体, 同时将定位 Hierarchy 面板中高亮物体的位置EditorGUIUtility.PingObject(go);// 选中物体, 显示 Inspector 面板 (目前 Unity 存在 Bug, 选中后直接变成 &quot;重命名&quot; 状态)Selection.activeGameObject = go;\n\nProject 面板// 读取资源GameObject go = AssetDatabase.LoadAssetAtPath&lt;GameObject&gt;(&quot;Assets/Cube.prefab&quot;);// 高亮物体, 同时将定位 Project 面板中高亮物体的位置EditorGUIUtility.PingObject(go);// 选中物体, 显示 Inspector 面板Selection.activeObject = go;\n\nEditorWindow 中变量的初始化窗口类中的变量通常是需要在 OnGUI() 方法中使用, 根据方法的生命周期来看, 在 OnGUI() 方法中使用的变量都是可以直接在 OnEnable() 方法中进行初始化的. 同时由于这类变量通常需要保存数据到本地, 所以大多是使用文件中读取的数值进行初始化.\n另外需要注意的一个点是: 之前说过 OnEnable() 和 OnFocus() 是在 GetWindow() 方法返回之前执行的, 因此这两个方法不能用来对 GetWindow() 的返回值进行设置, 所以对窗口的外观设置任务就只能交给 AfterGetWindow 区域了, 或者直接独立出一个方法来进行窗口的外观设置.\nusing UnityEditor;using UnityEngine;public class MyWindow : EditorWindow&#123;    string windowTitle;    // static 特性: 在编辑器模式下的静态变量一旦赋值, 除非 &quot;Unity 重新编译脚本&quot; 或者 &quot;Unity 退出&quot;, 否则变量的值一直保留, 不会重置.    private static MyWindow self;    private static GUIContent windowTitleContent;    public static void Open()    &#123;        self = GetWindow&lt;MyWindow&gt;();        // 对窗口初始化的任务就只能交给 AfterGetWindow 区域了.        self.titleContent = windowTitleContent;        self.minSize = new Vector2(500f, 500f);        self.maxSize = self.minSize;    &#125;    private void OnEnable()    &#123;        // OnEnable 中不能对 self 做任何操作, 因为此时 self 还是空值.        // 虽然由于 static 的特性, 仅第 1 次设置会报错, 但是既然报错就必须要禁止!😂        // 对 OnGUI 中需要用到的变量初始化        windowTitle = &quot;This is a string inside a Scroll view!&quot;;        windowTitleContent ??= new GUIContent(&quot;测试窗口1&quot;, &quot;气泡测试1&quot;);    &#125;    private void OnGUI()    &#123;        GUILayout.Label(windowTitle);    &#125;&#125;\n\n获取场景中全部游戏物体使用普通的方法只能获取非隐藏的游戏物体, 而我们大多数时候都是需要获取全部游戏物体的.\n/// &lt;summary&gt;/// 获取 Hierarchy 中所有的游戏物体/// 包括被禁用的游戏物体/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;private List&lt;GameObject&gt; GetAllSceneObjectsWithInactive()&#123;    var allTransforms = Resources.FindObjectsOfTypeAll(typeof(Transform));    var previousSelection = Selection.objects;    Selection.objects = allTransforms.Cast&lt;Transform&gt;()        .Where(x =&gt; x != null)        .Select(x =&gt; x.gameObject)        //.Where(x =&gt; x != null &amp;&amp; !x.activeInHierarchy)        //.Where(x =&gt; x != null &amp;&amp; x.activeInHierarchy)        .Cast&lt;UnityEngine.Object&gt;().ToArray();    var selectedTransforms = Selection.GetTransforms(SelectionMode.Editable | SelectionMode.ExcludePrefab);    Selection.objects = previousSelection;    return selectedTransforms.Select(transform =&gt; transform.gameObject).ToList();&#125;\n","categories":["Unity"],"tags":["Unity","Editor"]},{"title":"EditorWindow 类中事件方法的执行顺序","url":"/unity_editor/unity_editorwindow_runorder.html","content":"\n\n参与实验的事件方法Open() // 内部调用了 GetWindow() 方法OnEnable()OnFocus()OnGUI()OnInspectorUpdate()OnLostFocus()OnDisable()OnDestroy()OnHierarchyChange()OnProjectChange()OnSelectionChange()\n\n实验代码:using UnityEditor;using UnityEngine;public class MyWindow : EditorWindow&#123;    bool bool_OnEnable = true;    bool bool_OnInspectorUpdate = true;    bool bool_OnHierarchyChange = true;    bool bool_OnProjectChange = true;    bool bool_OnGUI = true;    bool bool_OnFocus = true;    bool bool_OnSelectionChange = true;    bool bool_OnLostFocus = true;    bool bool_OnDisable = true;    bool bool_OnDestroy = true;    public static void Open()    &#123;        Debug.Log(&quot;打开窗口&quot;);        Debug.Log(&quot;BeforeOpen&quot;);        GetWindow&lt;MyWindow&gt;();        Debug.Log(&quot;AfterOpen&quot;);    &#125;    private void OnEnable()    &#123;        if (bool_OnEnable)        &#123;            bool_OnEnable = false;            Debug.Log(&quot;OnEnable&quot;);        &#125;    &#125;    private void OnInspectorUpdate()    &#123;        if (bool_OnInspectorUpdate)        &#123;            bool_OnInspectorUpdate = false;            Debug.Log(&quot;OnInspectorUpdate&quot;);        &#125;    &#125;    private void OnHierarchyChange()    &#123;        if (bool_OnHierarchyChange)        &#123;            bool_OnHierarchyChange = false;            Debug.Log(&quot;OnHierarchyChange&quot;);        &#125;    &#125;    private void OnProjectChange()    &#123;        if (bool_OnProjectChange)        &#123;            bool_OnProjectChange = false;            Debug.Log(&quot;OnProjectChange&quot;);        &#125;    &#125;    private void OnGUI()    &#123;        if (bool_OnGUI)        &#123;            bool_OnGUI = false;            Debug.Log(&quot;OnGUI&quot;);        &#125;    &#125;    private void OnFocus()    &#123;        if (bool_OnFocus)        &#123;            bool_OnFocus = false;            Debug.Log(&quot;OnFocus&quot;);        &#125;    &#125;    private void OnSelectionChange()    &#123;        if (bool_OnSelectionChange)        &#123;            bool_OnSelectionChange = false;            Debug.Log(&quot;OnSelectionChange&quot;);        &#125;    &#125;    private void OnLostFocus()    &#123;        if (bool_OnLostFocus)        &#123;            bool_OnLostFocus = false;            Debug.Log(&quot;---------------------------------------------------------------------------------------------------------------------&quot;);            Debug.Log(&quot;关闭窗口&quot;);            Debug.Log(&quot;OnLostFocus&quot;);        &#125;    &#125;    private void OnDisable()    &#123;        if (bool_OnDisable)        &#123;            bool_OnDisable = false;            Debug.Log(&quot;OnDisable&quot;);        &#125;    &#125;    private void OnDestroy()    &#123;        if (bool_OnDestroy)        &#123;            bool_OnDestroy = false;            Debug.Log(&quot;OnDestroy&quot;);        &#125;    &#125;&#125;\n\n实验输出\n实验结论下图中有一个点需要特别注意, OnEnable() 和 OnFocus() 是在 GetWindow() 方法返回之前执行的. 因此 OnEnable() 和 OnFocus() 中不能对 GetWindow() 的返回值做任何操作, 因为此时的返回值还是空值.\n\n另外的三个 Change() 类事件方法:\n\nOnHierarchyChange()\n  每当场景的层次结构发生变化时调用.\n\nOnProjectChange()\n  每当项目发生更改时调用.\n\nOnSelectionChange()\n  每当选择发生更改时调用.\n\n\n","categories":["Unity"],"tags":["Unity","EditorWindow"]},{"title":"在 Unity 中实现 Android 分享文本、图片、文件功能","url":"/unity/unity_android_share.html","content":"\n\n🥦前言本人对于安卓开发是完完全全的新手, 什么 file:// 什么 content:// 都是第一次听说, 因为本文也是针对完全新手的小白\n🎈使用 Asset Store 插件实现分享功能既然是实现自己从未接触过领域的功能, 首先想到的就是尝试使用插件, 但是 ...\n商店中并没有免费且好用的分享插件, 基本都是收费的, 而且还很贵, 都在 25 美元以上! 于是只好自己想办法编写功能\n\nNative Screen Share : $25\nNative Share Screenshot (iOS and Android) : $20\nNative Screen Share - Try It : Free, 好像不兼容 Android 7.0, 而且已经是 2019 年的了\nNative Web Screen Capture, Save, and Share : $45\n\n但是有一个很不错的导入导出功能的插件, 注意, 导入导出功能和分享功能可不是不一回事哦！\n\nNative File Picker for Android &amp; iOS\nRuntime File Browser\n\n🥝使用原生安卓包Unity 支持直接引用 AAR 文件 (Android Archive)\n可以看下官方对于 Unity 如何进行 Android 开发的说明\n官方手册\n当然这份说明大而全, 我们这里只需要看 Unity 如何引用 Android 原生代码的部分即可\n如何引用原生代码\n从这个页面中 Android plug-in types 可以看出, Unity 支持很多种引用原生代码的方式\n\n引用 Android Library Projects\n引用 Android Archive plug-ins 也就是 AAR 包\n引用 JAR plug-ins 也就是 jar 包\n引用 Native plug-ins for Android 我未涉足过此领域, 猜测应该是用 C++ 写的包\n引用 Java and Kotlin source plug-ins 也就是直接的 java 代码文件和 kotlin 代码文件\n\n我这次使用的就是 AAR 包的方式, 使用 Java 编写代码, 打包为 AAR 供 Unity 调用即可\n🍀关于安卓分享的说明在 Android 7.0 之前, 应用可以使用 file://URI 的方式将自己的文件共享给其他应用访问。\n然而从 Android 7.0 开始, 为了进一步提高私有目录的安全性, Google 不再允许通过 file://URI 的形式直接共享文件给其他应用, 否则会触发 FileUriExposedException 异常, 导致应用崩溃\n那么, 如果我现在想要实现文件分享功能, 该怎么办？在 Android 7.0 及以上, 是否还有办法安全地进行文件共享？\n🌴FileProvider在 Android 7.0 进行更加严格地权限管理的同时, Google 提供了 FileProvider 机制, 这个机制允许应用通过 content:// 方式安全地共享文件, 并通过 grantUriPermissions 机制控制文件访问权限\n有了上面的理论基础, 下面开始分步骤讲解操作\n🍓创建一个 Android 项目打开 Android Studio, 点击 New Project, 此时需要选择一个项目模板, 直接选择 No Activity\n之后需要填写工程信息\nName: Unity-Plugin-Android工程名字我写的是 Unity-Plugin-Android, 表示这是我给 Unity 用的 Android 插件, 之所以这样命名是因为我所有的项目都是这样命名的\nPackage name: com.kuroha.unity_plugin_android这里的包名不需要和 Unity 中打包时的包名一致, 可以按照自己的规则编写即可\n比如我的 Unity 项目包名是 com.kuroha.swordrequiem\n这里我填写的则是 com.kuroha.unity_plugin_android\nSave location: F:\\Unity-Plugin-Android填写工程文件的存放目录, 因为我整个 F 盘都是用来放置工程的, 于是我直接放在了 F:\\Unity-Plugin-Android 中\nLanguage: Java编程语言, 我从来没有学习过 Kotlin, 所以选择了 Java\nMinimum SDK: API 24重点来了, 这里需要设置最小的 API 版本, 这个数字必须和 Unity 中的 Minimum API Level 保持一致! 否则会打包失败!\n我当时的情况是, Unity 设置了 23, 插件设置了 24, 打包时报错了, 因为不清楚是否只是这里的数字比 Unity 的小即可还是必须保持一致, 强烈建议保持一致! 更省心!\n另外因为后面要用的 FileProvider 是 Android 7.0 推出的, 因为建议这里选择 24, Unity 中的 Minimum API Level 也设置为 24\nBuild configuration language: Kotlin DSL这个选项我了解的并不深, 于是选择了推荐的选项, 即 Kotlin DSL, 后面的 [Recommended] 就是推荐的意思\n🌱调整项目目录的显示模式前面新建完成 Android 工程后, Android Studio 中可以看到一个空的 Android 项目\n左侧文件目录的默认显示模式是 : Android, 这个显示的其实是项目的逻辑结构, 并不是实际的文件结构, 因此对于新手而言, 还是切换到 Project 模式更好一些.\n切换到 Project 模式后, 仅有 Android, External Libraries, Scratches and Consoles 三项.\n🌳下载 SDK, NDK据 Android Studio 官方说明, 会在首次构建时自动下载安装\n\n自动安装 NDK 和 CMakeAndroid Gradle 插件 4.2.0 及更高版本可在您首次构建项目时自动安装所需的 NDK 和 CMake，前提是您已预先接受其二者的许可。安装 NDK 和 CMake当您安装 NDK 时，Android Studio 会选择可用的最新 NDK 版本。对于大多数项目，安装此默认版本的 NDK 已经足够。\n\n所以我们来执行一次构建, 打开主菜单中的 Build 菜单, 第一个选项就是 Make Project, 点击这个选项会直接开始构建, 触发下载 SDK\n需要等待一段时间, 还挺长的, 我等了接近一个小时吧.\n不仅仅是构建需要下载 SDK, 接下来我们要需要的使用 File/New/New Module... 选项, 同样需要 SDK, 所以乖乖等资源下载完吧, 不然 File/New/New Module... 选项直接是灰色的, 根本点不了...\n🍨新建 Module资源下载完成后, 就可以点击 File/New/New Module... 选项了.\n点击后首先需要选择 Module 的模板, 这里我们选择安卓原生库, 即 Android Native Library, 之后填写 Module 的具体信息\nModule name: Android-Library设置一下模块名称, 我填写了 Android-Library\nPackage name: com.kuroha.android_library使用了自动生成的 com.kuroha.android_library\nLanguage: Java选择 Java 作为编程语言\nC++ Standard: Toolchain Default我选择了让工具链自动使用默认值\nMinimum SDK: 24必须和 Unity 中的 Minimum API Level 保持一致! 否则会打包失败!\n建议这里选择 24, Unity 中的 Minimum API Level 也设置为 24\nBuild configuration language: Kotlin DSL同样使用推荐设置\n🍉配置 FileProvider模块建好后, 在工程目录下可以直接找到模块的文件夹, 比如我的就是 Android-Library 文件夹, 如果你找不到说明你的目录显示模式不对, 默认是 Android 模式, 改为 Project 模式就可以看到了\nAndroidManifest那么先来配置一下 FileProvider, 将模块目录中的 /src/main/AndroidManifest.xml 文件改为以下内容\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;    &lt;application&gt;        &lt;provider            android:name=&quot;androidx.core.content.FileProvider&quot;            android:authorities=&quot;$&#123;applicationId&#125;.file_provider&quot;            android:exported=&quot;false&quot;            android:grantUriPermissions=&quot;true&quot;&gt;            &lt;meta-data                android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot;                android:resource=&quot;@xml/file_path&quot; /&gt;        &lt;/provider&gt;    &lt;/application&gt;&lt;/manifest&gt;\n\n此时最后一行的 @xml/file_path 会是红色的, 因为我们还没有新建对应的 file_path 文件\nfile_path在模块目录中新建以下文件 /src/main/res/xml/file_path.xml, 如果中间某个层级没有, 直接新建对应名称的层级即可\n这里的文件名其实就是前面 /src/main/AndroidManifest.xml 文件中最后写的那句 android:resource=&quot;@xml/file_path&quot;\nfile_path 文件新建成功后, 粘贴以下内容\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;paths&gt;    &lt;files-path name=&quot;files&quot; path=&quot;.&quot; /&gt;    &lt;cache-path name=&quot;cache&quot; path=&quot;.&quot; /&gt;    &lt;external-path name=&quot;external&quot; path=&quot;.&quot; /&gt;    &lt;external-files-path name=&quot;external_file_path&quot; path=&quot;.&quot; /&gt;    &lt;external-cache-path name=&quot;external_cache_path&quot; path=&quot;.&quot; /&gt;&lt;/paths&gt;\n\n到此 FileProvider 就配置完成了, 是不是很简单, 此时再回去看 AndroidManifest 文件就会发现最后那里不会再变红了. 接下来就需要开始写代码了\n🍇使用 Java 编写分享逻辑以我项目中的模块为例, 我模块中已经新建好了一个 \\src\\main\\java\\com\\kuroha\\android_library\\NativeLib.java 文件\n找到这个 Java 文件, 修改其中的内容为:\npackage com.kuroha.android_library;import android.content.Context;import android.content.Intent;import android.net.Uri;import androidx.core.content.FileProvider;import java.io.File;public class ShareUtil &#123;    public static void ShareFile(Context context, String filePath, String title) &#123;        File file = new File(filePath);        if (file.exists()) &#123;            String authority = context.getPackageName() + &quot;.file_provider&quot;;            Uri uri = FileProvider.getUriForFile(context, authority, file);            Intent intent = new Intent(Intent.ACTION_SEND);            intent.setType(&quot;*/*&quot;);            intent.putExtra(Intent.EXTRA_STREAM, uri);            intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);            Intent chooser = Intent.createChooser(intent, title);            context.startActivity(chooser);        &#125;    &#125;&#125;\n\n因为 Java 中要求类名必须和文件名一致, 所以要么你修改类名为它默认提供的 NativeLib, 要么将文件重命名为 ShareUtil, 重命名这种操作总归不用再教了吧...\n至此就已经完成了, 直接构建, 在模块目录中就可以看到打包的 AAR 包了, 我的是: /build/outputs/aar/Android-Library-debug.aar\n为什么带一个 debug 呢, 是因为我们的项目是 debug 项目, 你改为 release 项目, 那么后面就是跟着一个 release 了, 不过 release 项目需要提供签名, 比较麻烦不是吗, 所以看你自己的选择啦 ~ 设置为 debug 和 release 都可以, 反正这个包不是直接暴露给玩家的, 只是我们自己内部使用罢了\n🍒Unity 引用 AAR 包据 Unity 官方的使用说明, 只要将打包的 AAR 包放到 Unity 项目内的 Assets 目录内的任意目录即可, 不再要求不许放在 Plugins 文件夹内, 因此我放在了自己的游戏框架目录内, 这样可以重复使用嘛\n这里是官方说明: Import an Android Archive plug-in\n我也直接把链接内的内容贴在下面:\n\nImport an Android Archive plug-inThis page describes how to import an Android Archive (AAR) plug-in into your Unity Project.\n\nCopy the AAR file to your Unity Project’s Assets folder.\nSelect the AAR in Unity and view it in the Inspector.\nIn the Select platforms for plugin section, select Android.\nSelect Apply.\n\n\n在 Unity 中新建一个脚本 FileUtilAndroid.cs\n复制粘贴以下内容, 其中命名空间之类的按照自己项目的要求改一下\nusing UnityEngine;namespace Kuroha.Utility&#123;    public static class FileUtilAndroid    &#123;        private static bool isProcessing;        private static AndroidJavaClass intentClass;        private static AndroidJavaObject intentObject;        private static AndroidJavaClass unityClass;        private static AndroidJavaClass shareUtilClass;        /// &lt;summary&gt;        /// 分享一段文本        /// &lt;/summary&gt;        /// &lt;param name=&quot;shareTitle&quot;&gt;分享页面的标题&lt;/param&gt;        /// &lt;param name=&quot;shareMessage&quot;&gt;要分享的文本&lt;/param&gt;        /// &lt;param name=&quot;shareSubject&quot;&gt;要分享的主题&lt;/param&gt;        /// &lt;returns&gt;成功标志&lt;/returns&gt;        public static void ShareText(string shareTitle, string shareMessage, string shareSubject)        &#123;            if (isProcessing)            &#123;                return;            &#125;            isProcessing = true;            unityClass ??= new AndroidJavaClass(&quot;com.unity3d.player.UnityPlayer&quot;);            intentClass ??= new AndroidJavaClass(&quot;android.content.Intent&quot;);            intentObject ??= new AndroidJavaObject(&quot;android.content.Intent&quot;);            intentObject.Call&lt;AndroidJavaObject&gt;(&quot;setAction&quot;, intentClass.GetStatic&lt;string&gt;(&quot;ACTION_SEND&quot;));            intentObject.Call&lt;AndroidJavaObject&gt;(&quot;setType&quot;, &quot;text/plain&quot;);            intentObject.Call&lt;AndroidJavaObject&gt;(&quot;putExtra&quot;, intentClass.GetStatic&lt;string&gt;(&quot;EXTRA_SUBJECT&quot;), shareSubject);            intentObject.Call&lt;AndroidJavaObject&gt;(&quot;putExtra&quot;, intentClass.GetStatic&lt;string&gt;(&quot;EXTRA_TEXT&quot;), shareMessage);            var currentActivity = unityClass.GetStatic&lt;AndroidJavaObject&gt;(&quot;currentActivity&quot;);            var chooser = intentClass.CallStatic&lt;AndroidJavaObject&gt;(&quot;createChooser&quot;, intentObject, shareTitle);            currentActivity.Call(&quot;startActivity&quot;, chooser);            isProcessing = false;        &#125;        /// &lt;summary&gt;        /// 分享一个文件        /// &lt;/summary&gt;        /// &lt;param name=&quot;shareTitle&quot;&gt;分享页面的标题&lt;/param&gt;        /// &lt;param name=&quot;filePath&quot;&gt;要分享的文件&lt;/param&gt;        /// &lt;returns&gt;成功标志&lt;/returns&gt;        public static void ShareFile(string shareTitle, string filePath)        &#123;            if (isProcessing)            &#123;                return;            &#125;            isProcessing = true;            unityClass ??= new AndroidJavaClass(&quot;com.unity3d.player.UnityPlayer&quot;);            shareUtilClass ??= new AndroidJavaClass(&quot;com.kuroha.android_library.ShareUtil&quot;);            var currentActivity = unityClass.GetStatic&lt;AndroidJavaObject&gt;(&quot;currentActivity&quot;);            shareUtilClass.CallStatic(&quot;ShareFile&quot;, currentActivity, filePath, shareTitle);            isProcessing = false;        &#125;    &#125;&#125;\n\n这里面就包含了如何分享文本和文件的代码, 分享图片也属于分享文件\n那么如何使用这两个 API 呢 ? 下面分别下一个调用的例子\nprivate void ShareText()&#123;    FileUtilAndroid.ShareText(&quot;测试分享文本&quot;, &quot;成功了!&quot;, &quot;分享主题&quot;);&#125;private async void ShareFile()&#123;    var path = $&quot;&#123;UnityEngine.Application.persistentDataPath&#125;/123.txt&quot;;    File.WriteAllText(path, &quot;Hello World!&quot;);    FileUtilAndroid.ShareFile(&quot;测试分享文件&quot;, path);&#125;\n\n至此, 教程结束!\n🍈附录Android Studio 简体中文汉化包简体中文汉化包\n","categories":["Unity"],"tags":["Unity"]},{"title":"闭包","url":"/unity/unity_closure.html","content":"\n\n闭包之前在学习委托事件的时候了解了一下闭包, 没想到后来在游戏制作中就犯了一个闭包的错误.\n使用的是 Unity 引擎, 先看一个 Start 方法:\nprivate void Start()&#123;    GameObject gameObject;    characterPackage = characterDataScript.characterData.Package;    for (int index = 0; index &lt; characterPackage.Count; index++)    &#123;        // 生成菜单项, 并设置父物体        gameObject = Instantiate(itemMenuItemPrefab, itemMenuItemParent.transform);        // 修改菜单项的名称        gameObject.name = index.ToString();        // 修改菜单项的图标        gameObject.transform.Find(&quot;Icon&quot;).Find(&quot;Image&quot;).GetComponent&lt;Image&gt;().sprite = characterPackage[index].Icon;        // 修改菜单项的文本        gameObject.transform.Find(&quot;Name&quot;).Find(&quot;Text&quot;).GetComponent&lt;Text&gt;().text = characterPackage[index].Name;        // 给菜单项的按钮注册事件, [UnityAction: 一个无参的委托, 返回值无所谓]        gameObject.GetComponent&lt;Button&gt;().onClick.AddListener(() =&gt; Event_ItemSelected(gameObject));    &#125;&#125;\n\n执行步骤:\n\n新建一个菜单项, 用 gameObject 保存.\n修改菜单项各项属性. 其中名称属性就是遍历索引 index 的值, 即第一个菜单项的名称是 0, 第二个是 1, 第十个是 9 等等;\n给菜单项上的按钮注册事件, 事件的参数为 gameObject, 即将菜单项自身作为参数传递到方法中.\n\n那么问题来了, 假设有 4 个菜单项, 那么在事件 Event_ItemSelected 中输出按钮的名称的话, 依次点击菜单项会输出什么呢?\n不是很了解闭包的人应该会说出这个答案: 0, 1, 2, 3, 而正确的答案是: 3, 3, 3, 3!\n什么是闭包?在上面的代码段中, gameObject 变量是在 Start 方法中定义的, 那么按理来说只要出了 Start 方法, gameObject 变量就不存在了. 但是我们在按钮的 Event_ItemSelected 事件中却又访问了变量 gameObject, 这种现象就是闭包.\n当一个变量脱离了其自身的作用域后, 根据上下文关系继续在某些方法或者类中发挥作用的现象就是闭包. 或者说闭包可以让变量脱离其作用域继续发挥作用.\n答案解析在上面的代码中, 每次循环都会创建一个菜单项, 并将 gameObject 变量作为参数绑定事件, 所以最后的结果就是 菜单项 0, 菜单项 1, 菜单项 2, 菜单项 3 都使用了 gameObject 变量作为参数, 而 gameObject 是一个变量啊, 不是一个常量, 创建菜单项 0 的时候, gameObject 确实是菜单项 0, 但是等到了创建菜单项 3 的时候, gameObject 也就变成菜单项 3 了, 因此调用事件的瞬间, 使用的也是那个瞬间的 gameObject 值, 也就是 3.\n纠正private void Start()&#123;    characterPackage = characterDataScript.characterData.Package;    for (int index = 0; index &lt; characterPackage.Count; index++)    &#123;        // 生成菜单项, 并设置父物体        GameObject gameObject = Instantiate(itemMenuItemPrefab, itemMenuItemParent.transform);        // 修改菜单项的名称        gameObject.name = index.ToString();        // 修改菜单项的图标        gameObject.transform.Find(&quot;Icon&quot;).Find(&quot;Image&quot;).GetComponent&lt;Image&gt;().sprite = characterPackage[index].Icon;        // 修改菜单项的文本        gameObject.transform.Find(&quot;Name&quot;).Find(&quot;Text&quot;).GetComponent&lt;Text&gt;().text = characterPackage[index].Name;        // 给菜单项的按钮注册事件, [UnityAction: 一个无参的委托, 返回值无所谓]        gameObject.GetComponent&lt;Button&gt;().onClick.AddListener(() =&gt; Event_ItemSelected(gameObject));    &#125;&#125;\n\n使用这段代码就可以纠正那个错误, 两段代码只有一个区别, 就是 gameObject 变量定义的位置不同. 一个在 for 循环外, 一个在 for 循环内.\n\n在 for 循环外部定义时, 每一个菜单项使用的都是同一个 gameObject;\n\n在 for 循环内部定义时, 每一次循环都会重新定义一个 gameObject, 每一个菜单项之间使用的都是不同的 gameObject;\n\n\n\n","categories":["Unity"],"tags":["Unity"]},{"title":"Unity 中自定义程序集的使用以及程序集的划分","url":"/unity/unity_asmdef.html","content":"\n\n官方说明先引用一下官方自己对自定义程序集的解释, 官方手册中的说明已经非常详细了, 下面是手册链接\nAssembly\n手册上已经有的我就不重复赘述了, 说明一下我在使用过程中的一些经验\n程序集的划分程序集划分为: 预定义程序集 和 预编译程序集 和 自定义程序集\n预定义程序集 (Predefined assembly)预定义程序集指的是 Unity 引擎自己预先定义好的一些程序集, 比如项目代码会生成的 Assembly-CSharp 和 Assembly-CSharp-Editor, 还有引擎程序集, 比如 UnityEngine, UnityEditor 等\n预编译程序集 (Precompiled assembly)手册原文解释\n\nA precompiled assembly is a library compiled outside your Unity Project.\n\n很字面意思, 即在 Unity 项目外预先编译好的程序集, 例如 DoTween.dll\n自定义程序集 (Project assembly)只有使用 自定义程序集文件 所定义的程序集才是自定义程序集, 在官方手册中被称为 Project assembly\n为什么要使用自定义程序集🐔原因一 : 可以非常有效且明确地划分代码之间的依赖关系不使用自定义程序集划分, 代码会被编译到 Assembly-CSharp.dll 中, 所有的代码都在一个程序集中 (不考虑编辑器代码, 不要鸡蛋里挑骨头), 那么所有的代码之间都可以相互引用, 并且没有任何限制, 在如今 IDE 都可以自动补全命名空间的情况下, 使用命名空间来区分完全不现实, 命名空间目前基本就一个作用了, 让类的命名不再那么小心翼翼, 可以使用重名类, 不在一个空间下就行了\n使用自定义程序集来手动划分代码所属程序集, 解开 游戏框架 - 逻辑模块 - 插件 - 开发库 之间的耦合; 同时因为程序集之间如果不明确引用的话, 在代码中是无法使用的, 可以有效防止新手程序员乱写, 这种规范性问题如果仅仅靠程序员的能力来自觉维护是不可能的\n🦄原因二 : 方便实现逻辑的热更新可以手动划分出热更程序集, 用于热更新\n👽原因三 : 开发时加快代码编译速度这个是手册中就提到的事情, 通过有效划分程序集, 可以实现当修改了上层程序集的代码时, 编译时只会重新编译代码所属的程序集, 节省编译时间, 当然这一点的实现需要合理的程序集划分, 因为当程序集重新编译时, 引用了此程序集的程序集也需要重新编译\n以下面的图为例, 当仅仅修改了 main.dll 中的代码时, 那么只有 main.dll 会进行重新编译\n但是如果修改了 Library.dll 中的代码, 那么 Main.dll, Stuff.dll, Library.dll 三个程序集都需要重新编译, 因此合理的程序集划分非常重要\n\n如何划分程序集程序集的划分要参考上面所说的 3 个目的去划分, 都需要结合实际项目说明, 这里举例子的话就只说明一些最基本的划分底限, 也就是绝对需要遵守的规则\n\n不使用 Assembly-CSharp 程序集\n\n这里的意思并不是说要删除掉这个程序集, 而是需要控制项目中的代码全部使用自定义程序集来划分, 任何项目代码都不许被编译到主程序集中.\n这里的项目代码指的也只是项目开发中自己所编写的代码, 像很多插件库, 他们一般有自己的程序集划分, 但是也可能没有啊, 这部分代码并不是我们自己开发的, 我们可以自己去给他划分程序集, 也可以不划分, 可以大致参考手册图片中的划分方式划分即可. (当然这个图也就仅供参考了)\n\n库, 框架, 工具集, 逻辑模块都需要单独设立程序集\n\n开发时使用的开发库需要有自己的程序集, 包括框架, 工具集, 各个逻辑模块都需要有自己的程序集, 具体的划分就需要按照项目自己制定了\n程序集文件的选项解释对 Unity 中程序集文件各个选项的进一步解释, 补充手册的不足, 下文中的 此程序集 都是指这个选项所归属的程序集\nAllow &#39;unsafe&#39; Code字面意思, 允许使用 &#39;unsafe&#39;, 不解释, 用到就勾, 用不到就不勾.\nAllow &#39;unsafe&#39; Code : 按需设置, 基本用不到\nAuto Referenced这个是手册里面的解释\n\nSpecify whether the predefined assemblies should reference this Project assembly.\n\n新手可能看起来有点晕, 我直接说明效果, 勾选选项后, 在 Assembly-CSharp.dll 中的代码才能引用此程序集中的代码, 不勾选的话是无法引用此程序集代码的\n这对于一些老项目而言非常有用, 因为老项目的代码基本都是在 Assembly-CSharp.dll 中, 这时候独立出来的一些自定义程序集就必须都勾选此选项, 让主程序集能够引用自己.\n而新项目如果根据上面的程序集划分准则划分程序集的话, 则不要勾选此选项, 而是在需要引用此程序集的地方手动设置引用\nAuto Referenced : 旧项目推荐勾选, 方便省事\nAuto Referenced : 新项目一律不勾选\nNo Engine References字面意思, 如果程序集中的代码完全不需要使用 UnityEditor 和 UnityEngine 等引擎相关代码, 那就可以勾选\nNo Engine References : 按需设置\nRoot Namespace设置根命名空间的, 这个选项极其具有误导性, 上面的选项都是优化程序集设置的, 设置后或多或少都会对程序集造成影响, 但是这个选项不会, 是的, 你没有看错, 这个选项不会对程序集造成任何影响! 这个选项不会对程序集造成任何影响! 这个选项不会对程序集造成任何影响!\n这个选项的作用只是为了方便程序编写代码, 设置此选项后, 在此目录下新建代码文件, Unity 引擎会自动在代码中生成命名空间的代码, 仅此而已.\n另外说明一下, 这个只是一个代码自动生成的辅助功能, 不要以为这里设置了命名空间, 代码中就不需要写了, 不是的, 代码中自动生成的那行 namespace 可不能删除哦.\n最后再说一下, 只有通过 Unity 创建代码文件的时候才会生效, 在 IDE 中此设置并没有效果!\nRoot Namespace : 无所谓, 看你心情\nAssembly Definition References这个列表即设置此程序集需要引用的其他程序集, 包括预定义程序集和其他自定义程序集, 而预编译程序集的引用不在这里设置, 而是下面的 Override References 中设置\nAssembly Definition Referencess : 按需设置\nOverride References这个是对预编译程序集 (Precompiled assembly) 引用的设置, 不勾选的话, 此程序集会引用全部的预编译程序集, 勾选后则需要手动设置\nOverride References : 旧项目推荐不勾选, 方便省事\nOverride References : 新项目一律勾选\nPlatforms字面意思, 程序集的平台兼容性设置, 可以设置程序集仅在哪些平台上编译\nPlatforms : 按需设置\nDefine Constraints这个也很好理解, 宏控制, 代码编写中也经常使用类似的功能, 很有用.\n比如你写了一个库, 这个库可能只有在满足了某种条件下才能使用, 此时就可以使用宏来控制此程序集是否编译, 如果项目中没有此宏, 程序集是不会编译的, 可以放心大胆的放到项目中\nDefine Constraints : 按需设置\n循环引用设置程序集引用关系的时候, 一定要避循环引用, 即 A 引用 B, B 引用 A\n前面说过, 程序集重新编译时, 引用此程序集的程序集也会被触发重新编译, 那么 A 重新编译时, 触发了 B 重新编译, 然后 B 的重新编译又触发了 A 重新编译... 编译器: ? ? ? 你 TM 在搞我 ? ? ?\n不过设置了循环引用后, 引擎也会报错的, 所以注意一下就好\n设置举例\n\n","categories":["Unity"],"tags":["Unity"]},{"title":"Unity 的特殊食用方法","url":"/unity/unity_cracker.html","content":"\n\n我必须立刻开始使用 Unity 2019.4.37f1 !!!\n🍆 传送门Unity 的特殊使用方法就是这个网站提供的, 直接点击一下传送门就可以传送过去, 这里是传送门 🛸 Appnee\n如果你觉得网站上那各个版本密密麻麻的使用说明看得很头疼, 或者你想站在我的肩膀上不踩坑, 那就继续往下看吧.\n🍄 愉快食用 Unity 2019.4.37f1🌴 料理前准备 [非必选]下面的步骤全部是为新食客准备的, 如果你是一位经验丰富的老美食家, 完全可以自己选择准备哪些东西.\n\n删除以下 Unity 缓存文件\n  C:\\Users\\(用户名)\\AppData\\Local\\Unity\\\n  C:\\Users\\(用户名)\\AppData\\LocalLow\\Unity\\\n  C:\\Users\\(用户名)\\AppData\\Roaming\\Unity\\\n\n删除以下 Unity Hub 缓存文件\n  C:\\Users\\(用户名)\\AppData\\Roaming\\UnityHub\\\n\n删除所有与 Unity 相关的注册表项\n  HKEY_CURRENT_USER\\Software\\Unity\\UnityEditor\\\n  HKEY_CURRENT_USER\\Software\\Unity\\\n\n\n🍖 食材采集先来采集一下食材\n主食系列: Unity 2019.4.37f1 自己选择需要的主食采集即可\n辅料: Unity Hub 3.0.1\n采集完之后直接放到锅里, 但是先不要食用, 后面还有其他的料理步骤\n🍳 料理主食先领一下料理包, 拿到 料理包 之后开始料理\n\n准备\n\n备份 2019.4.37f1\\Editor\\Unity.exe 文件\n\n\n处理\n\n删除整个 2019.4.37f1\\Editor\\Data\\Resources\\Licensing 文件夹\n\n\n料理\n\n使用料理包中的 Unity.exe 替换 2019.4.37f1\\Editor\\Unity.exe\n\n将 Unity_lic.ulf 复制到 C:\\ProgramData\\Unity\\ 中. [可能需要手动创建 Unity 文件夹]\n\n\n\n\n到这里主食就料理完成了, 可以直接食用, 但是为了更好地食用, 我们来处理一下辅料.\n🥦 料理辅料辅料的料理包和主食的料理包放在一起, 可以直接找到.\n\n处理\n\n将 Unity Hub\\Frameworks\\LicensingClient\\Unity.Licensing.Client.exe 重命名为 Unity.Licensing.Client.exe.back\n\n[注] 辅料从 3.0.0 开始, 在料理前需要先重命名 Unity.Licensing.Client.exe 文件, 同时由于删除 LicensingClient 文件夹或 Frameworks 文件夹会导致另一个补丁软件的 patch 按钮不显示, 因此这里最好的做法是重命名文件, 而不是直接删除目录, 虽然我们要达到的效果都是让此程序无法运行\n\n\n\n\n料理\n\n将料理包中的 app.asar 文件复制到 Unity Hub\\resources\\ 目录下并覆盖\n\n\n\n到这里辅料也就料理完成了, 可以直接食用.\n🌿 食用前的注意事项🍴 如何匿名食用如果食用前被保安拦住了, 需要提供一下身份该怎么办呢?\n\n先退出去. 总不能在人家明目张胆地造假吧 ? !\n\n找到 C:\\Users\\[用户名]\\AppData\\Roaming\\UnityHub\\firstTimeOpenKey.json, 将里面的内容改为 false 之后, 就可以匿名食用了\n\n\n","categories":["Unity"],"tags":["Unity"]},{"title":"Unity 中的坐标系","url":"/unity/unity_coordinate_system.html","content":"\n\n前言在制作魔剑镇魂曲的 TileMap 时用到了各种坐标系之间的转换, 当时被整得云里雾里的, 现在来回顾一下. 游戏中我只用到了笛卡尔坐标系, 没有用到极坐标系, 后面就直接简称为坐标系了.\n坐标系与坐标\n首先需要强调一下坐标系和坐标完全不是一回事, 文章中有很多地方涉及到坐标系和坐标, 为了避免混淆, 一定要在脑海中清晰地区分两者. 坐标系是一个系统, 而坐标只是一个表示位置的数字.\n\n坐标是不可能独立存在的, 它必须依存于某个坐标系, 因此很多时候我们就直接简称为某某坐标. 比如在屏幕坐标系中一个点的坐标简称为 &quot;屏幕坐标&quot;, 在世界坐标系中一个点的坐标简称为 &quot;世界坐标&quot;.\n\n\n分类Unity 中的坐标大致分为 4 种:\n\n\n\n坐标\n关键字\n\n\n\n世界坐标\nWorld Point\n\n\n本地坐标\nLocal Point\n\n\n屏幕坐标\nScreen Point\n\n\n视图坐标\nView Point\n\n\n世界坐标 (World Point)\nUnity 中有一个覆盖全部游戏物体的坐标系, 所有的游戏物体都靠这个坐标系来确定自身在游戏世界中的准确位置, 这个坐标系就是世界坐标系. 有时为了明显和 &quot;局部坐标系&quot; 相对应也被称为 &quot;全局坐标系&quot;. 在世界坐标系中得出的点的坐标称为世界坐标 (World Point).\n\n但是遗憾的是在游戏物体 Inspector 面板中, Transform 处显示的 Position 是在父物体坐标系中的坐标, 而不是在世界坐标系中的坐标. 只有当物体没有父物体的时候, Transform 处显示的 Position 才是在世界坐标系中的坐标.\n\n但是在脚本中, 使用 transform.position 获取的却是游戏物体的世界坐标.\n\n\n本地坐标 (Local Point)\nUnity 中每个游戏物体都有其自身坐标系, 其子物体便是使用这个坐标系来确定与父物体的相对位置关系. 在父物体坐标系下得出的点的坐标称为本地坐标 (Local Point).\n\n由于本地坐标系和物体绑定, 因此当游戏物体进行旋转, 移动的时候, 坐标系也会进行相应的旋转和移动. 但是本地坐标却有一个特点: 不变性. 当游戏物体进行旋转, 移动的时候, 其子物体的本地坐标是不变的, 即子物体相对于自身的相对位置不会改变, 因此子物体会跟随其父物体旋转, 移动.\n\nUnity 中模型 Mesh 保存的顶点坐标均为本地坐标, 因为本地坐标的不变性, 即使物体进行旋转或者移动, 也不会影响顶点的坐标.\n\n在脚本中使用 transform.position 获取的是游戏物体的世界坐标, 使用 transform.localPosition 获取的便是游戏物体的本地坐标. 但是当物体没有父物体的时候,  transform.localPosition 获取的也是世界坐标.\n\n\n屏幕坐标 (Screen Point)\n屏幕坐标系是基于游戏窗口建立的坐标系.\n\n屏幕坐标系以像素为单位, 窗口的左下角坐标为 (0, 0), 右上角坐标为窗口大小. 脚本中可以通过 (Screen.width, Screen.height) 来获取窗口大小.\n\n脚本中使用 Input.mousePosition 可以获得鼠标坐标, 这个坐标便是基于屏幕坐标系计算得来的. 另外使用 Input.GetTouch(0).position 可以获得单个手指触摸屏幕时手指的坐标, 这个坐标也是基于屏幕坐标系计算得来的.\n\n需要注意的是屏幕坐标不是根据玩家显示器的大小建立的坐标系, 而是以游戏窗口建立的坐标系, 比如玩家屏幕为: 1920 X 1080, 但是游戏窗口是: 800 X 600, 那么右上角的坐标是 (800, 600).\n\n\n视图坐标 (View Point)\n摄像机预览窗口显示的画面, 也是基于游戏窗口建立的坐标系.\n\n视图坐标系的大小为单位 1, 窗口的左下角坐标为 (0, 0), 右上角坐标为 (1, 1).\n\n屏幕坐标单位化后得到的就是视图坐标.\n\n\nPivot &#x2F; Center 和 Local &#x2F; Global首先必须明确的是这两个功能是用于编辑器的, 不是应用于运行时的, 他们是为了让开发者更加方便地切换信息\nPivot vs CenterPivot 显示的位置是游戏物体在运行时的真实位置, 即 Transform 的 Position, 有的物体它的坐标和渲染出来的几何体可能并不在一个位置上, 这个可以让开发者非常方便的看到各个物体的真实位置, 当多选时, Pivot 显示的是最后一个选中的物体的真实位置\nCenter 显示的位置是游戏物体渲染后的几何体的中心位置, 可以让开发者方便的查看多个物体, 调整多个物体的缩放, 位移等, 当多选时, Center 显示的是多个物体的包围盒中心\nLocal &#x2F; GlobalLocal 模式下, 选中物体显示的坐标系是自身坐标系, 会跟着物体旋转, 因此当需要让物体按照自身方向移动或者旋转时, 便可以使用此模式\nGlobal 模式下, 则是始终显示世界坐标系, 这样即使物体旋转了, 调整物体的世界坐标也会非常方便\n参考文章\nUnity中屏幕坐标、视口坐标和世界坐标、局部坐标与其之间的相互转换\n\n理解Unity3D中的四种坐标体系\n\n\n","categories":["Unity"],"tags":["Unity"]},{"title":"如何创建自定义瓦片","url":"/unity/unity_customize_tile.html","content":"\n\n选用待继承的瓦片编写自定义瓦片其实就是通过继承 Unity 原有瓦片, 并添加新数据来创建自己的瓦片, 因此首先需要选用待继承的瓦片, 这个根据项目的需要选择即可.\n如果瓦片需要播放动画, 便需要继承动画瓦片, 需要使用预制体就继承预制体瓦片, 需要使用普通瓦片, 随机瓦片, 规则瓦片时都可以继承自规则瓦片.\n添加自定义数据using System;using UnityEngine;/// &lt;summary&gt;/// 魔剑镇魂曲瓦片, 继承自 RuleTile/// &lt;/summary&gt;[Serializable][CreateAssetMenu(fileName = &quot;New Sword Requiem Tile.asset&quot;, menuName = &quot;Sword Requiem Tile&quot;)]public class SwordRequiemTile : RuleTile&#123;    /// &lt;summary&gt;    /// 枚举: 地形类型    /// &lt;/summary&gt;    public EM_Terrain defaultTerrainType;&#125;\n\n上面是我自定义的 Sword Requiem Tile, 只添加了一个简单的枚举类型数据.\n\nSerializable: 标记此类可以被序列化.\n\nCreateAssetMenu: 标记此脚本可以在资源菜单中直接创建, 创建的默认文件为: New Sword Requiem Tile.asset, 菜单项的路径为: Sword Requiem Tile.\n\nSwordRequiemTile: 继承自规则瓦片的自定义瓦片的类型名称.\n\ndefaultTerrainType: 自定义数据-默认地形类型.\n\n\n[注] 这个地方有一个挺大的坑, 可以看到我这里的自定义数据使用的是 &#39;字段&#39; 而非 &#39;属性&#39;, 因为使用属性, Inspector 面板中便无法持久保存瓦片属性.\n表现在项目中就是, 首先创建枚举, &#39;森林&#39; 的枚举值为 0, &#39;断层&#39; 为 1, 我创建了一个 Sword Requiem Tile, 默认地形类型自动初始化为 &#39;森林&#39;, 然后修改瓦片的地形类型为 &#39;断层&#39;, 之后绘制地形, 运行游戏, 发现一切正常, 但是一旦关闭 Unity, 再次打开时所有瓦片的自定义数据全部会被重置为 &#39;森林&#39;, 即默认值, 想想这个多可怕!\n以上情况不知道是不是我自己的失误, 总之这里使用原始的字段不会有任何问题.\n","categories":["Unity"],"tags":["Unity","Tile"]},{"title":"战棋游戏中使用 Flood Fill 算法计算行动范围","url":"/unity/unity_floodfill.html","content":"\n\n环境文章中的项目是使用 Unity 创建的 2D 游戏项目, 代码是基于 Microsoft Visual Studio 编写, 使用的编程语言是 csharp.\n思想Flood Fill 算法翻译为中文可以叫: &quot;洪水填充&quot; 算法.\n从起始位置开始, 不断向外围进行检测, 就像从中心一点向外不断蔓延的洪水一般.\n话说这个蔓延方式也不像洪水啊, 不应该是核弹爆炸嘛~ 今天又是核平的一天呐~ 😅\n实现原理Flood Fill 算法的基本原理是基于一个待检查队列, 这个队列中存放接下来待检查的结点, 首先取出待检查队列中一个结点, 检查其坐标周围的四个结点,\n\n将这个四个结点中满足条件的结点添加到待检查队列, 之后从待检查队列中取出下一个待检查结点以同样的规则进行检查, 再将满足条件的结点添加到待检查队列, 如此反复,\n\n直到将待检查队列中的结点全部检查完毕!\n定义待检查队列中的结点类型/// &lt;summary&gt;/// Data Struct 范围结点/// &lt;/summary&gt;public class DS_FloodFill_Node&#123;    /// &lt;summary&gt;    /// 结点的 X 坐标    /// &lt;/summary&gt;    public int positionX;    /// &lt;summary&gt;    /// 结点的 Y 坐标    /// &lt;/summary&gt;    public int positionY;    /// &lt;summary&gt;    /// 到达此结点时剩余的步数    /// &lt;/summary&gt;    public int overStep;&#125;\n\n定义两个 int 字段存储结点的坐标, 再定义一个 overStep, 表示从起始坐标到达此结点所在坐标时剩余的步数.\n创建算法类/// &lt;summary&gt;/// 算法类: Flood Fill/// 洪水填充/// &lt;/summary&gt;public class AR_FloodFill&#123;    // 算法具体内容&#125;\n\n创建算法需要的临时变量/// &lt;summary&gt;/// 地图数据/// &lt;/summary&gt;private EM_Terrain[,] map;/// &lt;summary&gt;/// 1. 检查过的格子/// 2. 可行动范围 (无其他数据)/// &lt;/summary&gt;private bool[,] flagChecked;/// &lt;summary&gt;/// 可行动范围 (有其他数据)/// &lt;/summary&gt;private readonly List&lt;DS_FloodFill_Node&gt; range = new List&lt;DS_FloodFill_Node&gt;();/// &lt;summary&gt;/// 1. 循环检查游标, 指明列表中 &quot;当前待检查结点&quot; 的位置/// 2. 循环检查次数计数器/// &lt;/summary&gt;private readonly int checkIndex = 0;/// &lt;summary&gt;/// 是否无视地形/// &lt;/summary&gt;private bool isIgnoreTerrain;\n\n\nmap 是整张地图的数据, 虽然这里只是一个枚举数组, 但是项目中有一个字典变量, 通过这个枚举值便可以查到特定的地形类型所对应的全部数据, 包含地形名称, 地形提供的闪避率, 防御力, 攻击力, 生命回复等等. 全部的数据结构牵扯的东西比较多, 这里就不列出了.\n\nflagChecked 用来标记算法在循环过程中哪些坐标已经被检查通过了, 这样可以避免重复检查. 另外, flagChecked 使用的存储方式是二维数组, 它是将检查过的位置标记在相应的坐标处, 且只标记通过的位置, 即 flagChecked 的值就是最终的行动范围, 但是它不附带其他的数据.\n\nrange 记录的也是被检查通过的结点, 但是它会将全部信息进行保存.\n\ncheckIndex 是待检查队列的游标, 表示当前检查到什么位置了.\n\nisIgnoreTerrain 标识是否无视地形, 用于区分检测的是移动范围还是攻击范围.\n\n\n实现 Flood Fill 算法主方法/// &lt;summary&gt;/// 洪水填充算法/// &lt;/summary&gt;/// &lt;param name=&quot;map&quot;&gt;地图数据&lt;/param&gt;/// &lt;param name=&quot;startPositionX&quot;&gt;人物坐标 X&lt;/param&gt;/// &lt;param name=&quot;startPositionY&quot;&gt;人物坐标 Y&lt;/param&gt;/// &lt;param name=&quot;minRange&quot;&gt;最小直接行动范围&lt;/param&gt;/// &lt;param name=&quot;maxRange&quot;&gt;最大直接行动范围&lt;/param&gt;/// &lt;param name=&quot;isIgnoreTerrain&quot;&gt;是否无视地形&lt;/param&gt;/// &lt;returns&gt;可行动范围&lt;/returns&gt;public bool[,] FloodFill(EM_Terrain[,] map, int startPositionX, int startPositionY, int minRange, int maxRange, bool isIgnoreTerrain)&#123;    // 地图    this.map = map;    // 是否无视地形    this.isIgnoreTerrain = isIgnoreTerrain;    // 初始化存放已检查格子的数组    flagChecked = new bool[map.GetLength(0), map.GetLength(1)];    for (int i = 0; i &lt; flagChecked.GetLength(0); i++)    &#123;        for (int j = 0; j &lt; flagChecked.GetLength(1); j++)        &#123;            flagChecked[i, j] = false;        &#125;    &#125;    // 将起点存入 可行动范围    DS_FloodFill_Node startPosition = new DS_FloodFill_Node    &#123;        positionX = startPositionX,        positionY = startPositionY,        overStep = maxRange,    &#125;;    range.Add(startPosition);    flagChecked[startPositionX, startPositionY] = true;    // 扫描地图上特定坐标周围的格子, 计算行动范围    ScanMap(checkIndex);    // 判断是否去除起始坐标    RemoveMinRange(minRange);    // 返回数据    return flagChecked;&#125;\n\n这个方法做的事情不多 (读者: 整个 Flood Fill 算法做的事情也不多好吧! !), 首先初始化算法需要的数据, 之后将初始位置存入待检查队列等待第一次检查, 记得同时更新 range 和 flagChecked 的值, 然后便可以使用 ScanMap() 方法检查整张地图了, 最后判断一下是否需要移除起始坐标, 像使用物品是可以对自己使用的, 但是移动的时候原地移动是不算真正移动了的, 攻击也同样不能攻击自己, 最后将计算好的范围返回外部, 由外部进行处理.\nScanMap 方法/// &lt;summary&gt;/// 扫描地图上特定坐标周围的格子, 计算行动范围/// &lt;/summary&gt;/// &lt;param name=&quot;checkIndex&quot;&gt;特定坐标的索引&lt;/param&gt;private void ScanMap(int checkIndex)&#123;    // 只要还没有将所有的可移动范围检测完, 就继续检测    while (checkIndex &lt; range.Count)    &#123;        int positionX = range[checkIndex].positionX;        int positionY = range[checkIndex].positionY;        int overStep = range[checkIndex].overStep;        CheckMapPos(positionX, positionY + 1, overStep);        CheckMapPos(positionX - 1, positionY, overStep);        CheckMapPos(positionX, positionY - 1, overStep);        CheckMapPos(positionX + 1, positionY, overStep);        checkIndex++;    &#125;&#125;\n\nScanMap() 方法就是一个循环, 针对当前坐标计算出周围坐标, 然后使用 CheckMapPos() 方法检测特定坐标.\nCheckMapPos() 方法/// &lt;summary&gt;/// 检查地图上特定坐标/// &lt;/summary&gt;/// &lt;param name=&quot;positionX&quot;&gt;特定坐标 X 轴&lt;/param&gt;/// &lt;param name=&quot;positionY&quot;&gt;特定坐标 Y 轴&lt;/param&gt;/// &lt;param name=&quot;overStep&quot;&gt;剩余步数&lt;/param&gt;private void CheckMapPos(int positionX, int positionY, int overStep)&#123;    // 判断是否越界    if (positionX &lt; 0 || positionX &gt;= map.GetLength(0))    &#123;        return;    &#125;    // 判断是否越界    if (positionY &lt; 0 || positionY &gt;= map.GetLength(1))    &#123;        return;    &#125;    // 判断是否可以到达当前单元格    overStep = isIgnoreTerrain ? overStep - 1 : overStep - AD_Terrain.AD_Terrains[map[positionX, positionY]].BaseStepCost;    if (overStep &lt; 0)    &#123;        return;    &#125;    // 如果当前单元格已经在行动范围内了    if (flagChecked[positionX, positionY])    &#123;        int checkedRangeDataIndex = GetCheckedRangeDataIndex(positionX, positionY);        if (overStep &gt; range[checkedRangeDataIndex].overStep)        &#123;            // 更新在行动范围内的数据            DS_FloodFill_Node updatePosition = new DS_FloodFill_Node            &#123;                positionX = positionX,                positionY = positionY,                overStep = overStep,            &#125;;            range[checkedRangeDataIndex] = updatePosition;        &#125;    &#125;    else // 如果当前单元格没有在行动范围内    &#123;        DS_FloodFill_Node currentPosition = new DS_FloodFill_Node        &#123;            positionX = positionX,            positionY = positionY,            overStep = overStep,        &#125;;        range.Add(currentPosition);        flagChecked[positionX, positionY] = true;    &#125;&#125;\n\nCheckMapPos() 方法的重点就是退出条件.\n退出条件\n是否越界\n\n由于我项目中地图的坐标是从 (0, 0) 开始设计的, 所以这里的越界判断自然就是这样的写法啦~\n\n是否可以到达当前坐标\n\n这里的判断使用了 &#39;isIgnoreTerrain&#39; 变量, 当无视地形时, 每移动一个位置消耗的步数为 1, 用于使用物品以及攻击范围的计算, 不无视地形时, 每移动一个位置消耗的步数需要根据地形类型进行判断, 用于计算移动范围.\n[注] 另一个需要注意的是 overStep, 里面保存的值不一定是最大剩余步数.\n这个问题是计算行动范围时会遇到的特殊情况. 由于每个坐标消耗的步数不同, 所以经常会出现这种情况:\n\n假设行动步数为 10 步, 翻越城镇城墙消耗 5 步, 进入城镇消耗 1 步, 那么:\n路线1首先检测到了城镇入口, 到达时剩余步数为: 4;\n路线2之后检测到了城镇入口, 到达时剩余步数为: 6;\n于是单独写一个 if 进行判断, 如果结点已经检查过了, 那么比较两次路线的剩余步数, 并更新为大的剩余步数. 当然这个地方不写 (上面代码段中的最后一个 if else 逻辑) 也已经可以充分的实现计算行动范围了.\n独立方法最后便是提取出来的独立方法.\n/// &lt;summary&gt;/// 得到已经检查过的结点/// &lt;/summary&gt;/// &lt;param name=&quot;positionX&quot;&gt;特定坐标 X 轴&lt;/param&gt;/// &lt;param name=&quot;positionY&quot;&gt;特定坐标 Y 轴&lt;/param&gt;/// &lt;returns&gt;结点索引&lt;/returns&gt;private int GetCheckedRangeDataIndex(int positionX, int positionY)&#123;    // 已经检查过的就不用比较了, 因为已经检查过的剩余步数肯定已经最大了    for (int i = checkIndex + 1; i &lt; range.Count; i++)    &#123;        if (range[i].positionX == positionX &amp;&amp;            range[i].positionY == positionY)        &#123;            return i;        &#125;    &#125;    return 0;&#125;/// &lt;summary&gt;/// 移除小于最小范围的非法坐标/// &lt;/summary&gt;/// &lt;param name=&quot;minRange&quot;&gt;&lt;/param&gt;private void RemoveMinRange(int minRange)&#123;    // 记录下起始位置坐标    int startPositionX = range[0].positionX;    int startPositionY = range[0].positionY;    if (minRange &gt; 0)    &#123;        for (int i = 0; i &lt; range.Count; i++)        &#123;            if (Math.Abs(startPositionX - range[i].positionX) + Math.Abs(startPositionY - range[i].positionY) &lt; minRange)            &#123;                flagChecked[range[i].positionX, range[i].positionY] = false;                range.RemoveAt(i);                i--;            &#125;        &#125;    &#125;&#125;\n\n这样最终返回的 bool 数组便是可行动的范围!\n参考文章cocos creator 实现战棋类游戏移动范围效果\n","categories":["Algorithm"],"tags":["Algorithm"]},{"title":"Unity JsonUtility 序列化链表和字典","url":"/unity/unity_jsonutility.html","content":"\n\n前言为什么要用 JsonUtility 呢?\n\n第三方的 Json 库很多是不适配最新版 Unity 的, 另外就是对于强迫症而言, 难道你不想用 Unity 官方的吗, 难道不想自动更新吗? 一直需要手动更新也是很麻烦的.\n\n一般来说第三方的 Json 库都是不支持序列化 MonoBehaviour 类和 ScriptableObject 类的.\n\n据 Unity 手册上描述, JsonUtility 比目前流行的 .NET JSON 解决方案要快得多, 缺点就是 JsonUtility 提供的功能很少. 下面是 Unity 手册的原文:\n\n\n\n垃圾收集 (GC) 内存使用量为最低量:\n\nToJson 仅为返回的字符串分配 GC 内存.\nFromJson 仅为返回的对象以及所需的所有子对象分配 GC 内存 (例如: 如果对包含数组的对象进行反序列&gt;化,则 Unity 将为该数组分配 GC 内存)\nFromJsonOverwrite 仅根据需要为写入的字段 (例如字符串和数组）分配 GC 内存. 这意味着, 如果 JSON &gt;覆盖的所有字段都是值类型, 则 Unity 不会分配任何 GC 内存.\n可以使用后台线程中的 JsonUtility API. 但是, 与任何多线程代码一样, 在一个线程上序列化或反序列化对&gt;象时, 请勿在另一个线程上访问或更改该对象.\n\n\nUnity 手册: Json 序列化\nJsonUtility 使用条件\nJsonUtility 支持任何 MonoBehaviour 子类, ScriptableObject 子类或者带有 [Serializable] 属性的普通类或结构. 但是, 将 JSON 反序列化为 MonoBehaviour 或 ScriptableObject 子类时,必须使用 FromJsonOverwrite 方法, 如果尝试使用 FromJson 则 Unity 会抛出异常.\n\n将对象传入到标准 Unity 序列化程序进行处理时, 需要遵循与在 Inspector 中相同的规则和限制, 比如: Unity 只序列化字段, 不序列化属性;\n\n另外此 API 不支持类似 Dictionary&lt;&gt; 的类型; 也不支持将其他类型直接传递到 API, 例如原始类型或数组. 如果需要转换上述类型, 则需要将它们包裹在某种 class 或 struct 中.\n\n\nAPI 链接https://docs.unity3d.com/cn/2020.2/ScriptReference/JsonUtility.html\n另外还有一个编辑器模式下专用的 API: EditorJsonUtility\n它的链接是: https://docs.unity3d.com/cn/2020.2/ScriptReference/EditorJsonUtility.html\n如何使用 JsonUtility 序列化数组 [] 和链表 List&lt;&gt;由于 JsonUtility 不支持直接序列化数组和链表, 因此需要首先将其包装在一个 class 或者 struct 中, 之后对 class 或者 struct 进行序列化.\n以 List&lt;&gt; 和 class 为例. 使用特性 [Serializable] 修饰 class, 使 class 成为可序列化类型, 最后使用 [SerializeField] 修饰 List&lt;&gt;, 这样链表就可以被序列化成 Json 文本了.\n[Serializable]public class Enemy&#123;    [SerializeField]    public int id;    [SerializeField]    public List&lt;string&gt; skills;&#125;\n\n上面的字符串链表中的元素类型是 string, 是可以序列化的, 另一个成员 int 类型, 也可以序列化, 只要将类修饰为 [Serializable], 字段修饰为 [SerializeField] 便可以使用 JsonUtility 进行序列化了.\n注: 严格来说, 如果基础类型使用的是 public 修饰, 那么就不必使用 [SerializeField] 进行修饰, 如上面的 id 成员, 但是链表不是基础类型, 即使使用 public 修饰, 也必须使用 [SerializeField] 进行修饰.\n[Serializable]public class Enemy&#123;    public int id;    [SerializeField]    public List&lt;string&gt; skills;&#125;\n\n但是如果 id 是 private 类型的, 那么还是需要使用 [SerializeField] 进行修饰. 基础类型的序列化规则和 Inspector 面板的序列化规则是相同的.\n如何使用 JsonUtility 序列化字典 Dictionary&lt;&gt;字典即使使用上述方式也是无法进行序列化的, 这里需要使用到 Unity 提供的 ISerializationCallbackReceiver 接口.\n这个接口要求实现两个方法: OnBeforeSerialize() 和 OnAfterDeserialize().\npublic void OnBeforeSerialize()这个方法会在 序列化之前 调用.\npublic void OnAfterDeserialize()这个方法会在 反序列化之后 调用.\n我们的思路是: 将字典放到一个新的 class 中, 由于字典不能序列化, 但是链表可以通过使用 [SerializeField] 修饰来进行序列化, 因此可以使用两个 List&lt;&gt; 分别保存所有的键和所有的值, 并使用 [SerializeField] 进行修饰, 这样只要在序列化之前将字典中的值放到链表中即可, 最后序列化出来的结果就是两个链表.\n[SerializeField]private List&lt;TKey&gt; keys;[SerializeField]private List&lt;TValue&gt; values;Dictionary&lt;TKey, TValue&gt; target;public Serialization(Dictionary&lt;TKey, TValue&gt; target)&#123;    this.target = target;&#125;public void OnBeforeSerialize()&#123;    keys = new List&lt;TKey&gt;(target.Keys);    values = new List&lt;TValue&gt;(target.Values);&#125;\n\n由于序列化后是两个链表, 那么反序列化出来的数据也是两个链表, 此时就需要将这两个链表转换为字典.\npublic void OnAfterDeserialize()&#123;    if (keys.Count == values.Count)    &#123;        target = new Dictionary&lt;TKey, TValue&gt;(count);        for (var index = 0; index &lt; count; ++index)        &#123;            target.Add(keys[index], values[index]);        &#125;    &#125;&#125;\n\n最后再补一个将反序列化的字典返回的方法.\npublic Dictionary&lt;TKey, TValue&gt; ToDictionary()&#123;    return target;&#125;\n\n使用方法:\n// 序列化var data = new Serialization&lt;int, Enemy&gt;(enemies);string json = JsonUtility.ToJson(data);// 反序列化Dictionary&lt;int, Enemy&gt; enemies = JsonUtility.FromJson&lt;Serialization&lt;int, Enemy&gt;&gt;(json).ToDictionary();\n\n参考链接【Unity】JsonUtility で List と Dictionary&lt;TKey,TValue&gt; シリアライズする\n","categories":["Unity"],"tags":["Unity"]},{"title":"Unity 中的动态资源加载","url":"/unity/unity_load_assets.html","content":"\n\n前言游戏中资源的状态可以分为三种:\n\n状态1: 仅在磁盘中.\n状态2: 被读取到内存中, 但是游戏此时并没有引用此资源.\n状态3: 被读取到内存中, 并且游戏此时正在引用此资源.\n\nUnity 有两种模式: 编辑器模式和运行模式. 两种模式下都可以实现动态资源加载.\n编辑模式编辑模式下可以使用 AssetDatabase 类来实现资源的动态加载.\nAssetDatabase.LoadAssetAtPath(filePath);\n由于 Unity 资源的根目录为 Assets, 因此 filePath 参数必须以 Assets&#x2F; 开头, 另外需要加后缀名. 通过这个方法就可以加载指定 Assets 路径下的资源, 资源加载后便处于状态 2 了, 如果紧接着使用了此资源, 资源状态就变成了状态 3.\n如果从资源目录中读取了一个 Prefab 资源, 运行模式下可以使用 GameObject.Instantiate() 来实例化 Prefab, 但是编辑模式下怎么实例化 Prefab 呢? 可以使用 PrefabUtility.InstantiatePrefab() 方法在编辑器模式下实例化 Prefab.\n另外在编辑模式下使用以下方法来更新或者创建新的 Prefab, 需要传入游戏物体, 保存路径等信息.\n\nPrefabUtility.SavePrefabAsset()\nPrefabUtility.SaveAsPrefabAsset()\nPrefabUtility.SaveAsPrefabAssetAndConnect()\n\n如果想要销毁一个游戏对象, 运行模式下可以使用 Destroy(); 方法, 但是编辑器模式下怎么销毁一个游戏对象呢? 编辑模式下只能使用 Object.DestroyImmediate(Selection.activeObject, true); 来销毁游戏对象, 第二个参数决定是否卸载游戏物体引用的资源.\n\n执行 Object.DestroyImmediate(go, false); 之后资源就变成状态 2 了.\n执行 Object.DestroyImmediate(go, false); 之后资源就变成状态 1 了.\n\n运行模式运行模式下实现资源的动态加载有两种方式: Resources 和 AssetsBundle.\nResources 实现运行时资源的动态加载 Unity 在发布打包的时候会自动排除掉没有引用的资源, 只有 Resources 和 StreamingAssets 文件夹中的资源无论是否被引用都会被打包.\n另外场景中如果直接引用了 Resources 中的资源, 打包的时候 Resources 文件夹中的资源会被场景和 Resources 重复打包成两份.\n基于上述两个原因约定:\n\nResources 文件夹只能存放运行时动态加载的资源\nScene 不能直接引用 Resources 中的资源\n\nResources.Load(fileName) 可以实现在运行模式下动态加载 Resources 文件夹下的资源. 其中 fileName 参数必须是 Resources 文件夹的相对路径, 且不能带有后缀名.\n运行模式下删除对象的方法:\n// 立即删除游戏对象DestroyImmediate(go);// 在下一帧的时候删除游戏对象Destroy(go);// 特定秒数后删除游戏对象Destroy(go, 5f);\n\n运行模式下 Resources 卸载资源的方式:\n\n使用 Resources.UnloadAsset(go); 卸载内存中指定游戏物体所引用的资源.\n使用 Resources.UnloadUnusedAssets(); 卸载内存中所有未被引用的资源. 另外这是一个异步进程, 可以在 Update 中使用 isDone 来判断是否执行完毕.\n\n下面是推荐的 Resources 卸载资源的工具代码:\nusing System;using UnityEngine;using UnityEngine.Events;/// &lt;summary&gt;/// Unity 资源回收工具/// &lt;/summary&gt;public class UnityGCUtility : MonoBehaviour&#123;    private AsyncOperation asyncOperation;    private UnityAction callBack;    /// &lt;summary&gt;    /// 彻底卸载 Resources 中所有未被引用的资源    /// &lt;/summary&gt;    public void UnloadUnusedAssets()    &#123;        UnloadUnusedAssetsUnit(() =&gt;        &#123;            UnloadUnusedAssetsUnit();        &#125;);    &#125;    /// &lt;summary&gt;    /// 单次卸载资源模块    /// &lt;/summary&gt;    /// &lt;param name=&quot;callBackAction&quot;&gt;回调&lt;/param&gt;    private void UnloadUnusedAssetsUnit(UnityAction callBackAction = null)    &#123;        callBack = callBackAction;        GC.Collect();        asyncOperation = Resources.UnloadUnusedAssets();    &#125;    private void Update()    &#123;        if (asyncOperation == null) return;        if (!asyncOperation.isDone) return;        asyncOperation = null;        callBack?.Invoke();        DestroyImmediate(this);    &#125;&#125;\n\nAssetBundle 实现运行时资源的动态加载要想使用 AssetBundle 的方式实现动态资源加载, 首先需要将资源打包成一个 AssetBundle 包, 打包之前要对待打包资源进行依赖设置, 设置依赖的方式有两种:\n\n在 Inspector 面板的最下方设置, 不推荐使用.\n\n选中所有需要打入 AssetBundle 包的资源, 在这些资源的 Inspector 面板中设置 AssetBundle 的名称和后缀名.\n\n对于会被重复依赖的贴图材质等资源需要进行单独的 AssetBundle 名称以及后缀名设置, 不设置的话这些被依赖的资源会被重复打包, 浪费资源.\n\n\n\n直接在一个脚本中设置好需要打包的资源以及他们的依赖关系.\n  var builds = new List&lt;AssetBundleBuild&gt; &#123;    new AssetBundleBuild() &#123;        assetBundleName = &quot;prefab&quot;,        assetNames = new[] &#123;            &quot;Assets/Resources/Materials/1.prefab&quot;,            &quot;Assets/Resources/Materials/2.prefab&quot;,            &quot;Assets/Resources/Materials/3.prefab&quot;        &#125;    &#125;,    new AssetBundleBuild() &#123;        assetBundleName = &quot;material&quot;,        assetNames = new[] &#123;            &quot;Assets/Resources/Materials/ground.mat&quot;        &#125;    &#125;&#125;;\n\n之后在编辑器模式的脚本中调用构建管线来创建 AssetBundle, 需要的参数有: 输出路径, 压缩选项, 目标平台. \nBuildPipeline.BuildAssetBundles(outPath, BuildAssetBundleOptions.ChunkBasedCompression, BuildTarget.StandaloneWindows);\n下面是推荐的输出路径 outPath 构建代码.\n#if UNITY_ANDROID    var outPath = Application.dataPath + &quot;!assets&quot;;#else    var outPath = Application.streamingAssetsPath;#endif    if (Directory.Exists(outPath)) &#123;        Directory.Delete(outPath, true);    &#125;    Directory.CreateDirectory(outPath);\n\n[注] 推荐的代码中使用的路径是 Assets 根目录下的 StreamingAssets 文件夹, 因为这个文件夹中的所有资源都会直接打包并发布, 不会进行任何的压缩以及改变, 适合游戏中长期使用且不随版本变化的资源.\nAssetBundle 资源包已经打好了, 那 Unity 怎么读取这种资源包呢?\n因为 AssetBundle 包体之间是具有依赖关系的, 因此在读取可能具有依赖关系的资源之前, 应该先将这个包体所依赖的所有包体全部读取出来, 然后再对需要使用的资源进行处理.\n假设需要加载一个名称为 abPre 的包体, 那么首先应该读取这个包体的依赖关系, 所有的依赖关系均在 StreamingAssets 这个 AssetBundle 中, 依赖关系的文件名为: AssetBundleManifest.\nvar assetBundlePath = Application.streamingAssetsPath;var assetBundle = AssetBundle.LoadFromFile(Path.Combine(assetBundlePath, &quot;StreamingAssets&quot;));var manifest = assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;);foreach (var dependence in manifest.GetAllDependencies(&quot;abPre&quot;)) &#123;    AssetBundle.LoadFromFile(Path.Combine(assetBundlePath, dependence));&#125;\n\nabPre 包体所依赖的包已经全部使用 AssetBundle.LoadFromFile() 加载完毕了, 接下来就可以加载 adPre 包体了, 加载完之后便可以读取 abPre 包体中的资源了. 假设需要读取 adPre 包体中的一个名为 myCube 的预制体, 则:\nvar assetBundle = AssetBundle.LoadFromFile(Path.Combine(assetBundlePath, &quot;abPre&quot;));var go = assetBundle.LoadAsset&lt;GameObject&gt;(&quot;myCube&quot;);\n\n之后可以使用 Instantiate(go); 来实例化资源.\n使用完之后需要卸载资源, 卸载 AssetBundle 中的资源需要使用 AssetBundle.UnloadAllAssetBundles(false); 方法. 其中的参数 unloadAllObjects:\n\nfalse: 只卸载 AssetBundle 对象, 不卸载资源对象.\ntrue: 同时卸载 AssetBundle 对象和资源对象.\n\n","categories":["Unity"],"tags":["Unity"]},{"title":"Unity 项目注意点总结 (持续更新)","url":"/unity/unity_note.html","content":"\n\n抽象口诀\n不同类做相同事情用接口, 相同类做相同事情不同效果用委托\n当需要枚举的时候, 其实是需要委托\n类的方法是这个类自身的能力\n\nUnity 中的乱码问题Unity 项目所在电脑必须设置开启 Unicode UTF-8 提供全球语言支持 或者不要使用任何非 ASCII 字符\n\n另外当路径过长时, 就不要使用中文了, 或者使用中文时要保证路径长度较短, 因为 Unity 的进度条在显示时, 当检测到长路径会自动切割, 中间使用 ... 代替显示, 此时可能会出现乱码, Unity 在切割时可能把中文字符切割为乱码, 为了保证项目中哪里都不会出现乱码, 尽量还是全部文件名称和路径名称都使用英文\n路径和文件名中的中文编码是不可控的, 这个是操作系统决定的, 我们用户能决定的只有文件内容的编码, 因此强烈建议目录和文件名全部使用英文\n编程中关于 Null 值的处理返回值中的 null 值返回值的最终结论为: 项目中不存在任何的 return null 语句, 同时 不允许返回引用类型, 任何方法只能返回 Task void bool 这几种类型, 其中 bool 是成功标志\n优化措施:\n\n对于值类型的返回值, 将合法的 return null 全部改为有效空白值, 比如 string.Empty, 0, -1 等\n对于引用类型的返回值, 将合法的 return null 全部改为 out 类型参数返回, 本来的返回值改为 bool\n任意类型的非法的 return null 全部删除, 改为输出错误日志并抛出异常\n\n参数中的 null 值参数的最终结论为: 使用断言进行判断, 断言的好处是正式版本中断言是不执行的, 因此只要在开发版本中进行全覆盖测试, 就可以在正式版本中杜绝参数为 null 的情况\n编程中关于结构体的使用编程时结构体内的字段必须全部都是纯粹的值类型, 如果含有引用类型, 请使用 class\n\nstruct 中的字段禁止使用引用类型\n当一个数据体内部的全部字段是一个不可变化的整体时, 才能使用 struct, 并且每一个 struct 都是一个独立的数据副本\n\n编程中关于继承和接口的选择\n当单纯需要代码复用时可使用继承, 但不允许使用 override\n当明确存在默认行为时可使用继承以及 override\n多态一律使用接口实现: interface\n\nUnity 项目的中前期使用 Mono 打包, 后期使用 IL2CPP 打包IL2CPP 打包需要安装的环境\n\n\nVisual Studio 核心编辑器\nC++ 桌面开发环境\nMSVC C++ 编译器\nWindows 10 SDK &#x2F; Windows 11 SDK\n\nUnity 中使用 foreach 遍历不会有 GC将函数作为参数时必须使用匿名方式且必须不发生闭包直接传递函数的情况必然会有 GC, 无论传递的函数是否为静态函数// 传递普通方法 Sum, 会有 GCLaunch(Sum);private void Sum() &#123; &#125;// 传递静态方法 Sum, 同样有 GCLaunch(Sum);private static void Sum() &#123; &#125;\n\n使用匿名方式传递函数, 则根据是否闭包决定有无 GC// Sum 是闭包, 会有 GCLaunch(() =&gt; Sum());private void Sum()&#123;    sum++;&#125;// Sum 不是闭包, 无 GCLaunch(() =&gt; Sum());private static void Sum()&#123;    sum++;&#125;\n\nUnity 的 Git 仓库必须添加 RenameLimit 限制[user]    name = Kuroha    email = KurohaKirito@gmail.com[diff]    renameLimit=1    renames=false[merge]    renameLimit=1    renames=false    directoryRenames=conflict[status]    renameLimit=1    renames=false[http]    proxy = http://127.0.0.1:20122[https]    proxy = https://127.0.0.1:20122\n\n性能优化时, 顶点数小于 300 的网格禁止参与静态批处理当小于 300 顶点数的网格参与静态批处理时, 即使它最终只会作为静态网格的一个 submesh 存在, 但也会导致整个静态网格的 KeepVertices 被开启, 一旦这个选项被开启, 网格的顶点信息将会被保留在 CPU 内存中, 同时因为 GPU 那边还有一份内存占用, 从而导致静态网格的内存占用翻倍。因此顶点数小于 300 的网格禁止参与静态批处理。\n","categories":["Unity"],"tags":["Unity"]},{"title":"在 Unity 中导入模型材质球的最优雅姿势","url":"/unity/unity_model_importer.html","content":"\n\n🥦Model Importer 前言对于项目中模型的材质球导入问题一直没有明确的规范, 导致这块美术资源的处理要么依赖出问题, 分包出问题, 资源加载卡顿, 要么产生的额外材质球导致版本管理异常, 到处充斥着 Unity 拉的屎, 这里一坨, 那里一坨, 对于我这种强迫症晚期患者而言, 每每看见一坨坨的屎, 上班的心情都没有了~\n想起来自己曾经处理过这个问题, 但是当时的思路还是模模糊糊的, 处于一种总感觉哪里有问题却又说不上来的状态, 于是趁最近几天的空闲时间, 再次把这个问题捡起来, 彻底把坑填上!\n先来看一下官方对模型导入材质球的说明: 跳转官方手册 Materials tab\n🎈Material Tab 解析先来彻底解析一下 Model Importer 的 Material 页面\n\n这个页面就是控制 Unity 如何生成材质球的, 生成材质球的模式有 3 种: None Standard (Legacy) Import via MaterialDescription 下面来逐一说明\nNone此模式下 Unity 将不参考任何模型数据, 而是直接引用 Unity 标准材质球, 原文是 &quot;Unity&#39;s default diffuse Material&quot;\nStandard (Legacy)此模式下 Unity 将使用一组默认规则生成材质球, 即规则固定, 不支持自定义, 同时标准模式也不支持复杂的材质球\n比如 Arnold Material Physical Material HDRP Material 等\nImport via MaterialDescription此模式下 Unity 将使用 FBX 文件中嵌入的材质描述来生成材质, 相比标准模式, 此模式可以提供更准确的结果并支持更广泛的材质类型\n🍸三种模式的总结None 模式下会引用标准材质球, 并且无法移除, 因此不满足要求\nStandard (Legacy) 模式下会按默认规则生成材质球, 但是可以移除, 因此可以使用此模式\nImport via MaterialDescription 模式下会按模型内的材质描述信息生成材质球, 但目前项目中的模型都没有使用材质描述, 因此不适用\n下面来详细说明一下 Standard (Legacy) 模式, Import via MaterialDescription 模式就不讲解了, 感兴趣的可以自行查阅资料 (我才不会说我也不知道呢(●ˇ∀ˇ●))\n🍀Standard (Legacy)\nsRGB Albedo Colors\n\n此选项控制使用伽马空间还是线性空间\n说实话我并没有图形学相关知识, 我感觉这个选项技美人员肯定知道怎么设置, 交给专业人士了! 我们来看其他选项\n\nLocation\n\n重点来了 Location 选项, 这个选项用来控制 Unity 生成材质球的位置, 有 2 种选择\nUse External Materials (Legacy) 和 Use Embedded Materials 我来逐个说明\n🍇Use External Materials (Legacy)\n这个选项下, Unity 会尝试查找已有的材质球资源, 查找时按照 Naming 和 Search 配置的查找方式进行查找 (查找方式的配置在本文最后)\n那如果找不到会怎么样呢? 会 使用默认规则新建材质球资源并放置于同级的 Materials 文件夹中\n上图中可以看到, 模型 Model Demo 同级目录中有一个 Materials 文件夹, 里面存放的就是 Unity 在标准模式下生成的材质球\n🍉 External 模式总结优先尝试搜寻外部材质球, 搜寻不到则按默认规则新建材质球\n\n只有当模型和材质球具有强制要求的命名规则, 并且强绑定, 材质球不会复用的情况下才推荐 Use External Materials (Legacy) 设置\n否则一旦 Unity 找不到对应的材质球便会新建 Materials 文件夹以及对应的材质球资源, 但是没有哪个项目会使用 Unity 生成的默认材质球的, 这部分默认材质球很显然是多余的资源!\n因此不推荐!\n\n接下来看另一个选项\n🍒Use Embedded Materials\n这个选项下, Unity 会直接使用默认规则新建材质球资源\n但是和上一个选项不同的是不再放置于同级的 Materials 文件夹中, 而是直接作为模型的 SubAsset\n从上图中可以很明显地看到生成了 01 - Default 02 - Default 03 - Default 三个材质球, 并且是作为模型内嵌资源的形式\n但是作为内嵌资源的方式有很大的弊端, 那就是无法修改材质球的参数, 为了解决这个问题, Unity 提供了 资源导出 功能\n资源导出功能\nExtract Materials\n\n提取 Unity 使用默认规则新建的作为模型 SubAsset 资源的材质球资源到指定的目录中\n\nExtract Textures\n\n提取 Unity 使用默认规则新建的作为模型 SubAsset 资源的贴图资源到指定的目录中\n使用上述两按钮便可以导出 Unity 创建的材质球和贴图, 并且会将导出信息记录在 meta 文件的 externalObjects 字段中\n导出时无法指定某一个材质球或纹理单独导出, 只能导出全部的材质球或者全部的纹理\n每一条导出信息都由以下信息构成, 其中最关键的就是 name 信息, 只有名称和模型中记录的名称完全匹配的信息才视为一条正确的导出信息\n- first:    type: UnityEngine:Material    assembly: UnityEngine.CoreModule    name: 01 - Default  second: &#123;fileID: 2100000, guid: 6ec473d8d7e6a0f4b98313871e38903d, type: 2&#125;\n\n但是资源导出功能也仅仅是将资源导出而已, 使用的还是 Unity 按照默认规则生成的资源, 并不是我们自己的资源, 于是还有一个功能 资源重映射 功能\n资源重映射功能Remapped Materials 同样使用 Naming 和 Search 配置的查找规则尝试查找重映射材质球\n- first:    type: UnityEngine:Material    assembly: UnityEngine.CoreModule    name: 01 - Default  second: &#123;fileID: 2100000, guid: 6ec473d8d7e6a0f4b98313871e38903d, type: 2&#125;\n\n上面是一条合法的导出信息, 重映射功能修改的就是其中的 guid 字段信息\n因此 资源重映射 功能是以 资源导出 功能为基础的, 如果此时 meta 文件中没有任何导出信息, 执行重映射时便会自动新建对应材质球的导出信息, 相当于将指定的一个材质球执行了导出操作, 其余没有创建导出信息的依旧会以内嵌资源 (SubAsset) 的形式存在于模型资源中\n🍍Embedded 模式总结简单概括: 不存在导出信息时以内嵌资源的形式创建材质球, 存在导出信息时引用导出信息中的资源\n\n此模式在存在导出信息时会直接引用导出信息中的资源, 因此自定义程度极高, 强烈推荐此模式!\n但是要注意, 在没有导出信息的情况下, Unity 依旧会创建材质球, 虽然是以内嵌资源的形式, 但这依然不是我们想要的, 所以切记要设置导出信息才行!\n强烈推荐!\n\n🥒如何批量设置导出信息本文最后会贴出完整代码, 这里就只说一下思路\n\n将模型导入设置修改为 Standard + Embedded, 并重新序列化 meta 文件\n\n这是为了统一导入设置, 同时规范 meta 文件的格式, 为后面文本处理做准备\n\n使用逐行扫描的方式删除 &quot;  externalObjects:&quot; 到 &quot;  materials:&quot; 的全部 Remap 信息\n\n这里为什么不使用 Unity 自带的 RemoveRemap 呢? 因为模型中很可能会存在非法的 Remap 信息, 使用 RemoveRemap 根本无法移除这部分信息\n另外模型的 meta 文件结构固定且内容不多, 而且前面我们已经重新序列化了 meta 文件, 保证了 meta 文件格式的正确性, 因此直接逐行分析即可, 同时多线程进行优化\n\n添加空的 Remap 信息\n\nRemap 信息清空后, 只要添加空的 Remap 信息就可以实现既不生成额外资源, 又不会引用到外部资源的效果!\n至此结束, 具体代码可查看本文最后! 最后实现的效果如下, 可以看到正确生成了导出信息并且没有引用额外的资源!\n「算是某种意义上的卡 Bug？什么叫 Bug？！这叫机制！」\n- first:    type: UnityEngine:Material    assembly: UnityEngine.CoreModule    name: 01 - Default  second: &#123;instanceID: 0&#125;\n\n🍑总结\n\n\n模式\n描述\n是否推荐\n\n\n\nNone\n直接引用 Unity 默认材质球，无法移除\n❌ 不推荐\n\n\nStandard (Legacy)\n按默认规则生成材质球，可移除\n✅ 可选\n\n\nImport via MaterialDescription\n按材质描述生成材质球，可移除\n❌ 不适用\n\n\nUse External Materials (Legacy)\n优先查找外部材质球，找不到则新建材质球资源\n❌ 不推荐\n\n\nUse Embedded Materials\n生成材质球为 SubAsset，可配合导出和重映射功能\n✅ 强烈推荐\n\n\nExtract Materials\n提取 Unity 生成的材质球资源\n\n\n\nExtract Textures\n提取 Unity 生成的纹理资源\n\n\n\nRemapped Materials\n通过导出信息替换默认材质\n\n\n\n🌳附录一：查找规则的配置Naming用于控制搜索时的名称规则\n\nBy Base Texture Name\n\n使用材质关联的主纹理名称作为线索进行查找\n\nFome Model&#39;s Material\n\n直接使用模型文件中定义的材质名称作为线索进行查找\n\nModel Name + Model&#39;s Material\n\n组合模型文件名和模型文件中定义的材质名作为线索进行查找\nSearch用于控制搜索的位置\n\nLocal Materials Folder\n\n仅在模型文件同级目录的 Materials 文件夹中搜索\n\nRecursive Up\n\n从模型文件所在目录开始向上逐级递归搜索\n\nProject Wide\n\n在整个项目范围内搜索\n🍈附录二：为什么 Extract Materials 按钮, Extract Textures 按钮是置灰的 ?这两个按钮在两种情况下是置灰的\n\n模型内部没有材质球和贴图时\n\nmeta 文件中已经记录了全部资源的导出信息时\n\n\n第一种情况很好理解, 关键是第二种情况, 假设 Unity 检测到模型中有 3 张纹理, 2 个材质球\ntex_1 tex_2 tex_3 mat_1 mat_2\n而目前 meta 中已经记录了 2 张纹理和 2 个材质球的导出信息\ntex_1 tex_2 mat_1 mat_2\n则导出贴图按钮就是可用的, 导出材质球按钮就是置灰的\n🥕附录三：设置模型导出信息的完整代码/// &lt;summary&gt;/// 移除模型的内嵌资源/// &lt;/summary&gt;/// &lt;param name=&quot;modelGUIDs&quot;&gt;需要处理的模型 GUID&lt;/param&gt;public static async void RemoveEmbeddedAssetsInModel(params string[] modelGUIDs)&#123;    #region 前提准备, 反射内部逻辑    var sourceMaterialsProperty = typeof(ModelImporter).GetProperty(&quot;sourceMaterials&quot;, BindingFlags.NonPublic | BindingFlags.Instance);    if (sourceMaterialsProperty == null)    &#123;        DebugUtil.LogError(&quot;未反射到属性 sourceMaterials! 请更新工具逻辑!&quot;, DebugUtil.RED);        return;    &#125;    #endregion    var modelList = TempDictionary&lt;string, ModelImporter&gt;.Get();    #region 获取全部模型    foreach (var modelGUID in modelGUIDs)    &#123;        var assetPath = AssetDatabase.GUIDToAssetPath(modelGUID);        var assetImporter = AssetImporter.GetAtPath(assetPath);        var modelImporter = assetImporter as ModelImporter;        if (modelImporter == null)        &#123;            continue;        &#125;        modelList.Add(assetPath, modelImporter);    &#125;    #endregion    #region 将模型设置为 Standard + Embedded    foreach (var modelImporter in modelList.Values)    &#123;        modelImporter.materialImportMode = ModelImporterMaterialImportMode.ImportStandard;        modelImporter.useSRGBMaterialColor = true;        modelImporter.materialLocation = ModelImporterMaterialLocation.InPrefab;        modelImporter.SaveAndReimport();    &#125;    #endregion    #region 删除 &quot;  externalObjects:&quot; 到 &quot;  materials:&quot; 的全部 Remap 信息    // 另外因为模型中会存在非法的 Remap 信息, 使用 RemoveRemap 根本无法移除这部分信息    // 加上模型的 meta 文件结构固定且内容不多, 因此直接逐行分析    var tasks = TempleList&lt;Task&gt;.Get();    foreach (var modelData in modelList)    &#123;        tasks.Add(Task.Run(() =&gt;        &#123;            var metaPath = $&quot;&#123;modelData.Key&#125;.meta&quot;;            var needKeep = true;            var newMeta = TempleList&lt;string&gt;.Get();            var metaLines = File.ReadAllLines(metaPath);            foreach (var line in metaLines)            &#123;                if (needKeep)                &#123;                    if (line == &quot;  externalObjects:&quot;)                    &#123;                        newMeta.Add(&quot;  externalObjects: []&quot;);                        needKeep = false;                    &#125;                    else                    &#123;                        newMeta.Add(line);                    &#125;                &#125;                else                &#123;                    if (line == &quot;  materials:&quot;)                    &#123;                        needKeep = true;                    &#125;                &#125;            &#125;            File.WriteAllLines(metaPath, newMeta);            TempleList&lt;string&gt;.Back(newMeta);        &#125;));    &#125;    await Task.WhenAll(tasks);    TempleList&lt;Task&gt;.Back(tasks);    AssetDatabase.Refresh();    #endregion    #region 添加空的 Remap 信息    foreach (var modelData in modelList)    &#123;        var assetIdentifiers = sourceMaterialsProperty.GetValue(modelData.Value) as AssetImporter.SourceAssetIdentifier[];        if (assetIdentifiers.IsNullOrEmpty())        &#123;            DebugUtil.LogError($&quot;错误! 模型 &#123;modelData.Key&#125; 没有可以执行重映射逻辑的材质球!&quot;, DebugUtil.RED, modelData.Value);        &#125;        assetIdentifiers.TheAll(identifier =&gt; modelData.Value.AddRemap(identifier, null));        modelData.Value.SaveAndReimport();    &#125;    #endregion    TempDictionary&lt;string, ModelImporter&gt;.Back(modelList);&#125;","categories":["Unity"],"tags":["Unity"]},{"title":"Unity 游戏的模组支持开发总结","url":"/unity/unity_mod_programming.html","content":"\n\n🐬前言模组支持的核心需求主要包含以下两部分:\n\n资源模块: 允许模组作者修改&#x2F;新增游戏配置, 包括角色, 技能, 道具等\n编程模块: 允许模组作者通过脚本扩展游戏逻辑\n\n本篇自然以我开发的《魔剑镇魂曲重制版》为例, 因为我也只是一个新手菜鸟, 这次的目标便是完整地实现上述两方面功能即可\n🐤为模组添加 &quot;资源模块&quot; 支持这一部分的思路其实非常简单, 就是游戏内指定一种文本语法, 让模组作者使用这种语法编写配置文本文件, 我们在游戏中按照对应的语法格式读取文本文件, 并添加到游戏数据库中即可\n注: 这里的数据库并不是网站开发中的数据库, 而是指游戏内的静态数据, 其实这才是数据库一词的真实含义, 一个完全静态数据的集合就是数据库\n🤠本体数据库的格式选择: ScriptableObject我这里使用了 Unity 提供的 ScriptableObject, 为什么使用这个呢?\n传统的数据配置大多使用 Excel, 充分利用 Excel 那丰富的表格功能, 最大程度提升策划们的工作效率, 同时也提升其他人的阅读效率, 但是 Excel 无法参与 Git 版本管理, 因此大多项目组会将 Excel 文件视为源文件, 真正参与到项目中的是 Excel 导出的 CSV 文件, 这是一种纯粹的带语法格式的文本文件, 虽然语法格式就是简单的用 tab 分割, 但这也是一种语法格式, 这样的 CSV 就可以参与到项目管理中了, Excel 则被纳入了项目外的单独管理中\n但实际情况是, 我的项目很小, 从头到尾仅有我一人进行开发, 全部的任务都由我一人完成, 没有其他的阅读者和协作者, 因此保证我的开发效率才是最重要的, 而且使用 Excel 还要编写 Excel 到 CSV 和 CSV 到 Excel 的自动化转化逻辑, 这部分对于我这个单人项目而言, 完全没必要\n按照这个思路下去, 最优的选择自然就是 Unity 原生支持的 ScriptableObject 了, 我还可以很方便快速地编写 C# 脚本进行批处理, 这种效率可不是 Excel 能比的 (因为我使用 Excel 并不熟练, 只会基础操作)\n还有一个更重要的点, 使用 csv 文件还需要编写对应的 csv 解析逻辑, 不仅如此, 还得写一个对应的数据类, 将 csv 中的数据读取到数据类中, 但是既然都需要编写数据类了, 那为什么不直接将这个数据类继承自 ScriptableObject 呢, 这样都不需要编写解析逻辑了, 直接通过 Unity 读取 ScriptableObject 即可, 一步到位!\n💊模组数据库的格式选择: Json这里最开始选择的是最通用的文本文件, 语法自定义, 最终的配置文件如下:\n\n三暗影|1.0\ncontent|role|莱希尔\nrole|icon|male|textures&#x2F;48_头像_莱希尔.png\nrole|icon|female|textures&#x2F;48_头像_莱希尔.png\nrole|portrait|male|textures&#x2F;48_立绘_莱希尔.png\nrole|portrait|female|textures&#x2F;48_立绘_莱希尔.png\n\n这种自定义语法的优点是非常直观, 模组作者一看就懂, 我只要说明有哪些字段可用即可\n但是问题就是想要支持任何一个修改点都需要我编写代码, 比如上面的示例便是支持修改角色的立绘和头像, 仅仅这一个修改点就要写一个类, 那无论是职业, 角色, 道具, 地图, 关卡, 关卡事件, 关卡事件的条件, 关卡事件的行为, 音乐, 技能等等, 每一个模块中都有十几甚至几十个数据点, 如果每个数据点都要编写代码来给模组作者提供支持, 这个任务量可想而知, 于是此方案废弃\n之后开始选择更加成熟的语法文件, 最终在大量的语法文件中选择了 json 文件, 其他的像 xml, ini, yaml 等都或多或少存在一些问题, 同时 json 也是我最熟悉, 最喜欢的格式, 因为它既兼顾了可读性, 又有极强的规范性, 且非常成熟, 各大编辑器都支持 json 文件, 更重要的是 Unity 唯一支持的序列化就是 json, Unity 提供的 JsonUtility 类是目前已知效率最高的 json 序列化器, 不使用的话真的是有点暴殄天物, 所以 json 成为了不二之选\n什么 ? 你说 Unity 的 JsonUtility 兼容性不行 ? 那是你不会用, 经过我扩展的 JsonUtility 目前已经没有不支持的类型了, 再说除了 Unity 的 JsonUtility 你还知道哪个 Json 序列化器原生支持序列化 Unity 的专有类型呢 ?\n当然还有最最最重要的一点, 那就是 支持配置数据的局部修改\nUnity 的 JsonUtility 有一个极方便的方法: FromJsonOverwrite 使用此方法便可以允许模组作者编写 Json 文件时, 仅需要编写要修改的字段, 如果字段不需要修改, 那就不需要书写, Unity 会自动使用原数值, 大大提升了模组作者的开发效率\n比如我只想修改物品的价格, 那么只要填写 id 和 price 两个字段即可, 其他的字段完全不需要, 就是如此简单, 仅 2 行就写完了一个物品\n&#123;  &quot;id&quot;: &quot;core.item.001.飞刀&quot;,  &quot;price&quot;: 400&#125;\n\n🍓实现资源模块的过程接下来阐述资源模块的实现过程, 包括游戏本体的处理和模组部分的处理\n本体: 编写数据库管理系统游戏本体的数据库管理系统只需要满足一个最重要的需求即可: 热重载, 即可以在运行时重置数据库数据, 并重新加载数据库\n因为模组在开启后, 是可以被玩家关闭的, 那么此时就需要重置数据库, 或者重新加载数据库, 不能让已关闭的模组中的数据污染数据库\n如何实现数据库的热重载呢 ?\n数据库统合管理器第一步, 编写数据库管理器, 用于统合每一个小的数据库, 同时提供全局的加载方法\nloadTaskList.Add(SO_Affix.Collect(labelReference));loadTaskList.Add(SO_AudioClip.Collect(labelReference));loadTaskList.Add(SO_Bonus.Collect(labelReference));loadTaskList.Add(SO_Equip.Collect(labelReference));loadTaskList.Add(SO_GameMode.Collect(labelReference));loadTaskList.Add(SO_Item.Collect(labelReference));loadTaskList.Add(SO_Job.Collect(labelReference));loadTaskList.Add(SO_Level.Collect(labelReference));loadTaskList.Add(SO_Map.Collect(labelReference));loadTaskList.Add(SO_Role.Collect(labelReference));loadTaskList.Add(SO_Skill.Collect(labelReference));loadTaskList.Add(SO_Tile.CollectCastle(labelReference));\n\n颗粒数据库的加载逻辑第二步, 编写每一个小数据库的加载逻辑, 我这里使用的是 Unity 提供的 Addressable 系统\npublic static Dictionary&lt;string, SO_Item&gt; DB &#123; get; &#125; = new Dictionary&lt;string, SO_Item&gt;();public static Task Collect(AssetLabelReference labelReference)&#123;    DB.Clear();    labelReference.labelString = nameof(SO_Item);    return Addressables.LoadAssetsAsync&lt;SO_Item&gt;(labelReference, LoadAsset).Task;&#125;private static void LoadAsset(SO_Item asset)&#123;    DB[asset.id] = Instantiate(asset);&#125;\n\n这里有一个非常非常非常重要的点: DB[asset.id] = Instantiate(asset);\n这里为什么不能直接保存读取的 asset 而是要 Instantiate(asset) 呢? 这是因为 Unity 引擎中, ScriptableObject 的数值一旦被修改, 必须关闭游戏再次启动才能将数据还原, 因此一旦直接保存了 asset, 后面加载模组数据时, 有的模组修改了其中的数据, 那么这份数据就被永久修改了, 即使是重新加载这份资源, 也还是修改后的数值, 除非关闭游戏\n但是每次进行模组的切换肯定不能让玩家重启游戏, 因此这里必须实例化一份新的资源, 游戏仅使用新实例化出来的副本, 而不是使用原数据, 只要注意好这点, 本体的数据库管理就完成了!\n本地: 拆分数据结构什么是拆分数据结构 ? 要怎么拆 ? 为什么要拆 ?\n拆分数据结构就是把要开放给模组作者的字段和不开放给模组作者的字段拆开, 因为我的项目是直接使用的 ScriptableObject 文件, 因此数据类中包含 Sprite, AudioClip 这种资源字段, 而这些字段是不能直接开放给模组作者的, 模组作者使用的字段应该是 string, 即资源的路径, 因此需要这样拆分开数据类\n看看下面的 3 个类, 应该一下子就明白了吧, 真正要开放给模组作者的便是 DatabaseItem 类\npublic class SO_Item_Base : ScriptableObject&#123;    public string id;    public string displayName;&#125;public class SO_Item : SO_Item_Base&#123;    public Sprite icon;&#125;public class DatabaseItem : SO_Item_Base&#123;    public string iconPath;&#125;\n\n本地: 资源标识规范化游戏内资源的标识有几种方案选择\n枚举枚举方案, 即硬编码方案, 将数据直接硬编码到程序中, 优点显而易见, 标识绝对不会出错, 一旦出错, 编译都无法通过, 缺点也是致命的, 无法运行时动态增删, 对于模组支持而言是致命的, 此方案舍弃\n数字数字方案, 比较常用的方案, 每一个资源都有自己的数字标识, 可以动态增删, 但是对于模组支持而言也有致命缺陷: 标识冲突\n因为使用数字标识, 那么模组中新增的资源也必须使用数字标识, 这样的话, 模组作者之间的标识冲突便成为了必然, 毕竟谁也没有规定谁必须使用哪个范围内的数字, 我用了 100 - 200, 他也可以用 100 - 200, 这种冲突完全不可控, 此方案舍弃\n字符串在前两个方案都无法满足的情况下, 就只能使用字符串了, 但是字符串作为标识也不能随便使用, 而是必须要有规范, 即使用: 语义字符串\n语义字符串语义字符串即字符串是有语义的, 我直接以我项目中的标识来讲解, 举例两个目前使用的标识\n这个是本体中资源的标识: core.role.001.kirito\n这个是模组中资源的标识: mod.kuroha.role.001.asuna\n\n第一组语义为本体还是模组, 本体统一使用 core, 模组则统一要求作者们使用 mod\n第二组语义为模组作者的名字, 此语义仅模组使用, 游戏本体省略\n第三组语义为资源类型, 这里举例为 role\n第四组语义为资源序号, 这里举例为 001\n第五组语义为资源名称, 这里举例为 kirito 和 asuna\n\n通过这样的语义标识可以彻底避免游戏本体和模组作者以及各个模组作者之间的标识冲突问题 \n模组: 添加语法文件解析这个步骤非常简单, 目标就是读取模组的 json 文件并解析为对应的资源, 核心点就是利用 FromJsonOverwrite 方法实现部分配置的修改, 下面是我的模组数据结构\n\n最重要的点就是让模组的作者配置好 json 所代表的数据类型, 这样我们在解析时就可以按照对应的标识解析为对应的数据类型了, 以关卡数据结构为例, 整个的解析方法就这么几行, 非常简单:\npublic class DatabaseLevel_Parser : IParser&#123;    private SO_Level coreAsset;    private SO_Level newAsset;    public bool IsMatch(ModContent content)    &#123;        coreAsset = null;        newAsset = null;        return content.type == &quot;database_level&quot;;    &#125;    public bool IsCoreAsset(string jsonText)    &#123;        newAsset = UnityEngine.ScriptableObject.CreateInstance&lt;SO_Level&gt;();        UnityEngine.JsonUtility.FromJsonOverwrite(jsonText, newAsset);        return SO_Level.DB.TryGetValue(newAsset.id, out coreAsset);    &#125;    public Task Parse(string jsonText)    &#123;        if (IsCoreAsset(jsonText))        &#123;            UnityEngine.JsonUtility.FromJsonOverwrite(jsonText, coreAsset);        &#125;        else        &#123;            SO_Level.DB[newAsset.id] = newAsset;        &#125;        return Task.CompletedTask;    &#125;&#125;\n\n模组: 添加图片和音乐外部加载支持模组中支持模组作者自己添加精灵图和音乐, 自然需要对应的代码支持, 这个我不再废话什么了, 直接上代码\n导入图片支持var texture = new Texture2D(2, 2, TextureFormat.RGBA32, false);texture.LoadImage(await File.ReadAllBytesAsync(texturePath));texture.Apply();var rect = new Rect(0, 0, texture.width, texture.height);var pivot = new Vector2(0.5f, 0.5f);var sprite = Sprite.Create(texture, rect, pivot);\n\n导入音频支持var URI = $&quot;file://&#123;audioPath&#125;&quot;;using (var assetRequest = UnityEngine.Networking.UnityWebRequestMultimedia.GetAudioClip(URI, audioType))&#123;    await assetRequest.SendWebRequest();    if (assetRequest.result == UnityEngine.Networking.UnityWebRequest.Result.Success)    &#123;        audioCache.Add(subPath, UnityEngine.Networking.DownloadHandlerAudioClip.GetContent(assetRequest));    &#125;&#125;\n\n🍉为游戏添加 &quot;编程模组&quot; 支持添加模组支持主要分两部分, 一部分是如何给予模组作者一个可编译, 可编写, 可生成的编程环境, 让模组作者可以直接引用项目中的 API, 另一部分是如何加载模组作者的 DLL, 将模组作者的逻辑注入到自己的逻辑中\n这里不考虑非 C# 语言, 因此下文中默认模组作者编写的逻辑最终会生成 DLL 文件\n如何加载模组作者 DLL 中的逻辑先来说比较简单的第二部分, 因为使用的是 DLL 文件, 因此最终的加载肯定是使用 Assembly.Load 函数, 但是众所周知, 选择使用 Mono 时, 可以直接使用此函数, 但是当选择 IL2CPP 时, 项目是不支持上面的函数的, 所以这里必须使用 HybridCLR 插件, 使用此插件后便可以使用 Assembly.Load 了, 关于如何使用  HybridCLR 插件, 我就不赘述了, 因为官方文档实在是太详细了, 完全没有需要补充的点, 这里直接发出链接, 照着教程走, 几分钟就搞定了! 当然前提是你有优雅的代码管理习惯, 不然, 可能项目要大改!\nHybridCLR 官网\nHybridCLR 官方手册\njson 方案最简单的方案是和前面的资源模块一样, 让模组作者把 DLL 中类的全名, 全名就是包含命名空间名, 以及类的功能类别配置到 json 中, 只要知道了类的全名和功能类别, 我们就可以加载对应的类, 并将其注入到对应的功能模块中, 简单可行!\n反射方案自行反射实现了对应接口的类, 之后将这些类直接注入到功能模块中, 更加简单直接, 对模组作者非常友好, 不需要模组作者自行配置, 可行!\n特性方案提供多个特性, 让模组作者可以对自己编写的类进行修饰, 简明易读, 之后我们反射对应的特性, 将类注册到对应的功能模块中, 可行!\n上述三种方案均可实现逻辑注入, 可自行选择方案\n必须实现的逻辑目前我认为, 除了按照项目特点开放出来一些接口, 以供模组作者实现以外, 还有一个必须实现的功能就是 MonoBehaviour 脚本的编写, 允许模组作者自行编写 MonoBehaviour, 使用 Unity 的生命周期实现任意的自定义逻辑\n但是这样会有问题, 就是可能会触及到敏感代码, 如果项目中确实有敏感代码, 千万不能开放 MonoBehaviour, 相反便建议支持 MonoBehaviour, 毕竟这是最高自由度的编码, 下面放一段简单的逻辑注入代码\nvar modAssembly = Assembly.Load(File.ReadAllBytes(Path.Combine(Global.MOD.currentModFolder, modData.jsonPath)));foreach (var type in modAssembly.GetTypes())&#123;    if (type.IsDefined(typeof(Mod_SkillAttribute), false))    &#123;        SkillRegister(type);    &#125;    else if (type.IsDefined(typeof(Mod_AffixAttribute), false))    &#123;        AffixRegister(type);    &#125;    else if (type.IsDefined(typeof(Mod_MonoBehaviourAttribute), false))    &#123;        MonoRegister(type);    &#125;&#125;private static void MonoRegister(Type type)&#123;    var monoName = type.Name;    if (Global.MOD.modMonoBehaviourTable.TryGetValue(monoName, out var mono))    &#123;        DebugUtil.LogWarning($&quot;已存在类型: &#123;mono&#125;&quot;, DebugUtil.YELLOW);        return;    &#125;    var monoGameObject = new GameObject(monoName);    monoGameObject.transform.SetParent(Global.MOD.modMonoBehaviourRoot.transform);    Global.MOD.modMonoBehaviourTable[monoName] = monoGameObject.AddComponent(type) as MonoBehaviour;&#125;private static void AffixRegister(Type type)&#123;    Global.AFFIX.RegisterLogic(Activator.CreateInstance(type) as Affix);&#125;private static void SkillRegister(Type type)&#123;    Global.SKILL.RegisterLogic(Activator.CreateInstance(type) as Skill);&#125;\n\n如何给予模组作者 DLL 开发环境这里就是本文的重中之重了, 如何给予模组作者一个可编码, 可编译, 可生成的游戏开发环境, 就像 Unity 给我们开发者提供了开发环境一样, 我们也要给模组作者提供开发环境\n提供开发环境的意思就是, 模组作者可以直接调用我们项目中的代码, 可以直接编译通过, 生成 DLL 文件, 那么我们就需要把代码开放出来, 对吧 ?\n\n啊 ? 这对吗 ? 这不对吧 ? 把代码开放出来 ? 你 TM 在开玩笑吗 ? 你干脆让我开源算了 ...\n好事做到底, 直接开放项目, 让他们可以重打包, 发布游戏赚钱, 我直接成为别人的打工人算了 ... 岂不美哉 ?\n\n哈哈哈, 冷静, 冷静 ... 听我慢慢说 ... \n因为 C# 是编译型语言, 所以想要让模组作者可编码, 可编译, 可生成, 提供游戏内的基础库是必须的, 不然他们根本无法编码, 但是我们也不能暴露自己的代码实现呀, 毕竟 DLL 发出来就和代码裸奔没什么区别, 那么有什么办法既可以满足模组作者的需要, 又可以满足我们开发者的需要呢 ?\n有, 有的, 兄弟!\n那就是声明式程序集\n声明式程序集声明式程序集中仅包含声明, 没有任何的实现, 也就是说这个 DLL 仅能用来辅助编译, 无法被加载, 被识别, 因为里面是空的, 只有一堆声明信息, 这样就满足双方的需求了!\n那么:\n\n如何生成声明式程序集呢 ? \n生成声明式程序集时要注意什么呢 ? \n无法被加载又是什么意思, 会有哪些坑呢 ?\n\n如何生成声明式程序集声明式程序集其实就是 &quot;类库&quot; 类型项目的构建结果\n回想下最初学习编程时, 是不是面对一个黑窗口 (cmd) 来查看编程结果, 那种项目便是控制台类型项目, 最终的构建结果是一个 exe 文件, 而这里的声明式程序集就是一个 &quot;类库&quot; 型的项目, 最终的构建结果是 DLL 文件\n我用 Rider 打开类库项目, 尝试生成声明式程序集, 发现并不行, 只能生成完整程序集, 于是目前为止, 我所知道的能够一键生成声明式程序集的软件就是 Visual Studio\n为什么不说 VS Code 呢, 因为这个软件需要手动配置, 并不是一键生成, 对新手并不友好, 也就是对我不友好, 同时 Unity 想要打包 IL2CPP 的话, 需要安装 C++ 编译器, 还需要安装 Windows 10 SDK, 如果仅使用 VS Code , 那么这些环境都是需要自己手动去折腾的\n于是统合上述全部需求, 既可以一键管理开发环境, 一键管理编译器, 一键管理 Windows SDK 的安装卸载, 又可以编译生成声明式程序集的 Visual Studio 自然成为了首选\n接下来我会以自己项目为例, 一步一步讲述如果构建自己游戏的 SDK\n声明式程序集生成步骤安装开发环境在 Visual Studio Instanller 中安装 .Net 桌面开发 组件, 仅安装基础组件即可, 其它的附加组件其实都不需要, 当然安装了也不是不行\n新建解决方案启动 Visual Studio 2022 , 选择创建新项目\n\n选择 &quot;类库&quot; 类型, 注意项目图标右上方的语言标识, 记得选择 C# 的, 不要选择了 VB 或者 F# 的\n\n填写名称, 选择项目目录\n\n框架选择 .Net Standard 2.1\n其实选择 .Net Standard 2.0 应该也可以, 不过我没试过\n\n删除默认项目删除解决方案中的默认项目, 右键项目, 在菜单中选择移除\n移除后, 项目所以不再属于此解决方案中, 但是项目本身的文件还在存在于磁盘中的, 建议找到目录中的项目文件, 也一并删除\n\n新建 Unity 项目按照 Unity 项目中程序集的划分来建立项目, 比如我的项目中划分的运行时项目有 7 个, 那么就需要新建 7 个项目, 在解决方案菜单上右键, 选择添加, 新建项目, 只有和游戏运行相关的需要在这里参与编译, 生成声明式程序集, 其他不参与的编辑器程序集则不需要新建\n\n填入在 Unity 中填写的程序集名称, 比如和 Unity 中的保持一致, 至于为什么, 我最后解释, 这里先这么做\n新建项目后, 记得把项目中默认的 Class1.cs 删除, 因为我们不需要编写额外代码, 到时候直接把项目代码拷贝过来就可以了\n我的项目中划分的运行时项目有 7 个\n\nARModule\nKuroha.PNG\nKuroha.GIF\nKuroha.KConsole.Runtime\nKuroha.UI.Runtime\nKuroha.Utility.Runtime\nSwordRequiem.Runtime\n\n全部项目新建完成后截图如下\n\n将 Unity 中的代码拷贝到对应的项目中将 Unity 中的代码拷贝到相对应的项目中, 如果你会使用 Windows 软链接, 可以使用软链接直接同步过去, 当然此时项目中将会有大量的报错, 没关系, 这是因为没有引用相关的 Unity 程序集导致的, 代码拷贝完成后的截图如下\n\n引入依赖的 Unity 类库和第三方插件库下一步就是解决对 Unity 类库和第三方插件库的依赖问题, 解决原理就是直接让 Unity 打一次包就可以了, Unity 打包后生成的 DLL 肯定是全的, 不然游戏运行不起来呀, 对吧 ?\n\n如果你的项目是 Mono 项目, 则直接打一个包, 打包后程序的 Managed 文件夹中会生成项目全部的 DLL 文件, 将这些文件拷贝到一个特定的目录, 让  SDK 解决方案中的每一个项目都去引用他们即可, 需要注意, 千万不要一股脑全选引用, 因为很多是重复引用, 是不能添加的, 按照你项目自己的报错信息添加依赖的 DLL 即可\n\n\n如果你的项目是 IL2CPP 项目怎么办呢 ? 不用担心, 使用 HybridCLR 插件后, 执行 HybridCLR/Generate/All 菜单, 生成后, 在 HybridCLRData/AssembliesPostIl2CppStrip 文件夹中可以找到全部的 DLL 文件, 将这些文件拷贝到一个特定的目录, 让 SDK 解决方案中的每一个项目都去引用他们即可, 需要注意, 千万不要一股脑全选引用, 因为很多是重复引用, 是不能添加的, 按照你项目自己的报错信息添加依赖的 DLL 即可, 当然你也可以暂时切换回 Mono 模式打包获取 DLL 后再切换回来\n\n在项目的 依赖项 上右键, 选择 &quot;添加项目引用&quot;\n\n点击右下角的 &quot;浏览&quot; 添加对应的引用即可\n\n解决项目间的依赖问题这个就更简单了, 同样是在项目的 依赖项 上右键, 选择 &quot;添加项目引用&quot;, 不过在打开的页面中选择解决方案, 直接在列出的已有项目中选择依赖的项目即可\n\n注: 因为逐个项目修改引用很慢, 如果知道怎么修改 .csproj 文件, 你可以直接编辑 .csproj 文件, 实现以超快速度设定完成项目引用!\n设定语言版本至此应该会是会有很多报错, 比如使用了高版本的语言特性, 所以我们需要设定一下编译时的语言版本, 由于语言版本无法在 &quot;属性&quot; 中修改, 所以需要直接编辑 csproj 文件, 双击项目就可以打开 csproj 文件了, 在 PropertyGroup 标签内添加一行, 注意, 每一个项目的 csproj 文件都要修改!\n&lt;LangVersion&gt;latest&lt;/LangVersion&gt;\n\n设定生成声明式程序集默认情况下类库项目仅生成完整的 DLL. 如果要生成声明式程序集 DLL 需要编辑 csproj 文件, 在 PropertyGroup 标签内添加一行, 注意, 每一个项目的 csproj 文件都要修改!\n&lt;ProduceReferenceAssembly&gt;true&lt;/ProduceReferenceAssembly&gt;\n\n设定生成声明式程序集的输出目录默认情况下声明式程序集 DLL 会生成到各自项目的 obj 文件夹中, 为了方便拷贝, 可以统一生成到一个目录下, 要修改输出目录首先要启用自定义输出目录, 之后配置输出目录, 同样是编辑 csproj 文件, 在 PropertyGroup 标签内添加两行, 注意, 每一个项目的 csproj 文件都要修改!\n&lt;BaseOutputPath&gt;..\\..\\SwordRequiemDLL&lt;/BaseOutputPath&gt;&lt;ProduceReferenceAssemblyInOutDir&gt;true&lt;/ProduceReferenceAssemblyInOutDir&gt;\n\n到目前为止, csproj 文件的 PropertyGroup 标签大概是这样:\n&lt;PropertyGroup&gt;\t&lt;TargetFramework&gt;netstandard2.1&lt;/TargetFramework&gt;\t&lt;Nullable&gt;enable&lt;/Nullable&gt;\t&lt;LangVersion&gt;latest&lt;/LangVersion&gt;\t&lt;BaseOutputPath&gt;..\\..\\SwordRequiemDLL&lt;/BaseOutputPath&gt;\t&lt;ProduceReferenceAssembly&gt;true&lt;/ProduceReferenceAssembly&gt;\t&lt;ProduceReferenceAssemblyInOutDir&gt;true&lt;/ProduceReferenceAssemblyInOutDir&gt;&lt;/PropertyGroup&gt;\n\n补充编译宏虽然已经添加了绝大多数设置和引用了, 但是到这里的时候, 项目应该还是报错的, 无法生成\n这是因为 Unity 中我们一般是多平台开发的, 里面有很多宏控制, 区分不同平台\n尤其是接入了 Steam 时, 还有 Steam 的宏控制, 因此需要设定一下宏, 那这里的宏究竟要添加哪些呢 ?\n这个是按照自己的项目来的, 前面不是打包了一次吗 ? 为了生成 DLL 的时候, 就使用那个项目那时的宏状态, 打包的时候用了什么宏, 这里就要写入什么宏\n项目处右键, 打开属性, 找到 条件编译符号 添加对应的宏即可\n\n最后点击 生成/重新生成解决方案 即可生成声明式 DLL, 可以在输出目录的 ref 文件夹中找到\n\n这些 DLL 就可以发给模组作者了\n前面不是让你把需要引用的 DLL 全部单独放到一个文件夹里面嘛, 这里最好是连前面引用的文件夹中的 DLL 一起发给模组作者, 这样我们游戏的 SDK 环境就完整了!\n这样模组作者就可以通过新建类库项目, 引用我们给的 DLL 文件, 就可以编写代码了!\n⚡为什么要和 Unity 中的程序集划分保持一致 ?以我自己的项目为例, 我在 Unity 项目中划分了 7 个程序集: \n\nARModule\nKuroha.PNG\nKuroha.GIF\nKuroha.KConsole.Runtime\nKuroha.UI.Runtime\nKuroha.Utility.Runtime\nSwordRequiem.Runtime\n\n现在, 我的 SDK 项目 (用于为 Mod 作者生成声明式程序集的项目) 中只划分了一个程序集: SwordRequiem.SDK\n我生成声明式程序集, 得到一个 SwordRequiem.SDK.dll 并将它发给 Mod 作者, Mod 作者在这个环境中编写逻辑, 编译得到 mod.dll\n其中 mod.dll 依赖于 SwordRequiem.SDK.dll\n然而, 当游戏尝试在运行时加载这个 mod.dll 时, 会直接报错: 无法找到名为 SwordRequiem.SDK 的程序集 提示缺失引用！\n尝试解决下 ?我们可以设想, 是否可以把 SwordRequiem.SDK.dll 一并保留, 运行时在加载 mod.dll 之前, 先手动加载这个 SDK DLL ?\n理论上可以, 但实际上不行 -- 这就是声明式程序集的局限: \n\n声明式程序集中只包含类型的声明, 而不包含任何逻辑实现也就是说它只适用于编译期引用, 而在运行时根本无法被加载\n\n当你尝试在运行时使用 Assembly.LoadFrom(&quot;SwordRequiem.SDK.dll&quot;) 加载它时, CLR 会直接报错, 提示这是一个非法程序集, 通常为 BadImageFormatException\n那怎么办 ?我们再来看看 CLR 如何判断程序集引用: \n程序集的识别是基于 Assembly Identity 它包含以下字段: \n\nName ✅\nVersion\nCulture\nPublicKeyToken\n\n虽然完整规则包含版本、公钥等, 但大多数 Unity 项目未启用这些, 主要就是靠 Name 匹配程序集\n✅ 正解: 保持程序集划分一致\n如果你让声明式 SDK 的输出程序集与 Unity 的原始程序集保持一致, 那就不会有这个问题了, Mod 编译时依赖的是 SwordRequiem.Runtime 游戏运行时自然已经加载了真实的 SwordRequiem.Runtime.dll, CLR 会将 mod 中的类型引用绑定到原始实现, 无需再手动加载 SDK DLL, 如此一来, mod.dll 就可以毫无障碍地被加载与运行了\n✅ 小结\nMod 编译时依赖的程序集名称必须和游戏运行时实际加载的程序集完全一致\n因此, 声明式程序集必须划分为多个与 Unity 原始项目一致的模块, 不能统一为一个 SwordRequiem.SDK, 否则就会造成运行时绑定失败\n","categories":["Mod"],"tags":["Mod"]},{"title":"Unity 在脚本中修改 UGUI 中 UI 的位置和尺寸","url":"/unity/unity_rect_transform.html","content":"\n\n🌴 前言在制作魔剑镇魂曲的对话框系统时, 在对话框的后面要显示当前人物的立绘图片, 这里的立绘图片我用的是 UGUI 里面的 Image 组件, 使用的位置组件就不再是 Transform, 而是继承自它的 RectTransform 组件, 但怎么用呢?\n🌾 RectTransform强烈推荐一篇博客: Unity进阶技巧 - RectTransform详解 看完这篇博客, RectTransform 组件就基本明白了, 这里不再赘述.\n🦄 脚本控制 RectTransform在 Inspector 面板中我们关注的数值:\n\n\n\n数值名\n备注\n\n\n\nTop\n顶部距离\n\n\nBottom\n底部距离\n\n\nLeft\n左侧距离\n\n\nRight\n右侧距离\n\n\nPosX\n位置坐标 X\n\n\nPosY\n位置坐标 Y\n\n\nWidth\n宽度\n\n\nHeight\n高度\n\n\n在脚本中, RectTransform 下可以获取的属性值, 同时我也列出了这些值和 Inspector 面板中数值的关系.\n\n\n\n名称\n类型\n备注\n\n\n\nanchoredPosition\nVector2 : (anchoredPosition.x, anchoredPosition.y)\n(PosX, PosY)\n\n\nanchorMin\nVector2 : (anchorMin.x, anchorMin.y)\n\n\n\nanchorMax\nVector2 : (anchorMax.x, anchorMax.y)\n\n\n\noffsetMin\nVector2 : (offsetMin.x, offsetMin.y)\n(Left, Bottom)\n\n\noffsetMax\nVector2 : (offsetMax.x, offsetMax.y)\n(-Right, -Top)\n\n\nsizeDelta\nVector2 : (sizeDelta.x, sizeDelta.y)\n(Width, Height)\n\n\npivot\nVector2 : (pivot.x, pivot.y)\n\n\n\n在脚本中如何修改数值. 下面的代码中, 如果需要某个值不变, 直接赋予原值即可.\nRight 和 Topfloat customTopValue = 1.0f;float customRightValue = 1.0f;GetComponent&lt;RectTransform&gt;().offsetMax = new Vector2(-customRightValue, -customTopValue);\n\nLeft 和 Bottomfloat customBottomValue = 2.0f;float customLeftValue = 2.0f;GetComponent&lt;RectTransform&gt;().offsetMin = new Vector2(customLeftValue, customBottomValue);\n\nPosX 和 PosYfloat customPosXValue = 3.0f;float customPosYValue = 3.0f;GetComponent&lt;RectTransform&gt;().anchoredPosition = new Vector2(customPosXValue, customPosYValue);\n\nWidth 和 Heightfloat customWidthValue = 4.0f;float customHeightValue = 4.0f;GetComponent&lt;RectTransform&gt;().sizeDelta = new Vector2(customWidthValue, customHeightValue);\n\n🐬 属性之间的关系anchoredPosition 和 pivot, offsetMin, offsetMaxanchoredPosition = ((Vector2.one - pivot) * offsetMin) + (pivot * offsetMax);\n\nsizeDelta 和 offsetMin, offsetMaxsizeDelta = offsetMax - offsetMin;\n\n总结图\n参考文章\nUnity进阶技巧 - RectTransform详解\n\n修改RectTransform的值\n\n\n","categories":["Unity"],"tags":["Unity","UGUI"]},{"title":"如何让 Unity 走代理?","url":"/unity/unity_proxy.html","content":"\n\n最近在学习制作 Unity 游戏, 到了最后需要发布 Android 版本游戏程序的时候, 发现根本导不出来!!!\n每次都会卡在 Gradle 的构建上... 看了日志之后知道了原来是从仓库下载包的时候下载失败了...那我就更郁闷了, 我 24 小时全天开着梯子, 你跟我说现在还有我下载不下来的东西? 后来在这篇文章中找到了答案! 解决Unity的网络水土不服问题\n原来 Unity 压根不吃梯子啊~ ~ !\n解决方法一使用阿里的镜像源替代 Google 源\n\n找到 Unity 的安装目录.\n\n使用 VSCode 打开路径: Editor\\Data\\PlaybackEngines\\AndroidPlayer\\Tools\\GradleTemplates.\n\n对路径中的文件逐一修改, 将其中所有的\n\n\ngoogle()jcenter()\n\n修改为:\nmaven &#123;    url &quot;https://maven.aliyun.com/repository/google&quot;&#125;maven &#123;    url &quot;https://maven.aliyun.com/repository/jcenter&quot;&#125;\n\n\n重启 Unity 项目, 重新发布即可!\n\n[注]\n\n文件中要替换的 google() jcenter() 不止一处, 必须全部替换!\n\nUnity 每次打开项目的时候, 都会从模板中复制文件, 在项目中建立缓存, 其中就包含我们刚刚修改的文件. 如果不重启项目, 那么项目中的缓存文件依旧使用的是修改前的文件, 此时发布依旧会失败, 所以必须重启 Unity 项目, 让 Unity 使用我们修改后的模板重新建立缓存!\n\n\n解决方法二为 Unity Hub 和 Unity 设置代理\nUnity Hub 和 Unity 在连接网络时并不会读取浏览器配置, 因此梯子时无效的! 但是 Unity Hub 和 Unity 会读取环境变量中 HTTP_PROXY 和 HTTPS_PROXY 的值判断是否使用代理.\n因此只要配置好这两个环境变量就好了.\nHTTP_PROXY = http://127.0.0.1:1080HTTPS_PROXY = http://127.0.0.1:1080\n\n结语我最终采用的是第一种方法, 虽然设置麻烦了一点, 但是没有副作用.\n第二种也用过, 也是可以实现的, 但是有副作用, 会导致其他的软件可能无法正常联网, 比如我的饥荒. (未完全证实) 不过我也确实不喜欢改动环境变量! 😂\n参考链接\n解决Unity的网络水土不服问题\n\nUnity使用Gradle打包出错问题\n\n\n","categories":["Unity"],"tags":["Unity"]},{"title":"关于 Unity 中引用查询的研究","url":"/unity/unity_reference.html","content":"\n\n博主目前所知道的 Unity 引用查询的方式有两种:\n\n将 Unity 的序列化模式设置为 Force Text, 通过文本比对的方式查询引用情况\n通过收集复合资源的依赖情况反向转换为引用情况, 直接进行查询\n\n文本方式这种查询方式可以自己实现也可以借助工具实现\n手动实现这里就以最简单的方式举例 (只说明思路)\n\n先收集全部的复合资源\n var guids = AssetDatabase.FindAssets(&quot;t:Prefab t:Material t:Scriptableobject t:Scene t:AnimatorController t:Textasset&quot;, new string[] &#123;&quot;Assets&quot;&#125;);\n\n依次加载全部文本\n rawData.text = File.ReadAllText(assetFullPath);\n\n获得要查询资源的 GUID\n guidRules = Selection.assetGUIDs\n\n依次进行比对\n foreach (var guidRule in guidRules)&#123;    if (Regex.IsMatch(rawData.text, guidRule))    &#123;        results.Add(guidRule, rawData.fullPath);    &#125;&#125;\n\n最后汇总结果就可以了, 其中关键的点在于要使用多线程来加快读取 text 以及遍历查询的速度, 否则效率将会非常低\n【总结】\n在较大的项目中, 初始化需要 33s 时间, 而且每次初始化的时间差异很大, 有时会长达 60s 以上\n\n查询 1 个文件的耗时 0.7s\n\n但是随着文件增多, 需要的查询时间也会随之上升, 查询 10 个文件时需要 6s\n\n查询 20 个文件时需要 16s\n\n【适用情况】\n\n由于每次修改 C# 代码都会导致缓存清空, 因此适用于关卡, 美术和优化等基本不会修改代码的人员\n\n制作缓存时, 基本都会使用 OnPostprocesser 这个方法, 从而会加长资源导入的时间, 如果项目中有大量的此方法, 便会导致资源导入非常缓慢\n\n由于查询数增多时, 时间消耗也会大幅度增加, 因此只适用于人工查询, 不适合批量查询\n\n\n使用 Ripgrep 软件使用 Ripgrep 软件的查询功能实现引用查询\nRipgrep 是命令行下一个基于行的搜索工具, 使用 Rust 开发, 可以在多平台下运行, RipGrep 官方号称比其它类似工具在搜索速度上快上 N 倍, VSCode 的搜索功能默认就是用的 Ripgrep\n\n使用 VSCode 执行搜索时在任务管理器中就可以看到\n\n软件下载地址: Ripgrep 开源地址\n将软件导入到 Unity 中, 编写代码使用 Process 类, 设置好参数, 启动软件查询即可\n推荐将参数写为可配置的方式, 这样使用过程中需要调整参数时可以直接外部调整\n\n另外 .exe 程序和 .ignore 文件都可以直接放到项目中\n\n在较大的项目中, 每次查询需要消耗 6 ~ 10s\n\n【适用情况】\n\n没有了初始化操作带来的时间消耗, 单次查询的时间大幅度缩短, 适用于程序等经常修改代码的人员\n\n由于无法做缓存, 因此也只适用于人工查询, 不适用于批量查询\n\n由于没有使用 OnPostprocesser 方法, 也带来一个好处, 不会对资源导入速度造成任何影响\n\n\n逆向依赖方式Unity 目前提供了 AssetDatabase.GetDependencies() 和 EditorUtility.CollectDependencies() 两个方法收集复合类资源的依赖, 通过将依赖关系转化为引用关系, 便可以实现引用情况的查询 (编辑器中可以直接: 资源右键 &#x3D;&gt; Select Dependencies)\n【注】由于使用了 Unity 内部的引用关系来做查询, 直接通过代码调用资源接口进行加载的资源将无法被统计\n先说一下两个接口的差异\n\nAssetDatabase.GetDependencies() 收集的依赖包含无效引用\nEditorUtility.CollectDependencies() 收集的依赖不包含无效引用\n\n无效引用指的就是 Unity 为了方便开发者而做的一些引用缓存; 以材质球为例, 在切换 Shader 的时候, Unity 并不会将之前 Shader 的相关序列化信息删除, 旧的纹理引用依旧会序列化保存下来\n更详细的差异可以看这里: 详细差异\n下面说一下实现思路:\n\n得到全部的复合资源\n\nvar sprites = AssetDatabase.FindAssets(&quot;t:SpriteAtlas&quot;);var materials = AssetDatabase.FindAssets(&quot;t:Material&quot;);var prefabs = AssetDatabase.FindAssets(&quot;t:Prefab&quot;);var sos = AssetDatabase.FindAssets(&quot;t:ScriptableObject&quot;);var models = AssetDatabase.FindAssets(&quot;t:Model&quot;);var cons = AssetDatabase.FindAssets(&quot;t:AnimatorController&quot;);var scenes = AssetDatabase.FindAssets(&quot;t:Scene&quot;);var animas = AssetDatabase.FindAssets(&quot;t:Animation&quot;);\n\n\n获取全部依赖\n\n使用 AssetDatabase.GetDependencies(), 因为其可以直接传递路径, 另一个方法需要传递物体, 多一个加载过程的耗时\nforeach (var key in typeFilter.Keys)&#123;    foreach (var guid in typeFilter[key])    &#123;        if (dependencies.ContainsKey(guid))        &#123;            // DebugUtil.LogError($&quot;存在相同的 GUID : &#123;guid&#125;&quot;, DebugUtil.红);        &#125;        else        &#123;            dependencies.Add(guid, AssetDatabase.GetDependencies(AssetDatabase.GUIDToAssetPath(guid), false));        &#125;    &#125;&#125;\n\n\n将依赖关系转换为引用关系, 有了引用关系的字典就可以直接查询了\n\nforeach (var guid in dependencies.Keys)&#123;    foreach (var dependPath in dependencies[guid])    &#123;        var dependGuid = AssetDatabase.AssetPathToGUID(dependPath);        if (!assetData.referencedAssets.TryGetValue(dependGuid, out _))        &#123;            assetData.referencedAssets[dependGuid] = new List&lt;string&gt;();        &#125;        assetData.referencedAssets[dependGuid].Add(guid);    &#125;&#125;\n\n这个方法的耗时主要在构建依赖关系上, 经测试每次构建需要耗时 70s 以上\n\n而将依赖关系转换为引用关系仅花费了 1s 左右\n\n查询耗时连 1ms 都不到\n\n【适用情况】\n\n因为每次构建字典的时间过长, 不适合经常使用, 多适用于批量查询, 全局查询\n\n也可以将字典做成缓存, 使用 OnPostprocesser 来做, 虽然会对资源导入速度有影响, 但是就不必每次都进行字典的构建, 借助字典的查询友好, 可快速查询引用, 资源商店中的 FR2 便是使用了这个思路\n\n\n总结\n\n\n思路\n方案\n初始化耗时\n单次查询耗时\n多次查询耗时\n是否适合批量查询\n\n\n\n文本比对\n手动实现逻辑\n33s ~ 2 min (耗时不稳定)\n0.7s\n高于线性\n不适合\n\n\n文本比对\nRipgrep\n无\n6 ~ 10s\n线性\n不适合\n\n\n逆向依赖\n逆向依赖\n72s 左右 (耗时稳定)\n~0ms [字典: O(1)]\n线性\n适合\n\n\n","categories":["Unity"],"tags":["Unity","Reference"]},{"title":"Unity - 2D 精灵 和 3D 物体的渲染顺序","url":"/unity/unity_render_order.html","content":"\n\n问题:我在学习 SiKi 学院出的一款捕鱼达人的游戏教程时, 教程中使用了一个 3D 物体, 在其上面制作水波纹特效, 为了容易观察渲染层级, 我还特意将同一个层级 (Sorting Layer) 的精灵全部放到同一个 Z 位置上, 一共分了四层.\n\n但是从相机预览效果中可以看出, 水波纹效果被遮挡了. 在这个场景中所有的 Canvas 的渲染层级都是一个自定义的 UI 层, 但是这个 3D 游戏物体的层级该怎么设置呢? 根本找不到设置的地方啊? 😥\nMeshRenderer 与 SpriteRenderer 的渲染顺序3D 游戏物体使用的是 MeshRenderer, 2D 精灵使用的是 SpriteRenderer, 两者都是继承自 Renderer, 在 Renderer 中渲染层级是 sortingLayerName 字段, 渲染顺序是 sortingOrder 字段.\n\nSpriteRenderer 中的 Sorting Layer 对应的是 sortingLayerName 字段, Order in Layer 对应的是 sortingOrder 字段.\n\n在 MeshrRenderer 中这两个字段并没有做处理, 只是在面板上隐藏了而已, 因此可以在脚本中直接使用.\n public int orderinLayer = 15;public string sortingLayer = &quot;UI&quot;;private MeshRenderer meshRenderer;private void Awake()&#123;    meshRenderer = GetComponent&lt;MeshRenderer&gt;();&#125;private void Start()&#123;    //设定 3D 游戏物体的渲染层级    meshRenderer.sortingLayerName = sortingLayer;    meshRenderer.sortingOrder = orderinLayer;&#125;\n\n在 ParticleSystem 中同样也有 Renderer 组件控制粒子特效的渲染顺序, 同样可以使用脚本控制, 也可以直接在面板上设置.\n public int orderinLayer = 15;public string sortingLayer = &quot;UI&quot;;public ParticleSystem[] particleSystems;private void Start()&#123;    //设定粒子特效的渲染层级    for (int index = 0; index &lt; particleSystems.Length; index++)    &#123;        rendererParticle = particleSystems[index].GetComponent&lt;Renderer&gt;();        rendererParticle.sortingLayerName = sortingLayer;        rendererParticle.sortingOrder = orderinLayer;    &#125;&#125;\n\n问题解决后效果使用上面脚本中的设置就可以让 MeshRenderer 也参与到 2D UI 的排序中来了, 效果还是不错的.\n\n参考资料SpriteRenderer 与 MeshRenderer的渲染排序层级\n","categories":["Unity"],"tags":["Unity"]},{"title":"面向新手的 TextMeshPro 使用说明","url":"/unity/unity_textmeshpro.html","content":"\n\nTextMeshPro 和 Text 效果上的不同\n\n\n对比维度\nTextMeshPro\nText\n\n\n\n文本显示效果\n高分辨率渲染，支持子像素定位，文本清晰锐利\n简单渲染，缩放时模糊、失真\n\n\n富文本支持\n支持复杂标签和自定义样式，功能丰富\n支持简单的富文本功能\n\n\n字体支持\n动态字体生成，自定义字体图集，支持多语言和复杂脚本\n静态字体支持，语言兼容性有限\n\n\n高级排版功能\n自动换行、字符间距、行间距、对齐方式等细节排版功能强大\n仅支持简单的排版设置\n\n\n特效支持\n内置渐变、描边、阴影等丰富特效\n需要手动实现特效，能力有限\n\n\n性能\n高效处理动态文本，支持材质合并优化渲染开销\n性能较低，处理大量动态文本时容易卡顿\n\n\nAPI 功能\n丰富的 API，支持复杂样式控制和动态生成\nAPI 功能少，只能满足简单文本操作\n\n\n兼容性\n需要额外的字体资源和材质设置，初次学习可能稍复杂\n内置 Unity 功能，使用简单\n\n\n多语言支持\n支持阿拉伯语、中文、日文等复杂文字布局\n对多语言支持有限，需手动调整\n\n\n适用场景\n高质量文本显示，大型项目，UI 动态文本\n简单文本显示，小型项目，低复杂度 UI\n\n\nTextMeshPro 和 Text 使用上的不同最大的使用差别就一个, TMP 有字体库的概念. Text 组件直接引用字体文件, 而 TMP 则是引用以字体文件为基础制作而成的 TMP_Font Asset 资源.\n如何生成 TMP_Font Asset 呢 ?打开 Font Asset Creator 窗口, 放入字体文件, 选择会用到的字符集, 点击 Generate 即可生成. 如下图所示.\n\n生成 TMP_Font Asset 的时候为什么 &quot;慢&quot;, 而且是 &quot;巨慢&quot; ?提问 : 为什么我生成的时候很慢很慢呢? 一次要 30 分钟甚至几小时!\n回答 : 影响生成字符集时长的原因主要有 2 个\n\n字符的数量\n\n比如使用了常用汉字集这种几千字的集合, 大概需要几十秒, 下面是我电脑的数据: 4205 字, 可以看到, 生成时间耗费了 22 秒.\n\n\nPoint Size 和 Padding 的设置\n\n当要生成几千字的字体资源时, Point Size 和 Padding 不要设置为 Auto, 字符数量少时可以使用来快速找到合适的数值.\n这个是让工具自动去调整 Point 以及 Padding 的大小, 这样工具会不断试错, 尝试一个值, 不行, 换下一个, 不行, 再换下一次, 还是不行, 再换 ... 如此往复 ... 因此 &quot;慢&quot; 是因为它生成了数次.\n只要固定 Point 和 Padding 的大小, 它就会仅生成一次, 消耗的时间就很少了.\n推荐一个常用的汉字集 : 跳转到 Github 汉字集\n那么 Size 和 Padding 该设置多大呢 ?先放一下 TextMeshPro 的官方手册 : TMP 4.0 手册\n手册中是这样写的, 对于 512 的图集, padding 为 5 就够用了.\n\nA padding of 5 is often fine for a 512x512 texture.\n\n那么其他的分辨率下该设置多少呢? 你自己看着办 ... (多去尝试) 当然也可以参考我上面截图中的, 我是 8192 * 4096 的图集, 用的是 12, 感觉还好, 即使是 &quot;加粗+描边&quot; 效果下也很平滑, 至少肉眼看不出啥瑕疵来.\nPadding 主要控制的就是字体显示效果, 原文是这么写的:\n\nThe larger the padding, the smoother the transition, which allows for higher-quality rendering and larger effects, like thick outlines.\n\n意思就是这个值越大, 字体越平滑, 就越能支持更高质量的渲染和效果, 比如厚厚的描边.\n至于 Point Size 嘛 ... 参考我的截图吧, 我的游戏中有时候会用到 50 号甚至 60 号的文字, 感觉 Point Size 设置为 72 已经挺极限了, 再小的话显示就出问题了.\n画面缩小后文字有 &quot;白底&quot; ?这个其实是 SP&#x2F;PD Ratio 值过小导致的. SP&#x2F;PD Ratio 数值就是 padding 和 point size 的比值, 用来描述各个字符之间空隙的大小, 空隙太小时便会出现白底的问题, 但是太大也不好, 浪费空间嘛.\n网上的说法是, 推荐最大 10%, 最小 4%, 但是我实测发现基本低于 10% 就会出现白底了, 所以我推荐的值为 12% 左右, 太小出现白底, 太大浪费空间, 自己通过手调 Point Size 和 Padding 来调整吧.\n这是别人的研究, 我也不确定文章会不会哪天就看不了了, 智障的 CSDN 会员! 且看且珍惜吧, 也不长, 主要意思就一个: SP&#x2F;PD Ratio 值过小过导致白底, 我都总结了. 它的文章里面就是写了原因的推测, 也只是推测, 这里是原文: 文字白底问题探讨\n玩家文本输入框怎么做呢 ? 因为我不可能提前预知玩家输入哪些字符呀 ?是的, 我们确实无法预知, 所以这里就要用到之前从来没有提到的另一个概念了 : 动态字体.\n我们之前创建的字体资源都是静态字体, 顾名思义, 静态字体的意思就是打包哪些字符就支持显示哪些字符, 没有打包的就不支持, 这也是为什么很多人一开始用 TMP 显示不了中文字符的原因.\n而动态字体中, 初始是没有任何字符的, 它是现用现做, 因此性能上就会差一些, 但是好处也是毋庸置疑的, 它能支持字体文件中全部字符.\n怎么做一个动态字体呢 ?直接引用手册原文\n\nCreating a dynamic font AssetEmpty font assets are dynamic by default. To create one:\nFrom Unity&#39;s main menu, choose &quot;Assets &gt; Create &gt; TextMeshPro &gt; Font Asset&quot; or press Ctrl&#x2F;Cmd + Shift + F12.To make an existing font Asset dynamic:\nSelect Asset and open it in the Inspector.\nSet the Generation Settings &gt; Atlas Population Mode property to Dynamic.\n\n通过修改字体文件的材质属性实现了一个效果, 但是要实现另一个效果怎么办 ? 难道要再创建一份字体资源吗 ?不需要再创建一份字体资源, 否则人都麻了... 只需要创建一份 Material Preset 即可, 如图操作\n\n选中字体资源下的材质球, 仅选中即可, 然后点击 Inspector 面板上材质球的小菜单, 竖着的三个小点, 记得是材质球的菜单, 不是上面那个三个小点的菜单, 有两个, 千万别混了. 最后点击菜单中的 &quot;Create Material Preset&quot; 即可, 这样在 TextMeshPro 控件中的材质球选项处会自动多出选项供你选择.\n彩色 emoji 字符怎么支持 ? 表情包怎么支持 ? 有哪些可用的富文本标签 ? 渐变效果怎么支持 ?这些目前我也还没开始大规模使用, 就尝试使用了一下表情包和标签而已, 具体的请直接查阅文档, 文档巨详细.\ncolor emoji 支持 (字符表情)\n表情包支持 (图片表情)\n富文本标签支持\nStyle Sheet 支持\n颜色渐变效果支持\n总结 : 首个项目的 TextMeshPro 的一般使用姿势 (后面的项目可以直接复用)\n选择各个语种: 英文、日文、韩文、中文等要使用的字体, 可用即可, 后期再正式选择. 一般每种语种都要单独选择, 支持多个语种的字体一般除了主语种外的其他语种字符都不好看.\n\n对各个字体文件创建动态字体资源, 直接使用动态的, 因为具体要用到哪些字符还没有完全确定, 静态的也不好做.\n\n将动态字体中收集的字符进行分类: 英文、数字、符号、日文、韩文、中文、数学符号等等, 分别创建对应的 txt 文件.\n\n选择一个主字体, 比如中文, 然后将 ASCII、日文、韩文 作为 CallBack 设置. 如果字母和数字想使用不同的字体, 可以在步骤 3 那里详细进行拆分, 分别设置 CallBack, 比如英文用 A 数字字体, 中文用 B 数字字体等.\n\n记得 CallBack 的最后必须设置上一个多语种的动态字体, 推荐开源的阿里巴巴普惠体3.0, 尤其是需要玩家输入昵称或者显示外部文本的地方, 更是必须使用动态字体 : 阿里巴巴普惠体3.0\n\n无穷, 无限, 积分等数学符号可以使用支持数学符号的字体解决 : 数学字符字体\n\n\n","categories":["Unity"],"tags":["Unity"]},{"title":"Unity 网络框架学习","url":"/unity/unity_spacetimedb.html","content":"\n\n👀 框架的选择在这次开发之前, 我先去大概浏览了目前比较常用的网络框架, 像是:\nUNet Mirror Netcode for GameObjects Netcode for Entities FishNet\n以及 Photon 系列:\nPUN (Photon Unity Networking), Photon Fushion, Photon Realtime 等\n了解它们的设计理念以及使用方式, 同时也分析了自己项目的需求, 我的游戏项目是简单的卡牌对战, 不需要物理系统, 也没有运动同步, 因此对于实时性几乎没有要求, 而上述框架都是基于 Unity 做的, 或者和 Unity 深度绑定, 给我一种 Unity 专属网络框架的感觉\n同时我对代码编写也有要求, 底线是客户端必须和服务端分离, 如果服务端能直接脱离 Unity 则更好, 另一个底线则是服务端必须拥有绝对权威性, 如果框架直接能做到这点则更好, 即使框架做不到, 我也会自己编码实现\n在这两个底线的作用下, 我对于框架的选择就很纠结 ... 至少这些框架都或多或少不满足要求 ...\n纠结的时间中我在 GDC 演讲中发现了一个新的框架, 叫做 SpacetimeDB, 准确来说不是网络框架, 而是一个专门为多人游戏设计的网络数据库, 但是它满足我的需求\n🤩 STDB 的特点因为我几乎没有使用服务端框架的经验, 仅仅是用 UNet 做了一个 FPS demo 的程度, 所以也别指望我会去对比上述框架, 我可没那个能力, 我就说下近期使用 STDB 的经验, 说下 STDB 的特点\n第一 : 客户端和服务端的彻底分离使用 STDB 进行开发的话, 服务端和客户端是完全分离的, 不仅仅是代码分离, 而是两个端压根不是一个项目\nSTDB 的服务端是一个 C# 项目, 当然你也可以选择别的语言, 这就意味着如果你是 Unity 开发者, 你的服务端将无法使用 Unity 的任何功能, 碰撞系统, 运动系统, 甚至 Update 生命周期都无法使用, 因为服务端是一个纯粹的 C# 项目\nSTDB 的客户端就随意了, 在我这里肯定就是 Unity 项目了, STDB 对 Unity 开发者挺友好的, 做了很多对 Unity 的支持, 包括两端数据模型的同步, Unity 插件支持等\n第二 : Table + Reducer服务端的编程模型是 Table + Reducer\nTable 是数据, 可以简单理解为类似字典的一种结构, 如果你有数据库相关知识, 那这玩意儿就是数据库中的表, 一模一样的\nSTDB 提供了 Insert Delete Update 方法对数据进行处理\n数据都是以 行 为单位来处理的: 插入一行, 删除一行, 修改一行\nReducer 则是逻辑, 那它和普通的逻辑有什么区别呢 ? 为什么非要额外定义一个 Reducer 呢 ? 这点就是我选择 STDB 的理由之一, Reducer 中对数据库所做的操作必定会全部生效或者全部失效, 绝对不会存在仅生效了一部分的情况\n举个例子: 喝回血药剂, 执行此逻辑的方法内必然分为至少两个步骤, 一个步骤是玩家血量的修改, 另一个则是药剂库存的修改, 如果其中一个操作失败了, 另一个操作是不会自动回滚的, 你得自己编写逻辑来回滚数据: 如果回血失败了, 药剂也不能扣除, 得找回来, 或者药剂扣除失败了, 那前面回复的血量也得扣回去, 而 Reducer 就原生保证了这一点, 要么全部生效, 要么全部失效\n第三 : 绝对的服务器权威服务端全部的 Table 只能通过 Reducer 修改, 服务端不接受客户端的任何直接传值, 或者直接修改, 客户端是纯被动的, 一切状态, 一切数据都是服务端下发的\n特点这种东西都是自己用了一段时间后的感受, 我这里说再多, 没用过的人也是感受不到的, 所以接下里直接开始讲解 STDB 的使用\n🐬 Server : 安装 SpacetimeDB以数据库 MySQL 为类比, 这一步就是在安装 MySQL 软件, 直接在任意 shell 中执行下面的命令即可安装\niwr https://windows.spacetimedb.com -useb | iex\n如果你不想上面那样云里雾里地被安装, 也可以手动安装, 这是 STDB 的 Github 地址, 单击即可跳转\nhttps://github.com/clockworklabs/SpacetimeDB\n打开页面后, 转到 Release 页面, 可以看到下载列表\n\nSTDB 分为两部分, 一部分是命令行程序, 用于命令行支持, 另一部分则是真正的 STDB 软件\n\n首先下载命令行程序 spacetimedb-update-x86_64-pc-windows-msvc.exe \n下载后重命名为 spacetime.exe\n将重命名后的 spacetime.exe 放置到自己的工具目录中, 配置好环境变量\n\n环境变量配置到文件夹即可, 不需要配置到具体的程序\n比如我放在了 E:\\Tool\\Spacetime\\spacetime.exe 中, 环境变量则配置 E:\\Tool\\Spacetime 即可\n完成上面的步骤就可以直接在命令行中使用 spacetime 命令了, 如下图, 我直接输入 spacetime\n\n可以看到命令可以正常识别到, 但是有报错, 提示没有在下面的目录中找到对应的程序, 所以我们继续操作\nC:\\Users\\Administrator\\AppData\\Local\\SpacetimeDB\\bin\\current\\spacetimedb-cli.exe\n\n首先按照提示, 新建文件夹, 找到 C:\\Users\\Administrator\\AppData\\Local\n在里面新建 SpacetimeDB, 再新建 bin, 最后是新建 current\n这次下载 STDB 程序 spacetime-x86_64-pc-windows-msvc.zip\n下载后的压缩包解压后可以看到两个 exe 程序, 将这两个 exe 剪切到之前新建的 current 目录中\n\n做完上述步骤后会这样\n\n此时再去执行 spacetime 命令就不会报错了, 比如执行 spacetime --version 命令可以查看版本号\n\n注意 : 你可能会觉得 spacetime 只能放在 C 盘用户的 Local 目录下很蠢, 但是 ... 这个嘛, 我也只能说确实很蠢, 但我也没找到解决办法 (当然也不是完全不能解决), 只能先这样了\n如果你了解 Windows 的软链接功能, 可以将 current 文件夹链接到自定义目录, 这样就可以实现将 spacetime 放置到自己的目录了\n总结一下就是: 下载命令行程序, 为其配置环境变量, 下载执行程序, 将其放到指定目录, 结束!\n\n🎄 Server : 启动 SpacetimeDB默认情况下, 启动 STDB 只需要在命令行中输入 spacetime start 即可\n但是这样启动后, 数据库的数据将会被保存到 Local 文件夹中, 如果你希望自己定义数据库文件的位置, 可以参考下面的命令\nspacetime start --listen-addr 0.0.0.0:3000 --data-dir F:\\U-BlackHole\\Data\n这样启动就是让 STDB 监听 3000 端口, 并将数据库文件放到 F:\\U-BlackHole\\Data 中\n\n关于 Server 配置 cli.toml 后面再讲, 现在无视即可\n🍉 Server : 初始化服务端项目进入到项目目录中, 务必先进入到项目目录中\n之后执行命令 spacetime init --lang csharp Server\n该命令会自动在当前目录下新建 Server 文件夹作为服务端, 并使用 C# 语言初始化此服务端项目\n此时使用 Rider 或者 VS 等打开服务端项目应该是报错的, 因为环境还没有准备好\n我的建议是进入 Server 文件夹内, 打开终端\n运行 spacetime publish -s local black-hole 命令, 关于命令的含义请查阅文章最后的额外参考部分\n这句命令会尝试编译并发布服务器到配置名称为 local 的 Server 上, 且数据模型会被命名为 black-hole\n在编译过程中, 会自动检查环境配置, 需要安装的是 .net sdk 以及 wasi 工作负载\n.net sdk 可能需要手动安装, 而 wasi 则会自动安装相应的版本, 不需要担心\n当你成功发布数据模型后, 整个项目应该也就编译通过了, 至此, 服务端就可以开始编写代码了\n🦴 Server : C# 服务端的编码📦 表结构相关属性\n\n\n属性\n用法说明\n\n\n\n[SpacetimeDB.[Table()]]\n声明数据库表, Name 指定表名, Public 表示是否对客户端可见\n\n\n(Name &#x3D; &quot;tb_config&quot;, Public &#x3D; true)\n仅可用于 partial class 和 partial struct\n\n\n[SpacetimeDB.PrimaryKey]\n标记主键字段, 每个表只能有一个, 自动具备唯一性\n\n\n[SpacetimeDB.Unique]\n标记字段为唯一约束, 可用于一个或多个字段\n\n\n[SpacetimeDB.AutoInc]\n标记字段为自增字段, 支持自动递增的整数类型, 常与主键或唯一字段搭配使用\n\n\n[SpacetimeDB.Type]\n声明可用于键的自定义类型, 仅用于 partial struct, 在索引键等场景中需要使用\n\n\n\n🌲 索引相关属性\n\n\n属性\n用法说明\n\n\n\n[SpacetimeDB.Index.BTree()]\n创建 B-Tree 索引\n\n\n(Name &#x3D; &quot;索引名&quot;, Columns &#x3D; [字段1, 字段2...])\n支持单字段或多字段索引, 可自定义索引名称\n\n\n\n🔁 Reducer（数据库事务函数）\n\n\n属性\n用法说明\n\n\n\n[SpacetimeDB.Reducer]\n声明 Reducer, 用于服务端逻辑处理, 必须作用于静态方法, 且第一个参数为 ReducerContext\n\n\n[SpacetimeDB.Reducer(ReducerKind.Init)]\n当模块首次上线或数据库重置时自动调用, 用于准备初始数据\n\n\n[SpacetimeDB.Reducer(ReducerKind.ClientConnected)]\n当客户端连接数据库时自动调用, 用于初始化该用户状态\n\n\n[SpacetimeDB.Reducer(ReducerKind.ClientDisconnected)]\n当客户端断开连接时自动调用, 用于清理该用户状态或释放资源\n\n\n🦴 Server : 服务端编码注意事项\n服务端内的 .csproj 文件不能重命名, 必须使用 StdbModule.csproj (是不是很蠢 ? 是的, 巨蠢, 但没办法 ... 后续版本肯定会优化的吧, 肯定会吧? 肯定会吧!)\n全部的 Table 以及 Reducer 都必须在同一个 static partial class 类中, 所以可以看到服务端中全部的文件都用 public static partial class Module 包起来了\n默认数据库启动后会自动监听 0.0.0.0, 但客户端连接时可不能使用 0.0.0.0 作为地址, 因为 0.0.0.0 是一个特殊的非路由地址, 它表示的含义其实是 监听本机所有可用 IPv4 地址\n\n🌴 Client : SpacetimeDB 的使用首先需要导入插件包, 在 Unity Package 中添加 Git Package : https://github.com/clockworklabs/com.clockworklabs.spacetimedbsdk.git\n之后新建一个全局物体挂载上 SpacetimeDBNetworkManager\n仅此两步, 客户端配置完成, 可以开始编写客户端代码了!\n📚 额外参考STDB 中 Server 层概念的解释Server 层是为了开发方便而设计的一层概念, 对客户端而言是无感的\n设想一下, 我们目前操作的机器就是 spacetimedb 所在的机器, 我们可以使用 publish 命令直接发布数据模型\n但是如果我们现在操作的机器并不是 spacetimedb 所在的机器呢, 我们的 spacetimedb 运行在远端, 比如阿里的服务器上, 我们是不可能跑到阿里机库那里操作电脑的\n所以有了 Server 层的概念, 我们可以在\nC:\\Users\\Administrator\\AppData\\Local\\SpacetimeDB\\config\\cli.toml\n文件中配置上远端服务端的地址, 再起一个名字, 这样就可以直接用自己的电脑发布数据模型到远端的 spacetimedb 上了\n比如默认情况下, spacetimedb 都为我们提供了一个免费的远端, 叫做 maincloud, 你打开 cli.toml 就可以看到\n我们总不可能跑到人家公司机库的电脑上输入命令吧, 所以这里我们可以使用 spacetime publish -y -c -s maincloud black-hole 命令\n其中的 -s 就是选择 Server, 这样我们就可以将数据模型发布到 maincloud 上了\n客户端在连接 maincloud 时使用 https://maincloud.spacetimedb.com 或 wss://maincloud.spacetimedb.com 即可, 我这边测试过后完全没问题\n而且 spacetimedb 还有一个后台可以使用, 登录 spacetime 后, 点击头像, 点击 Your Profile, 点击数据模型列表中右侧的大眼睛即可进入后台\n\nSTDB 中关于命令行 SQL 的说明STDB 直接在命令行中输入 SQL 命令来查询服务端数据, 具体情况可以使用 spacetime sql -h 查询\nspacetime sql -s local black-hole &quot;SELECT * FROM tb_player_logged_out&quot;\n.net 8.0 sdk 下载地址https://dotnet.microsoft.com/en-us/download/dotnet/8.0\n可以在 shell 中执行 dotnet --list-sdks 来检查当前已经安装了哪些 .Net SDK\n安装 wasi 工作负载直接在 shell 中执行 dotnet workload install wasi-experimental 即可\n因为手动安装的版本不一定就是 STDB 需要的版本, 所以不建议手动安装工作负载\n&gt; Downloading Microsoft.NET.Runtime.WebAssembly.Wasi.Sdk.Msi.x64 (9.0.6)&gt; 正在安装 Microsoft.NET.Runtime.WebAssembly.Wasi.Sdk.Msi.x64 .... Done&gt; Downloading Microsoft.NETCore.App.Runtime.Mono.wasi-wasm.Msi.x64 (9.0.6)&gt; 正在安装 Microsoft.NETCore.App.Runtime.Mono.wasi-wasm.Msi.x64 ..... Done&gt; Downloading Microsoft.NET.Runtime.WebAssembly.Templates.net9.Msi.x64 (9.0.6)&gt; 正在安装 Microsoft.NET.Runtime.WebAssembly.Templates.net9.Msi.x64 ... Done&gt; Downloading Microsoft.NETCore.App.Runtime.AOT.win-x64.Cross.wasi-wasm.Msi.x64 (9.0.6)&gt; 正在安装 Microsoft.NETCore.App.Runtime.AOT.win-x64.Cross.wasi-wasm.Msi.x64 .... Done&gt; Downloading Microsoft.NET.Runtime.MonoAOTCompiler.Task.Msi.x64 (9.0.6)&gt; 正在安装 Microsoft.NET.Runtime.MonoAOTCompiler.Task.Msi.x64 .... Done&gt; Downloading Microsoft.NET.Runtime.MonoTargets.Sdk.Msi.x64 (9.0.6)&gt; 正在安装 Microsoft.NET.Runtime.MonoTargets.Sdk.Msi.x64 .... Done&gt; &gt; 已成功安装的工作负载 wasi-experimental。\n\nSTDB 命令行列表https://spacetimedb.com/docs/cli-reference\ngenerate 命令详解generate 命令的作用是将服务端的数据模型生成一份代码到客户端, 这样客户端便可以和服务端共享数据模型\nspacetime generate --lang &lt;LANG&gt; --out-dir &lt;DIR&gt; [--project-path &lt;DIR&gt; | --bin-path &lt;PATH&gt;]\n\n-l, --lang &lt;LANG&gt; : 指定生成代码的语言, 如 csharp, typescript, rust\n-o, --out-dir &lt;DIR&gt; : 生成的代码输出到哪个目录\n-p, --project-path &lt;DIR&gt; : 服务端模块的项目路径, 默认是当前目录\n-b, --bin-path &lt;PATH&gt; : 直接指定已编译的 wasm 文件路径\n-y, --yes : 尽量保持非交互性, 自动回答选项, 大部分是 yes, 有时是 no, 比如是否使用 spacetimedb.com 登录时\n--namespace &lt;NAMESPACE&gt; : 生成的代码所使用的命名空间, 默认是: SpacetimeDB.Types\n\n示例: spacetime generate -l csharp -o ../Client/Assets/Assets/Script/Game.Core/Module\npublish 命令解释publish 命令的作用是编译服务端, 并将新的服务端发布到 Spacetime 中, 如果不存在同名服务端, 会自动新建, 如果已存在同名服务端, 则会自动更新\n如果不知道当前有哪些数据模型已经发布了, 可以使用 list 命令查询: spacetime list\n如果你想知道具体是如何解决版本数据冲突的, 请参阅官方文档中有关自动迁移的说明: https://spacetimedb.com/docs/modules/c-sharp#automatic-migrations\nspacetime publish [OPTIONS] [name|identity]\n\n[name|identity] : 数据库名或身份标识 (只能使用数字和小写字母和横线, 不能使用其他所有符号, 比如大写字母, 比如下划线)\n-c, --delete-data : 若数据库已存在, 则先清空该数据库中所有数据再重新发布\n--build-options &lt;BUILD_OPTIONS&gt; : 传递给构建工具的额外选项\n-p, --project-path &lt;PROJECT_PATH&gt; : 指定项目路径, 默认当前路径\n-b, --bin-path &lt;WASM_FILE&gt; : 直接指定已构建完成的 wasm 文件\n--anonymous : 使用匿名身份执行发布, 不绑定任何已登录的账号\n-s, --server &lt;SERVER&gt; : 指定目标服务器地址\n-y, --yes : 跳过所有提示, 以非交互方式执行命令\n\n示例: spacetime publish -y -c -s local black-hole\nCould not find wasm-opt to optimise the module 怎么解决wasm-opt 是 Binaryen 项目提供的一个 WebAssembly 优化工具，它可以减小 .wasm 文件大小, 优化指令执行顺序, 提高浏览器的运行效率\n如果你要打包 WebGL 游戏, 可以安装 wasm-opt, 安装过程非常简单, 前往发布页: https://github.com/WebAssembly/binaryen/releases\n下载对应操作系统的预编译版本, 解压后，把 wasm-opt 放到你的 PATH 环境变量中\n可以用我的做参考, 我将解压后的文件夹命名为 wasm-opt 所以我环境变量中配置的是: E:\\Tool\\wasm-opt\\bin\ndotnet 识别不到怎么办dotnet 的默认安装路径都是 C:\\Program Files\\dotnet\n除非你是 32 位电脑, 那么在这个目录: C:\\Program Files (x86)\\dotnet\n但是这基本不可能了对吧, 现在还有谁的电脑是 32 位呢?\n所以直接在环境变量中配置 C:\\Program Files\\dotnet 即可识别到\n常用命令\nspacetime start --listen-addr 0.0.0.0:3000 --data-dir F:\\U-BlackHole\\Data\nspacetime generate -l csharp -o ..&#x2F;Client&#x2F;Assets&#x2F;Assets&#x2F;Script&#x2F;Game.Core&#x2F;Module\nspacetime publish -y -c -s local black-hole\nspacetime publish -y -c -s maincloud black-hole\nspacetime list -s local\nspacetime logs -s local black-hole\nspacetime sql -s local black-hole &quot;SELECT * FROM tb_player_logged_out&quot;\n\n参考链接\nhttps://spacetimedb.com/docs\nhttps://github.com/clockworklabs/SpacetimeDB\nhttps://github.com/ClockworkLabs/Blackholio\nhttps://github.com/clockworklabs/com.clockworklabs.spacetimedbsdk\nhttps://github.com/WebAssembly/binaryen/releases\n\n","categories":["Unity"],"tags":["Unity","SpacetimeDB"]},{"title":"Unity TileMap 瓦片与瓦片之间的线条","url":"/unity/unity_tile_border_line.html","content":"\n\n问题在使用 TileMap 制作 2D 游戏的时候, 发现瓦片与瓦片之间总是存在一条缝隙, 这条缝隙什么颜色的都有, 可是我已经把所有素材的过滤方式都设置为了: &quot;Point (no filter)&quot;, 为什么还会有这个问题呢? 原本以为是瓦片之间没拼接好, 大小没设置对(原谅我没有图形学方面的知识), 后来查阅资料得知, 目前美工在制作 2D 游戏素材时, 基本都会将同类的精灵图放到一张贴图中, 这样紧贴着的两个精灵图在某种特殊情况下就会出现使用了相邻精灵图中像素的问题.\n\n从上面的素材图中可以看到, 多个精灵图组成了一张贴图, 其中中间位置的一张看似像 &quot;车轮印&quot; 的精灵图和右侧一张表示 &quot;海洋&quot; 的贴图相连, 于是在游戏中就会出现这种情况:\n\n代表 &quot;车轮印&quot; 精灵图的右侧就会出现代表 &quot;海洋&quot; 精灵图的一个蓝色的像素, 导致出现了一条蓝色的细线. 实乃万恶之源!\n先说一下已经试过的网友们的方法.\n将 TileMap 的 cell 大小设置为接近 1 的值默认情况下 TileMap 中 cell 的大小为 1 个单位, 瓦片在地图中的大小通常也是一个单位, 于是就想到将 cell 大小设置为比 1 个单位小那么一丢丢, 让最外围的一个像素不显示出来不就好了~ 赶紧尝试一下, 于是:\n\n乍看上去好像没有细线了, 但是放大一下就会发现, 不仅是右侧有蓝色的细线, 现在上方也有了...呃...看来这种方法不适合我啊~\n建立图集听另一位大佬说, 将精灵图添加到图集时, Unity 会自动补全像素, 因此可以作为一个解决此问题的办法, 于是赶紧照着大佬说的操作一番~ 然后:\n\n关于图集的知识我也不是很懂, 总之依旧没有实现比较完美的效果, 或者是让我满意的效果...可以看到图中确实已经没有了蓝色的细线, 但是会发现瓦片与瓦片之间的衔接变得很不自然, 有一条明显的分界线...呃...看来这种方法同样不适合我~\n\n素材分辨率后来我想到了之前做泰拉瑞亚的仿制 demo 时曾出现过的一个情况, 当时自己从网上搞来一批素材, 开始搭建人物. 人物的素材是拆成很多部分的, 我在拼接这些部分的时候发现像素对应不起来, 当时我的解决办法是把图片的分辨率改成了 2 的幂, 当时改成了 64, 然后像素就能对应上了. 同时我也发现 Unity 中有一项 Max Size 的设置, 这里也只支持 2 的幂, 会不会就是这里导致 Unity 会自动补全像素呢? 于是我赶紧将素材都改为了 2 的幂, 256 X 256, 重新导入并设置好后, 神奇的一幕发生了:\n\n而且瓦片与瓦片之间也衔接的不错, 虽然仔细观察还是有瑕疵, 但是这应该是素材自身的问题了!\n\nMSAA 多重采样再到后来编写摄像机脚本的时候, 发现摄像机中有一个 MSAA 的设置选项, 忽然想起之前大佬提到过 MSAA 啊! 赶紧查一下 MSAA 是啥!\nMSAA 是 &quot;多重采样&quot; 技术, 用来实现 &quot;抗锯齿&quot; 的效果. 在不规则图形的渲染中需求比较大. 下面是一张简单表示 MSAA 效果的图片. (引用自文章: 深入剖析MSAA)\n\n由此可见在没有开启 MSAA 时, 一条斜线上的锯齿感非常明显, 开始 MSAA 之后, 斜线上的锯齿感便开始弱化. 理想状态下可以无限接近于真正的斜线.\n但是在我这个项目中, MSAA 反而会形成困扰, 导致瓦片之间衔接不好, 甚至出现前面所说的细线, 毕竟游戏本就是像素风格嘛~ 于是我开始好奇将 MSAA 关闭后会有什么效果呢?\n\n于是我回退到之前没有修改素材分辨率的版本, 找到摄像机中的 MSAA 选项, 选择 &quot;Off&quot;, 然后神奇的一幕又发生了, 关闭 MSAA 后, 也实现了近乎完美的瓦片衔接...\n那我之前耗费那么多时间处理素材是图啥子嘞~ 😭 又吃了没文化的亏~\n总结如果你的项目中也出现了文章中所提到的问题, 不妨尝试尝试这几种方法:\n\n将 TileMap 的 cell 大小设置为接近 1 的值.\n\n建立图集, 在图集的 Padding 处设置自动补全的像素值, 可选: 2 4 8.\n \n\n处理素材的分辨率为 2 的幂.\n\n关闭 MSAA\n\n\n参考文章\n3D 瓦片地图采坑录\n\n深入剖析 MSAA\n\n绘制地图(Tile Map)\n\n图集(Atlas)\n\n\n","categories":["Unity"],"tags":["Unity","TileMap"]},{"title":"在 Unity 中实现 Windows 选择文件","url":"/unity/unity_windows_import.html","content":"\n\n🥦实现思路在 Windows 上实现存档的导入功能, 可以直接调用系统的文件管理器, 选择我们指定类型的文件, 之后代码中进行处理即可\n🌵调用文件管理器系统提供了 GetOpenFileName 函数, 可以调用 Windows 文件管理器, 以下是此函数的使用步骤\n新建数据类[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]internal class OpenFileName&#123;    public int structSize;    public IntPtr dlgOwner;    public IntPtr instance;    public string filter;    public string customFilter;    public int maxCustFilter;    public int filterIndex;    public IntPtr file; // 新风格不能使用 string 存储返回值, 这里使用 IntPtr 存储返回值    public int maxFile;    public string fileTitle;    public int maxFileTitle;    public string initialDir;    public string title;    public int flags;    public short fileOffset;    public short fileExtension;    public string defExt;    public IntPtr custData;    public IntPtr hook;    public string templateName;    public IntPtr reservedPtr;    public int reservedInt;    public int flagsEx;&#125;\n\n引入 DLL/// &lt;summary&gt;/// 打开文件对话框/// &lt;/summary&gt;[DllImport(&quot;ComDLG32.dll&quot;, SetLastError = true, ThrowOnUnmappableChar = true, CharSet = CharSet.Auto)]internal static extern bool GetOpenFileName([In, Out] OpenFileName openFileName);\n\n准备数据var openFileName = new OpenFileName();openFileName.structSize = Marshal.SizeOf(openFileName);openFileName.filter = filter;openFileName.fileTitle = new string(new char[64]);openFileName.maxFileTitle = openFileName.fileTitle.Length;openFileName.initialDir = defaultFolder;openFileName.title = windowTitle;openFileName.templateName = string.Empty;openFileName.flags = 0x00000008 | 0x00000200 | 0x00000800 | 0x00001000 | 0x00080000;// 分配 2KB 缓冲区const int BUFFER_SIZE = 2048;var fileBuffer = Marshal.AllocHGlobal(BUFFER_SIZE * Marshal.SystemDefaultCharSize);// 清空缓冲区，防止残留数据影响for (var index = 0; index &lt; BUFFER_SIZE; index++)&#123;    Marshal.WriteByte(fileBuffer, index, 0);&#125;// 赋值缓冲区openFileName.file = fileBuffer;openFileName.maxFile = BUFFER_SIZE;\n\n打开管理器// 选取文件if (GetOpenFileName(openFileName) == false)&#123;    selectData = null;    return false;&#125;\n\n处理返回值selectedFilesList.Clear();var pointer = fileBuffer;while (true)&#123;    var file = Marshal.PtrToStringAuto(pointer);    if (string.IsNullOrEmpty(file))    &#123;        break;    &#125;    selectedFilesList.Add(file);    pointer += (file.Length + 1) * Marshal.SystemDefaultCharSize;&#125;selectData = selectedFilesList;return selectedFilesList.Count &gt; 0;\n\n释放内存// 释放分配的缓冲区内存Marshal.FreeHGlobal(fileBuffer);\n\n🦄总结\n强烈建议使用新风格的文件管理器, 虽然旧风格的文件管理器返回的值用 空格 来分割, 处理起来更简单, 但是界面巨丑, 操作巨反人类\n使用新风格的文件管理器时要注意, 一定不要使用 string 类型存储返回值, 因为返回值使用 \\0 来分割, 而 C# 中的字符串认为 \\0 是字符串的结束, 因此后面的信息就丢失了\n记得及时释放申请的缓冲区内存\n\n👀完整代码// ReSharper disable NotAccessedField.Globalusing System;using System.Collections.Generic;using System.Runtime.InteropServices;namespace Kuroha.Utility&#123;    public class FileUtilWindows    &#123;        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]        internal class OpenFileName        &#123;            public int structSize;            public IntPtr dlgOwner;            public IntPtr instance;            public string filter;            public string customFilter;            public int maxCustFilter;            public int filterIndex;            public IntPtr file; // 新风格不能使用 string 存储返回值, 这里使用 IntPtr 存储返回值            public int maxFile;            public string fileTitle;            public int maxFileTitle;            public string initialDir;            public string title;            public int flags;            public short fileOffset;            public short fileExtension;            public string defExt;            public IntPtr custData;            public IntPtr hook;            public string templateName;            public IntPtr reservedPtr;            public int reservedInt;            public int flagsEx;        &#125;        /// &lt;summary&gt;        /// 打开文件对话框        /// &lt;/summary&gt;        [DllImport(&quot;ComDLG32.dll&quot;, SetLastError = true, ThrowOnUnmappableChar = true, CharSet = CharSet.Auto)]        internal static extern bool GetOpenFileName([In, Out] OpenFileName openFileName);        private static readonly List&lt;string&gt; selectedFilesList = new List&lt;string&gt;();        /// &lt;summary&gt;        /// 选择多个文件并返回        /// &lt;/summary&gt;        /// &lt;param name=&quot;windowTitle&quot;&gt;弹窗标题&lt;/param&gt;        /// &lt;param name=&quot;defaultFolder&quot;&gt;默认打开的文件夹&lt;/param&gt;        /// &lt;param name=&quot;filter&quot;&gt;文件后缀筛选&lt;/param&gt;        /// &lt;param name=&quot;selectData&quot;&gt;返回选择情况: 多个文件时, 首个数据为文件夹, 后续数据依次为文件名&lt;/param&gt;        /// &lt;returns&gt;未选择时返回 false, 选择文件时返回 true&lt;/returns&gt;        public static bool SelectFiles(string windowTitle, string defaultFolder, string filter, out List&lt;string&gt; selectData)        &#123;            var openFileName = new OpenFileName();            openFileName.structSize = Marshal.SizeOf(openFileName);            openFileName.filter = filter;            openFileName.fileTitle = new string(new char[64]);            openFileName.maxFileTitle = openFileName.fileTitle.Length;            openFileName.initialDir = defaultFolder;            openFileName.title = windowTitle;            openFileName.templateName = string.Empty;            openFileName.flags = 0x00000008 | 0x00000200 | 0x00000800 | 0x00001000 | 0x00080000;            // 分配 2KB 缓冲区            const int BUFFER_SIZE = 2048;            var fileBuffer = Marshal.AllocHGlobal(BUFFER_SIZE * Marshal.SystemDefaultCharSize);            // 清空缓冲区，防止残留数据影响            for (var index = 0; index &lt; BUFFER_SIZE; index++)            &#123;                Marshal.WriteByte(fileBuffer, index, 0);            &#125;            // 赋值缓冲区            openFileName.file = fileBuffer;            openFileName.maxFile = BUFFER_SIZE;            try            &#123;                // 选取文件                if (GetOpenFileName(openFileName) == false)                &#123;                    selectData = null;                    return false;                &#125;                #region 处理返回值                selectedFilesList.Clear();                var pointer = fileBuffer;                while (true)                &#123;                    var file = Marshal.PtrToStringAuto(pointer);                    if (string.IsNullOrEmpty(file))                    &#123;                        break;                    &#125;                    selectedFilesList.Add(file);                    pointer += (file.Length + 1) * Marshal.SystemDefaultCharSize;                &#125;                selectData = selectedFilesList;                return selectedFilesList.Count &gt; 0;                #endregion            &#125;            finally            &#123;                // 释放分配的缓冲区内存                Marshal.FreeHGlobal(fileBuffer);            &#125;        &#125;    &#125;&#125;\n","categories":["Unity"],"tags":["Unity"]}]